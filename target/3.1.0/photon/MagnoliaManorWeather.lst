
c:/Users/Mitch/Documents/Particle/projects/MagnoliaManorWeather/target/3.1.0/photon/MagnoliaManorWeather.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000075f0  080a0020  080a0020  00010020  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .backup       00000004  40024000  080a7610  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000088  20000000  080a7614  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          0000059c  20000088  20000088  00040088  2**3
                  ALLOC
  6 .module_info_suffix 00000028  080a769c  080a769c  0003769c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .module_info_crc 00000004  080a76c4  080a76c4  000376c4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_info   001093e2  00000000  00000000  000376c8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00016562  00000000  00000000  00140aaa  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    00022812  00000000  00000000  0015700c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00002658  00000000  00000000  0017981e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00005a70  00000000  00000000  0017be76  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  000300ba  00000000  00000000  001818e6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   0003d39c  00000000  00000000  001b19a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    000bb8a9  00000000  00000000  001eed3c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  00006cec  00000000  00000000  002aa5e8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080a0020 <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0020:	4809      	ldr	r0, [pc, #36]	; (80a0048 <module_user_pre_init+0x28>)
 80a0022:	490a      	ldr	r1, [pc, #40]	; (80a004c <module_user_pre_init+0x2c>)
void* module_user_pre_init() {
 80a0024:	b508      	push	{r3, lr}
    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0026:	4288      	cmp	r0, r1
 80a0028:	d005      	beq.n	80a0036 <module_user_pre_init+0x16>
 80a002a:	4a09      	ldr	r2, [pc, #36]	; (80a0050 <module_user_pre_init+0x30>)
 80a002c:	4282      	cmp	r2, r0
 80a002e:	d002      	beq.n	80a0036 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a0030:	1a12      	subs	r2, r2, r0
 80a0032:	f006 fdb7 	bl	80a6ba4 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0036:	4807      	ldr	r0, [pc, #28]	; (80a0054 <module_user_pre_init+0x34>)
 80a0038:	4a07      	ldr	r2, [pc, #28]	; (80a0058 <module_user_pre_init+0x38>)
 80a003a:	2100      	movs	r1, #0
 80a003c:	1a12      	subs	r2, r2, r0
 80a003e:	f006 fdbf 	bl	80a6bc0 <memset>
    return &link_heap_start;
}
 80a0042:	4806      	ldr	r0, [pc, #24]	; (80a005c <module_user_pre_init+0x3c>)
 80a0044:	bd08      	pop	{r3, pc}
 80a0046:	bf00      	nop
 80a0048:	20000000 	.word	0x20000000
 80a004c:	080a7614 	.word	0x080a7614
 80a0050:	20000088 	.word	0x20000088
 80a0054:	20000088 	.word	0x20000088
 80a0058:	20000624 	.word	0x20000624
 80a005c:	20000624 	.word	0x20000624

080a0060 <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a0060:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a0062:	f003 fbbf 	bl	80a37e4 <module_user_init_hook>

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0066:	2500      	movs	r5, #0
 80a0068:	4e05      	ldr	r6, [pc, #20]	; (80a0080 <module_user_init+0x20>)
 80a006a:	4c06      	ldr	r4, [pc, #24]	; (80a0084 <module_user_init+0x24>)
 80a006c:	1ba4      	subs	r4, r4, r6
 80a006e:	08a4      	lsrs	r4, r4, #2
 80a0070:	42a5      	cmp	r5, r4
 80a0072:	d100      	bne.n	80a0076 <module_user_init+0x16>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a0074:	bd70      	pop	{r4, r5, r6, pc}
        link_constructors_location[ctor_num]();
 80a0076:	f856 3b04 	ldr.w	r3, [r6], #4
 80a007a:	4798      	blx	r3
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a007c:	3501      	adds	r5, #1
 80a007e:	e7f7      	b.n	80a0070 <module_user_init+0x10>
 80a0080:	080a75e8 	.word	0x080a75e8
 80a0084:	080a7608 	.word	0x080a7608

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 be9e 	b.w	80a0dc8 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f001 f88f 	bl	80a11b0 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _post_loop();
 80a0096:	f003 bb5d 	b.w	80a3754 <_post_loop>

080a009a <_Znwj>:
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size)
{
	return malloc(size);
 80a009a:	f003 b809 	b.w	80a30b0 <malloc>

080a009e <_Znaj>:
 80a009e:	f003 b807 	b.w	80a30b0 <malloc>

080a00a2 <_ZdlPv>:
	return malloc(size);
}

void operator delete(void *p)
{
	free(p);
 80a00a2:	f003 b80d 	b.w	80a30c0 <free>

080a00a6 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00a6:	7800      	ldrb	r0, [r0, #0]
 80a00a8:	fab0 f080 	clz	r0, r0
 80a00ac:	0940      	lsrs	r0, r0, #5
 80a00ae:	4770      	bx	lr

080a00b0 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00b0:	2301      	movs	r3, #1
 80a00b2:	7003      	strb	r3, [r0, #0]
 80a00b4:	4770      	bx	lr
	...

080a00b8 <_Z16publishDelayWTHR6String>:
    return returnCode;
}

// Allows you to remotely change how often the device is publishing to the cloud
// Change the default at the top of the code.
int publishDelayWTHR(String command) {
 80a00b8:	b508      	push	{r3, lr}
    delayPublish = atoi(command) * 1000;
 80a00ba:	6800      	ldr	r0, [r0, #0]
 80a00bc:	f006 fd5c 	bl	80a6b78 <atoi>
 80a00c0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a00c4:	4358      	muls	r0, r3
 80a00c6:	4b01      	ldr	r3, [pc, #4]	; (80a00cc <_Z16publishDelayWTHR6String+0x14>)
 80a00c8:	6018      	str	r0, [r3, #0]
    return delayPublish;
}
 80a00ca:	bd08      	pop	{r3, pc}
 80a00cc:	2000000c 	.word	0x2000000c

080a00d0 <_Z16publishDelayWIND6String>:
int publishDelayWIND(String command) {
 80a00d0:	b508      	push	{r3, lr}
    delayPublish2 = atoi(command) * 1000;
 80a00d2:	6800      	ldr	r0, [r0, #0]
 80a00d4:	f006 fd50 	bl	80a6b78 <atoi>
 80a00d8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a00dc:	4358      	muls	r0, r3
 80a00de:	4b01      	ldr	r3, [pc, #4]	; (80a00e4 <_Z16publishDelayWIND6String+0x14>)
 80a00e0:	6018      	str	r0, [r3, #0]
    return delayPublish2;
}
 80a00e2:	bd08      	pop	{r3, pc}
 80a00e4:	20000010 	.word	0x20000010

080a00e8 <_Z11resetDevice6String>:
// remote reboot of photon
int resetDevice(String command) {
 80a00e8:	b508      	push	{r3, lr}
    System.reset();
 80a00ea:	f003 f85f 	bl	80a31ac <_ZN11SystemClass5resetEv>
    return 0;
}
 80a00ee:	2000      	movs	r0, #0
 80a00f0:	bd08      	pop	{r3, pc}
 80a00f2:	0000      	movs	r0, r0
 80a00f4:	0000      	movs	r0, r0
	...

080a00f8 <_Z7rainIRQv>:
{
 80a00f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a00fa:	f002 fdf7 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
  raintime = millis(); // grab current time
 80a00fe:	4c16      	ldr	r4, [pc, #88]	; (80a0158 <_Z7rainIRQv+0x60>)
  raininterval = raintime - rainlast; // calculate interval between this and last event
 80a0100:	4d16      	ldr	r5, [pc, #88]	; (80a015c <_Z7rainIRQv+0x64>)
  raintime = millis(); // grab current time
 80a0102:	6020      	str	r0, [r4, #0]
  raininterval = raintime - rainlast; // calculate interval between this and last event
 80a0104:	6823      	ldr	r3, [r4, #0]
 80a0106:	682a      	ldr	r2, [r5, #0]
 80a0108:	1a9b      	subs	r3, r3, r2
 80a010a:	4a15      	ldr	r2, [pc, #84]	; (80a0160 <_Z7rainIRQv+0x68>)
 80a010c:	6013      	str	r3, [r2, #0]
    if (raininterval > 10) // ignore switch-bounce glitches less than 10mS after initial edge
 80a010e:	6813      	ldr	r3, [r2, #0]
 80a0110:	2b0a      	cmp	r3, #10
 80a0112:	d91b      	bls.n	80a014c <_Z7rainIRQv+0x54>
    dailyrainin += 0.011; //Each dump is 0.011" of water
 80a0114:	a30e      	add	r3, pc, #56	; (adr r3, 80a0150 <_Z7rainIRQv+0x58>)
 80a0116:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a011a:	4e12      	ldr	r6, [pc, #72]	; (80a0164 <_Z7rainIRQv+0x6c>)
 80a011c:	e9d6 0100 	ldrd	r0, r1, [r6]
 80a0120:	f005 fd12 	bl	80a5b48 <__adddf3>
    rainHour[minutes] += 0.011; //Increase this minute's amount of rain
 80a0124:	4b10      	ldr	r3, [pc, #64]	; (80a0168 <_Z7rainIRQv+0x70>)
    dailyrainin += 0.011; //Each dump is 0.011" of water
 80a0126:	e9c6 0100 	strd	r0, r1, [r6]
    rainHour[minutes] += 0.011; //Increase this minute's amount of rain
 80a012a:	781f      	ldrb	r7, [r3, #0]
 80a012c:	4e0f      	ldr	r6, [pc, #60]	; (80a016c <_Z7rainIRQv+0x74>)
 80a012e:	f856 0027 	ldr.w	r0, [r6, r7, lsl #2]
 80a0132:	f005 fe67 	bl	80a5e04 <__aeabi_f2d>
 80a0136:	a306      	add	r3, pc, #24	; (adr r3, 80a0150 <_Z7rainIRQv+0x58>)
 80a0138:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a013c:	f005 fd04 	bl	80a5b48 <__adddf3>
 80a0140:	f006 f9b0 	bl	80a64a4 <__aeabi_d2f>
 80a0144:	f846 0027 	str.w	r0, [r6, r7, lsl #2]
    rainlast = raintime; // set up for next event
 80a0148:	6823      	ldr	r3, [r4, #0]
 80a014a:	602b      	str	r3, [r5, #0]
}
 80a014c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a014e:	bf00      	nop
 80a0150:	020c49ba 	.word	0x020c49ba
 80a0154:	3f86872b 	.word	0x3f86872b
 80a0158:	20000228 	.word	0x20000228
 80a015c:	20000224 	.word	0x20000224
 80a0160:	20000220 	.word	0x20000220
 80a0164:	200000c0 	.word	0x200000c0
 80a0168:	200000f0 	.word	0x200000f0
 80a016c:	20000128 	.word	0x20000128

080a0170 <_Z9wspeedIRQv>:
{
 80a0170:	b510      	push	{r4, lr}
 80a0172:	f002 fdbb 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
  if (millis() - lastWindIRQ > 10) // Ignore switch-bounce glitches less than 10ms (142MPH max reading) after the reed switch closes
 80a0176:	4c07      	ldr	r4, [pc, #28]	; (80a0194 <_Z9wspeedIRQv+0x24>)
 80a0178:	6823      	ldr	r3, [r4, #0]
 80a017a:	1ac0      	subs	r0, r0, r3
 80a017c:	280a      	cmp	r0, #10
 80a017e:	d907      	bls.n	80a0190 <_Z9wspeedIRQv+0x20>
 80a0180:	f002 fdb4 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
    windClicks++; //There is 1.492MPH for each click per second.
 80a0184:	4a04      	ldr	r2, [pc, #16]	; (80a0198 <_Z9wspeedIRQv+0x28>)
    lastWindIRQ = millis(); //Grab the current time
 80a0186:	6020      	str	r0, [r4, #0]
    windClicks++; //There is 1.492MPH for each click per second.
 80a0188:	7813      	ldrb	r3, [r2, #0]
 80a018a:	3301      	adds	r3, #1
 80a018c:	b2db      	uxtb	r3, r3
 80a018e:	7013      	strb	r3, [r2, #0]
}
 80a0190:	bd10      	pop	{r4, pc}
 80a0192:	bf00      	nop
 80a0194:	200000ec 	.word	0x200000ec
 80a0198:	20000270 	.word	0x20000270

080a019c <_ZN5Print5printIiLi0EEEjT_i.part.0.isra.0>:
    size_t vprintf(bool newline, const char* format, va_list args) __attribute__ ((format(printf, 3, 0)));
};

template <typename T, std::enable_if_t<!std::is_base_of<Printable, T>::value && (std::is_integral<T>::value || std::is_convertible<T, unsigned long long>::value ||
    std::is_convertible<T, long long>::value), int>>
size_t Print::print(T n, int base)
 80a019c:	b570      	push	{r4, r5, r6, lr}
// FIXME: avoids 'comparison of constant '0' with boolean expression is always false'
#if __GNUC__ >= 9
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wbool-compare"
#endif // __GNUC__ >= 9
        if (n < 0 && base == 10) {
 80a019e:	1e0c      	subs	r4, r1, #0
size_t Print::print(T n, int base)
 80a01a0:	4606      	mov	r6, r0
 80a01a2:	4615      	mov	r5, r2
        if (n < 0 && base == 10) {
 80a01a4:	da0b      	bge.n	80a01be <_ZN5Print5printIiLi0EEEjT_i.part.0.isra.0+0x22>
 80a01a6:	2a0a      	cmp	r2, #10
 80a01a8:	d109      	bne.n	80a01be <_ZN5Print5printIiLi0EEEjT_i.part.0.isra.0+0x22>
            t = print('-');
 80a01aa:	212d      	movs	r1, #45	; 0x2d
 80a01ac:	f003 f954 	bl	80a3458 <_ZN5Print5printEc>
            val = -n;
 80a01b0:	4261      	negs	r1, r4
            val = n;
        }
#if __GNUC__ >= 9
#pragma GCC diagnostic pop
#endif // __GNUC__ >= 9
        return printNumber(val, base) + t;
 80a01b2:	4630      	mov	r0, r6
 80a01b4:	b2ea      	uxtb	r2, r5
    }
}
 80a01b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return printNumber(val, base) + t;
 80a01ba:	f003 b966 	b.w	80a348a <_ZN5Print11printNumberEmh>
            val = n;
 80a01be:	4621      	mov	r1, r4
 80a01c0:	e7f7      	b.n	80a01b2 <_ZN5Print5printIiLi0EEEjT_i.part.0.isra.0+0x16>

080a01c2 <_ZN10CloudClass12syncTimeDoneEv.isra.0>:
    bool syncTimePending(void)
    {
        return connected() && spark_sync_time_pending(nullptr);
    }

    bool syncTimeDone(void)
 80a01c2:	b508      	push	{r3, lr}
    {
        return !spark_sync_time_pending(nullptr) || disconnected();
 80a01c4:	2000      	movs	r0, #0
 80a01c6:	f002 ff63 	bl	80a3090 <spark_sync_time_pending>
 80a01ca:	b128      	cbz	r0, 80a01d8 <_ZN10CloudClass12syncTimeDoneEv.isra.0+0x16>
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a01cc:	f002 ff48 	bl	80a3060 <spark_cloud_flag_connected>
        return !spark_sync_time_pending(nullptr) || disconnected();
 80a01d0:	f080 0001 	eor.w	r0, r0, #1
 80a01d4:	b2c0      	uxtb	r0, r0
    }
 80a01d6:	bd08      	pop	{r3, pc}
        return !spark_sync_time_pending(nullptr) || disconnected();
 80a01d8:	2001      	movs	r0, #1
 80a01da:	e7fc      	b.n	80a01d6 <_ZN10CloudClass12syncTimeDoneEv.isra.0+0x14>

080a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>:
        return spark_variable(varKey, (const void*)userVar, T::TYPE_ID, NULL);
 80a01dc:	2300      	movs	r3, #0
 80a01de:	2209      	movs	r2, #9
 80a01e0:	f002 bf26 	b.w	80a3030 <spark_variable>

080a01e4 <_ZN10CloudClass9_variableEPKcRKi.isra.0>:
 80a01e4:	2300      	movs	r3, #0
 80a01e6:	2202      	movs	r2, #2
 80a01e8:	f002 bf22 	b.w	80a3030 <spark_variable>

080a01ec <_Z15getSoilMositurev>:
    else
      soiltempf = (InTempC * 9)/5 + 32;//else grab the newest, good data
}
//---------------------------------------------------------------
void getSoilMositure()
{
 80a01ec:	b508      	push	{r3, lr}
    /*We found through testing that leaving the soil moisture sensor powered
    all the time lead to corrosion of the probes. Thus, this port breaks out
    Digital Pin D5 as the power pin for the sensor, allowing the Photon to
    power the sensor, take a reading, and then disable power on the sensor,
    giving the sensor a longer lifespan.*/
    digitalWrite(SOIL_MOIST_POWER, HIGH);
 80a01ee:	2101      	movs	r1, #1
 80a01f0:	2005      	movs	r0, #5
 80a01f2:	f004 f984 	bl	80a44fe <digitalWrite>
    delay(200);
 80a01f6:	20c8      	movs	r0, #200	; 0xc8
 80a01f8:	f003 fa44 	bl	80a3684 <delay>
    soilMoisture = analogRead(SOIL_MOIST);
 80a01fc:	200b      	movs	r0, #11
 80a01fe:	f004 f9aa 	bl	80a4556 <analogRead>
 80a0202:	4b05      	ldr	r3, [pc, #20]	; (80a0218 <_Z15getSoilMositurev+0x2c>)
 80a0204:	6018      	str	r0, [r3, #0]
    delay(100);
 80a0206:	2064      	movs	r0, #100	; 0x64
 80a0208:	f003 fa3c 	bl	80a3684 <delay>
    digitalWrite(SOIL_MOIST_POWER, LOW);

}
 80a020c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    digitalWrite(SOIL_MOIST_POWER, LOW);
 80a0210:	2100      	movs	r1, #0
 80a0212:	2005      	movs	r0, #5
 80a0214:	f004 b973 	b.w	80a44fe <digitalWrite>
 80a0218:	2000024c 	.word	0x2000024c

080a021c <_Z15update18B20TempPhRd>:
//---------------------------------------------------------------
void update18B20Temp(DeviceAddress deviceAddress, double &tempC)
{
 80a021c:	b510      	push	{r4, lr}
 80a021e:	460c      	mov	r4, r1
  tempC = sensors.getTempC(deviceAddress);
 80a0220:	4601      	mov	r1, r0
 80a0222:	4804      	ldr	r0, [pc, #16]	; (80a0234 <_Z15update18B20TempPhRd+0x18>)
 80a0224:	f001 fdfe 	bl	80a1e24 <_ZN17DallasTemperature8getTempCEPKh>
 80a0228:	f005 fdec 	bl	80a5e04 <__aeabi_f2d>
 80a022c:	e9c4 0100 	strd	r0, r1, [r4]
}
 80a0230:	bd10      	pop	{r4, pc}
 80a0232:	bf00      	nop
 80a0234:	20000230 	.word	0x20000230

080a0238 <_Z11getSoilTempv>:
{
 80a0238:	b538      	push	{r3, r4, r5, lr}
    update18B20Temp(inSoilThermometer, InTempC);
 80a023a:	4c11      	ldr	r4, [pc, #68]	; (80a0280 <_Z11getSoilTempv+0x48>)
    sensors.requestTemperatures();
 80a023c:	4811      	ldr	r0, [pc, #68]	; (80a0284 <_Z11getSoilTempv+0x4c>)
 80a023e:	f001 fda0 	bl	80a1d82 <_ZN17DallasTemperature19requestTemperaturesEv>
    update18B20Temp(inSoilThermometer, InTempC);
 80a0242:	4621      	mov	r1, r4
 80a0244:	4810      	ldr	r0, [pc, #64]	; (80a0288 <_Z11getSoilTempv+0x50>)
 80a0246:	f7ff ffe9 	bl	80a021c <_Z15update18B20TempPhRd>
    if(InTempC < -100)
 80a024a:	cc30      	ldmia	r4, {r4, r5}
 80a024c:	2200      	movs	r2, #0
 80a024e:	4620      	mov	r0, r4
 80a0250:	4629      	mov	r1, r5
 80a0252:	4b0e      	ldr	r3, [pc, #56]	; (80a028c <_Z11getSoilTempv+0x54>)
 80a0254:	f006 f8a0 	bl	80a6398 <__aeabi_dcmplt>
 80a0258:	b980      	cbnz	r0, 80a027c <_Z11getSoilTempv+0x44>
      soiltempf = (InTempC * 9)/5 + 32;//else grab the newest, good data
 80a025a:	2200      	movs	r2, #0
 80a025c:	4b0c      	ldr	r3, [pc, #48]	; (80a0290 <_Z11getSoilTempv+0x58>)
 80a025e:	4620      	mov	r0, r4
 80a0260:	4629      	mov	r1, r5
 80a0262:	f005 fe27 	bl	80a5eb4 <__aeabi_dmul>
 80a0266:	2200      	movs	r2, #0
 80a0268:	4b0a      	ldr	r3, [pc, #40]	; (80a0294 <_Z11getSoilTempv+0x5c>)
 80a026a:	f005 ff4d 	bl	80a6108 <__aeabi_ddiv>
 80a026e:	4b0a      	ldr	r3, [pc, #40]	; (80a0298 <_Z11getSoilTempv+0x60>)
 80a0270:	2200      	movs	r2, #0
 80a0272:	f005 fc69 	bl	80a5b48 <__adddf3>
 80a0276:	4b09      	ldr	r3, [pc, #36]	; (80a029c <_Z11getSoilTempv+0x64>)
 80a0278:	e9c3 0100 	strd	r0, r1, [r3]
}
 80a027c:	bd38      	pop	{r3, r4, r5, pc}
 80a027e:	bf00      	nop
 80a0280:	20000090 	.word	0x20000090
 80a0284:	20000230 	.word	0x20000230
 80a0288:	20000014 	.word	0x20000014
 80a028c:	c0590000 	.word	0xc0590000
 80a0290:	40220000 	.word	0x40220000
 80a0294:	40140000 	.word	0x40140000
 80a0298:	40400000 	.word	0x40400000
 80a029c:	20000250 	.word	0x20000250

080a02a0 <_Z18get_wind_directionv>:
//---------------------------------------------------------------
//Read the wind direction sensor, return heading in degrees
int get_wind_direction()
{
 80a02a0:	b538      	push	{r3, r4, r5, lr}
  unsigned int adc;
  double volts;

  adc = analogRead(WDIR); // get the current reading from the sensor
 80a02a2:	4bc9      	ldr	r3, [pc, #804]	; (80a05c8 <_Z18get_wind_directionv+0x328>)
 80a02a4:	8818      	ldrh	r0, [r3, #0]
 80a02a6:	f004 f956 	bl	80a4556 <analogRead>
  volts = ( ( (double)adc * 3.3)/4095 );
 80a02aa:	f005 fd89 	bl	80a5dc0 <__aeabi_ui2d>
 80a02ae:	a3a0      	add	r3, pc, #640	; (adr r3, 80a0530 <_Z18get_wind_directionv+0x290>)
 80a02b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a02b4:	f005 fdfe 	bl	80a5eb4 <__aeabi_dmul>
 80a02b8:	a39f      	add	r3, pc, #636	; (adr r3, 80a0538 <_Z18get_wind_directionv+0x298>)
 80a02ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a02be:	f005 ff23 	bl	80a6108 <__aeabi_ddiv>
  if(volts > 3.16 && volts < 3.20) return (2700);
  if(volts > 2.96 && volts < 3.00) return (2925);
  if(volts > 3.06 && volts < 3.10) return (3150);
  if(volts > 2.74 && volts < 2.78) return (3375);
*/
  if(volts >= 2.84 && volts < 2.95) return (0);
 80a02c2:	a39f      	add	r3, pc, #636	; (adr r3, 80a0540 <_Z18get_wind_directionv+0x2a0>)
 80a02c4:	e9d3 2300 	ldrd	r2, r3, [r3]
  volts = ( ( (double)adc * 3.3)/4095 );
 80a02c8:	4604      	mov	r4, r0
 80a02ca:	460d      	mov	r5, r1
  if(volts >= 2.84 && volts < 2.95) return (0);
 80a02cc:	f006 f878 	bl	80a63c0 <__aeabi_dcmpge>
 80a02d0:	b148      	cbz	r0, 80a02e6 <_Z18get_wind_directionv+0x46>
 80a02d2:	a39d      	add	r3, pc, #628	; (adr r3, 80a0548 <_Z18get_wind_directionv+0x2a8>)
 80a02d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a02d8:	4620      	mov	r0, r4
 80a02da:	4629      	mov	r1, r5
 80a02dc:	f006 f85c 	bl	80a6398 <__aeabi_dcmplt>
 80a02e0:	2800      	cmp	r0, #0
 80a02e2:	f040 8114 	bne.w	80a050e <_Z18get_wind_directionv+0x26e>
  if(volts >= 1.99 && volts < 2.20) return (225);
 80a02e6:	a39a      	add	r3, pc, #616	; (adr r3, 80a0550 <_Z18get_wind_directionv+0x2b0>)
 80a02e8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a02ec:	4620      	mov	r0, r4
 80a02ee:	4629      	mov	r1, r5
 80a02f0:	f006 f866 	bl	80a63c0 <__aeabi_dcmpge>
 80a02f4:	b148      	cbz	r0, 80a030a <_Z18get_wind_directionv+0x6a>
 80a02f6:	a398      	add	r3, pc, #608	; (adr r3, 80a0558 <_Z18get_wind_directionv+0x2b8>)
 80a02f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a02fc:	4620      	mov	r0, r4
 80a02fe:	4629      	mov	r1, r5
 80a0300:	f006 f84a 	bl	80a6398 <__aeabi_dcmplt>
 80a0304:	2800      	cmp	r0, #0
 80a0306:	f040 8104 	bne.w	80a0512 <_Z18get_wind_directionv+0x272>
  if(volts >= 2.20 && volts < 2.42) return (450);
 80a030a:	a393      	add	r3, pc, #588	; (adr r3, 80a0558 <_Z18get_wind_directionv+0x2b8>)
 80a030c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0310:	4620      	mov	r0, r4
 80a0312:	4629      	mov	r1, r5
 80a0314:	f006 f854 	bl	80a63c0 <__aeabi_dcmpge>
 80a0318:	b148      	cbz	r0, 80a032e <_Z18get_wind_directionv+0x8e>
 80a031a:	a391      	add	r3, pc, #580	; (adr r3, 80a0560 <_Z18get_wind_directionv+0x2c0>)
 80a031c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0320:	4620      	mov	r0, r4
 80a0322:	4629      	mov	r1, r5
 80a0324:	f006 f838 	bl	80a6398 <__aeabi_dcmplt>
 80a0328:	2800      	cmp	r0, #0
 80a032a:	f040 80f4 	bne.w	80a0516 <_Z18get_wind_directionv+0x276>
  if(volts >= 1.24 && volts < 1.27) return (675);
 80a032e:	a38e      	add	r3, pc, #568	; (adr r3, 80a0568 <_Z18get_wind_directionv+0x2c8>)
 80a0330:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0334:	4620      	mov	r0, r4
 80a0336:	4629      	mov	r1, r5
 80a0338:	f006 f842 	bl	80a63c0 <__aeabi_dcmpge>
 80a033c:	b148      	cbz	r0, 80a0352 <_Z18get_wind_directionv+0xb2>
 80a033e:	a38c      	add	r3, pc, #560	; (adr r3, 80a0570 <_Z18get_wind_directionv+0x2d0>)
 80a0340:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0344:	4620      	mov	r0, r4
 80a0346:	4629      	mov	r1, r5
 80a0348:	f006 f826 	bl	80a6398 <__aeabi_dcmplt>
 80a034c:	2800      	cmp	r0, #0
 80a034e:	f040 80e5 	bne.w	80a051c <_Z18get_wind_directionv+0x27c>
  if(volts >= 1.27 && volts < 1.35) return (900);
 80a0352:	a387      	add	r3, pc, #540	; (adr r3, 80a0570 <_Z18get_wind_directionv+0x2d0>)
 80a0354:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0358:	4620      	mov	r0, r4
 80a035a:	4629      	mov	r1, r5
 80a035c:	f006 f830 	bl	80a63c0 <__aeabi_dcmpge>
 80a0360:	b148      	cbz	r0, 80a0376 <_Z18get_wind_directionv+0xd6>
 80a0362:	a385      	add	r3, pc, #532	; (adr r3, 80a0578 <_Z18get_wind_directionv+0x2d8>)
 80a0364:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0368:	4620      	mov	r0, r4
 80a036a:	4629      	mov	r1, r5
 80a036c:	f006 f814 	bl	80a6398 <__aeabi_dcmplt>
 80a0370:	2800      	cmp	r0, #0
 80a0372:	f040 80d6 	bne.w	80a0522 <_Z18get_wind_directionv+0x282>
  if(volts >= 1.18 && volts < 1.24) return (1125);
 80a0376:	a382      	add	r3, pc, #520	; (adr r3, 80a0580 <_Z18get_wind_directionv+0x2e0>)
 80a0378:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a037c:	4620      	mov	r0, r4
 80a037e:	4629      	mov	r1, r5
 80a0380:	f006 f81e 	bl	80a63c0 <__aeabi_dcmpge>
 80a0384:	b148      	cbz	r0, 80a039a <_Z18get_wind_directionv+0xfa>
 80a0386:	a378      	add	r3, pc, #480	; (adr r3, 80a0568 <_Z18get_wind_directionv+0x2c8>)
 80a0388:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a038c:	4620      	mov	r0, r4
 80a038e:	4629      	mov	r1, r5
 80a0390:	f006 f802 	bl	80a6398 <__aeabi_dcmplt>
 80a0394:	2800      	cmp	r0, #0
 80a0396:	f040 80c7 	bne.w	80a0528 <_Z18get_wind_directionv+0x288>
  if(volts >= 1.48 && volts < 1.65) return (1350);
 80a039a:	a37b      	add	r3, pc, #492	; (adr r3, 80a0588 <_Z18get_wind_directionv+0x2e8>)
 80a039c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a03a0:	4620      	mov	r0, r4
 80a03a2:	4629      	mov	r1, r5
 80a03a4:	f006 f80c 	bl	80a63c0 <__aeabi_dcmpge>
 80a03a8:	b148      	cbz	r0, 80a03be <_Z18get_wind_directionv+0x11e>
 80a03aa:	a379      	add	r3, pc, #484	; (adr r3, 80a0590 <_Z18get_wind_directionv+0x2f0>)
 80a03ac:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a03b0:	4620      	mov	r0, r4
 80a03b2:	4629      	mov	r1, r5
 80a03b4:	f005 fff0 	bl	80a6398 <__aeabi_dcmplt>
 80a03b8:	2800      	cmp	r0, #0
 80a03ba:	f040 8107 	bne.w	80a05cc <_Z18get_wind_directionv+0x32c>
  if(volts >= 1.35 && volts < 1.48) return (1575);
 80a03be:	a36e      	add	r3, pc, #440	; (adr r3, 80a0578 <_Z18get_wind_directionv+0x2d8>)
 80a03c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a03c4:	4620      	mov	r0, r4
 80a03c6:	4629      	mov	r1, r5
 80a03c8:	f005 fffa 	bl	80a63c0 <__aeabi_dcmpge>
 80a03cc:	b148      	cbz	r0, 80a03e2 <_Z18get_wind_directionv+0x142>
 80a03ce:	a36e      	add	r3, pc, #440	; (adr r3, 80a0588 <_Z18get_wind_directionv+0x2e8>)
 80a03d0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a03d4:	4620      	mov	r0, r4
 80a03d6:	4629      	mov	r1, r5
 80a03d8:	f005 ffde 	bl	80a6398 <__aeabi_dcmplt>
 80a03dc:	2800      	cmp	r0, #0
 80a03de:	f040 80f8 	bne.w	80a05d2 <_Z18get_wind_directionv+0x332>
  if(volts >= 1.79 && volts < 1.99) return (1800);
 80a03e2:	a36d      	add	r3, pc, #436	; (adr r3, 80a0598 <_Z18get_wind_directionv+0x2f8>)
 80a03e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a03e8:	4620      	mov	r0, r4
 80a03ea:	4629      	mov	r1, r5
 80a03ec:	f005 ffe8 	bl	80a63c0 <__aeabi_dcmpge>
 80a03f0:	b148      	cbz	r0, 80a0406 <_Z18get_wind_directionv+0x166>
 80a03f2:	a357      	add	r3, pc, #348	; (adr r3, 80a0550 <_Z18get_wind_directionv+0x2b0>)
 80a03f4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a03f8:	4620      	mov	r0, r4
 80a03fa:	4629      	mov	r1, r5
 80a03fc:	f005 ffcc 	bl	80a6398 <__aeabi_dcmplt>
 80a0400:	2800      	cmp	r0, #0
 80a0402:	f040 80e9 	bne.w	80a05d8 <_Z18get_wind_directionv+0x338>
  if(volts >= 1.65 && volts < 1.79) return (2025);
 80a0406:	a362      	add	r3, pc, #392	; (adr r3, 80a0590 <_Z18get_wind_directionv+0x2f0>)
 80a0408:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a040c:	4620      	mov	r0, r4
 80a040e:	4629      	mov	r1, r5
 80a0410:	f005 ffd6 	bl	80a63c0 <__aeabi_dcmpge>
 80a0414:	b148      	cbz	r0, 80a042a <_Z18get_wind_directionv+0x18a>
 80a0416:	a360      	add	r3, pc, #384	; (adr r3, 80a0598 <_Z18get_wind_directionv+0x2f8>)
 80a0418:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a041c:	4620      	mov	r0, r4
 80a041e:	4629      	mov	r1, r5
 80a0420:	f005 ffba 	bl	80a6398 <__aeabi_dcmplt>
 80a0424:	2800      	cmp	r0, #0
 80a0426:	f040 80da 	bne.w	80a05de <_Z18get_wind_directionv+0x33e>
  if(volts >= 2.60 && volts < 2.70) return (2250);
 80a042a:	a35d      	add	r3, pc, #372	; (adr r3, 80a05a0 <_Z18get_wind_directionv+0x300>)
 80a042c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0430:	4620      	mov	r0, r4
 80a0432:	4629      	mov	r1, r5
 80a0434:	f005 ffc4 	bl	80a63c0 <__aeabi_dcmpge>
 80a0438:	b148      	cbz	r0, 80a044e <_Z18get_wind_directionv+0x1ae>
 80a043a:	a35b      	add	r3, pc, #364	; (adr r3, 80a05a8 <_Z18get_wind_directionv+0x308>)
 80a043c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0440:	4620      	mov	r0, r4
 80a0442:	4629      	mov	r1, r5
 80a0444:	f005 ffa8 	bl	80a6398 <__aeabi_dcmplt>
 80a0448:	2800      	cmp	r0, #0
 80a044a:	f040 80cb 	bne.w	80a05e4 <_Z18get_wind_directionv+0x344>
  if(volts >= 2.42 && volts < 2.60) return (2475);
 80a044e:	a344      	add	r3, pc, #272	; (adr r3, 80a0560 <_Z18get_wind_directionv+0x2c0>)
 80a0450:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0454:	4620      	mov	r0, r4
 80a0456:	4629      	mov	r1, r5
 80a0458:	f005 ffb2 	bl	80a63c0 <__aeabi_dcmpge>
 80a045c:	b148      	cbz	r0, 80a0472 <_Z18get_wind_directionv+0x1d2>
 80a045e:	a350      	add	r3, pc, #320	; (adr r3, 80a05a0 <_Z18get_wind_directionv+0x300>)
 80a0460:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0464:	4620      	mov	r0, r4
 80a0466:	4629      	mov	r1, r5
 80a0468:	f005 ff96 	bl	80a6398 <__aeabi_dcmplt>
 80a046c:	2800      	cmp	r0, #0
 80a046e:	f040 80bc 	bne.w	80a05ea <_Z18get_wind_directionv+0x34a>
  if(volts >= 3.14 && volts < 3.21) return (2700);
 80a0472:	a34f      	add	r3, pc, #316	; (adr r3, 80a05b0 <_Z18get_wind_directionv+0x310>)
 80a0474:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0478:	4620      	mov	r0, r4
 80a047a:	4629      	mov	r1, r5
 80a047c:	f005 ffa0 	bl	80a63c0 <__aeabi_dcmpge>
 80a0480:	b148      	cbz	r0, 80a0496 <_Z18get_wind_directionv+0x1f6>
 80a0482:	a34d      	add	r3, pc, #308	; (adr r3, 80a05b8 <_Z18get_wind_directionv+0x318>)
 80a0484:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0488:	4620      	mov	r0, r4
 80a048a:	4629      	mov	r1, r5
 80a048c:	f005 ff84 	bl	80a6398 <__aeabi_dcmplt>
 80a0490:	2800      	cmp	r0, #0
 80a0492:	f040 80ad 	bne.w	80a05f0 <_Z18get_wind_directionv+0x350>
  if(volts >= 2.95 && volts < 3.04) return (2925);
 80a0496:	a32c      	add	r3, pc, #176	; (adr r3, 80a0548 <_Z18get_wind_directionv+0x2a8>)
 80a0498:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a049c:	4620      	mov	r0, r4
 80a049e:	4629      	mov	r1, r5
 80a04a0:	f005 ff8e 	bl	80a63c0 <__aeabi_dcmpge>
 80a04a4:	b148      	cbz	r0, 80a04ba <_Z18get_wind_directionv+0x21a>
 80a04a6:	a346      	add	r3, pc, #280	; (adr r3, 80a05c0 <_Z18get_wind_directionv+0x320>)
 80a04a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a04ac:	4620      	mov	r0, r4
 80a04ae:	4629      	mov	r1, r5
 80a04b0:	f005 ff72 	bl	80a6398 <__aeabi_dcmplt>
 80a04b4:	2800      	cmp	r0, #0
 80a04b6:	f040 809e 	bne.w	80a05f6 <_Z18get_wind_directionv+0x356>
  if(volts >= 3.04 && volts < 3.14) return (3150);
 80a04ba:	a341      	add	r3, pc, #260	; (adr r3, 80a05c0 <_Z18get_wind_directionv+0x320>)
 80a04bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a04c0:	4620      	mov	r0, r4
 80a04c2:	4629      	mov	r1, r5
 80a04c4:	f005 ff7c 	bl	80a63c0 <__aeabi_dcmpge>
 80a04c8:	b148      	cbz	r0, 80a04de <_Z18get_wind_directionv+0x23e>
 80a04ca:	a339      	add	r3, pc, #228	; (adr r3, 80a05b0 <_Z18get_wind_directionv+0x310>)
 80a04cc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a04d0:	4620      	mov	r0, r4
 80a04d2:	4629      	mov	r1, r5
 80a04d4:	f005 ff60 	bl	80a6398 <__aeabi_dcmplt>
 80a04d8:	2800      	cmp	r0, #0
 80a04da:	f040 808f 	bne.w	80a05fc <_Z18get_wind_directionv+0x35c>
  if(volts >= 2.70 && volts < 2.84) return (3375);
 80a04de:	a332      	add	r3, pc, #200	; (adr r3, 80a05a8 <_Z18get_wind_directionv+0x308>)
 80a04e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a04e4:	4620      	mov	r0, r4
 80a04e6:	4629      	mov	r1, r5
 80a04e8:	f005 ff6a 	bl	80a63c0 <__aeabi_dcmpge>
 80a04ec:	2800      	cmp	r0, #0
 80a04ee:	f000 8088 	beq.w	80a0602 <_Z18get_wind_directionv+0x362>
 80a04f2:	a313      	add	r3, pc, #76	; (adr r3, 80a0540 <_Z18get_wind_directionv+0x2a0>)
 80a04f4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a04f8:	4620      	mov	r0, r4
 80a04fa:	4629      	mov	r1, r5
 80a04fc:	f005 ff4c 	bl	80a6398 <__aeabi_dcmplt>


  return (-1); // error, disconnected?
 80a0500:	2800      	cmp	r0, #0
 80a0502:	f640 502f 	movw	r0, #3375	; 0xd2f
 80a0506:	bf08      	it	eq
 80a0508:	f04f 30ff 	moveq.w	r0, #4294967295
}
 80a050c:	bd38      	pop	{r3, r4, r5, pc}
  if(volts >= 2.84 && volts < 2.95) return (0);
 80a050e:	2000      	movs	r0, #0
 80a0510:	e7fc      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 1.99 && volts < 2.20) return (225);
 80a0512:	20e1      	movs	r0, #225	; 0xe1
 80a0514:	e7fa      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 2.20 && volts < 2.42) return (450);
 80a0516:	f44f 70e1 	mov.w	r0, #450	; 0x1c2
 80a051a:	e7f7      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 1.24 && volts < 1.27) return (675);
 80a051c:	f240 20a3 	movw	r0, #675	; 0x2a3
 80a0520:	e7f4      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 1.27 && volts < 1.35) return (900);
 80a0522:	f44f 7061 	mov.w	r0, #900	; 0x384
 80a0526:	e7f1      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 1.18 && volts < 1.24) return (1125);
 80a0528:	f240 4065 	movw	r0, #1125	; 0x465
 80a052c:	e7ee      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
 80a052e:	bf00      	nop
 80a0530:	66666666 	.word	0x66666666
 80a0534:	400a6666 	.word	0x400a6666
 80a0538:	00000000 	.word	0x00000000
 80a053c:	40affe00 	.word	0x40affe00
 80a0540:	eb851eb8 	.word	0xeb851eb8
 80a0544:	4006b851 	.word	0x4006b851
 80a0548:	9999999a 	.word	0x9999999a
 80a054c:	40079999 	.word	0x40079999
 80a0550:	3d70a3d7 	.word	0x3d70a3d7
 80a0554:	3fffd70a 	.word	0x3fffd70a
 80a0558:	9999999a 	.word	0x9999999a
 80a055c:	40019999 	.word	0x40019999
 80a0560:	f5c28f5c 	.word	0xf5c28f5c
 80a0564:	40035c28 	.word	0x40035c28
 80a0568:	3d70a3d7 	.word	0x3d70a3d7
 80a056c:	3ff3d70a 	.word	0x3ff3d70a
 80a0570:	851eb852 	.word	0x851eb852
 80a0574:	3ff451eb 	.word	0x3ff451eb
 80a0578:	9999999a 	.word	0x9999999a
 80a057c:	3ff59999 	.word	0x3ff59999
 80a0580:	ae147ae1 	.word	0xae147ae1
 80a0584:	3ff2e147 	.word	0x3ff2e147
 80a0588:	7ae147ae 	.word	0x7ae147ae
 80a058c:	3ff7ae14 	.word	0x3ff7ae14
 80a0590:	66666666 	.word	0x66666666
 80a0594:	3ffa6666 	.word	0x3ffa6666
 80a0598:	0a3d70a4 	.word	0x0a3d70a4
 80a059c:	3ffca3d7 	.word	0x3ffca3d7
 80a05a0:	cccccccd 	.word	0xcccccccd
 80a05a4:	4004cccc 	.word	0x4004cccc
 80a05a8:	9999999a 	.word	0x9999999a
 80a05ac:	40059999 	.word	0x40059999
 80a05b0:	51eb851f 	.word	0x51eb851f
 80a05b4:	40091eb8 	.word	0x40091eb8
 80a05b8:	7ae147ae 	.word	0x7ae147ae
 80a05bc:	4009ae14 	.word	0x4009ae14
 80a05c0:	851eb852 	.word	0x851eb852
 80a05c4:	400851eb 	.word	0x400851eb
 80a05c8:	20000004 	.word	0x20000004
  if(volts >= 1.48 && volts < 1.65) return (1350);
 80a05cc:	f240 5046 	movw	r0, #1350	; 0x546
 80a05d0:	e79c      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 1.35 && volts < 1.48) return (1575);
 80a05d2:	f240 6027 	movw	r0, #1575	; 0x627
 80a05d6:	e799      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 1.79 && volts < 1.99) return (1800);
 80a05d8:	f44f 60e1 	mov.w	r0, #1800	; 0x708
 80a05dc:	e796      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 1.65 && volts < 1.79) return (2025);
 80a05de:	f240 70e9 	movw	r0, #2025	; 0x7e9
 80a05e2:	e793      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 2.60 && volts < 2.70) return (2250);
 80a05e4:	f640 00ca 	movw	r0, #2250	; 0x8ca
 80a05e8:	e790      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 2.42 && volts < 2.60) return (2475);
 80a05ea:	f640 10ab 	movw	r0, #2475	; 0x9ab
 80a05ee:	e78d      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 3.14 && volts < 3.21) return (2700);
 80a05f0:	f640 208c 	movw	r0, #2700	; 0xa8c
 80a05f4:	e78a      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 2.95 && volts < 3.04) return (2925);
 80a05f6:	f640 306d 	movw	r0, #2925	; 0xb6d
 80a05fa:	e787      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  if(volts >= 3.04 && volts < 3.14) return (3150);
 80a05fc:	f640 404e 	movw	r0, #3150	; 0xc4e
 80a0600:	e784      	b.n	80a050c <_Z18get_wind_directionv+0x26c>
  return (-1); // error, disconnected?
 80a0602:	f04f 30ff 	mov.w	r0, #4294967295
 80a0606:	e781      	b.n	80a050c <_Z18get_wind_directionv+0x26c>

080a0608 <_Z14get_wind_speedv>:
//---------------------------------------------------------------
//Returns the instataneous wind speed
float get_wind_speed()
{
 80a0608:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a060a:	f002 fb6f 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
  float deltaTime = millis() - lastWindCheck; //750ms
 80a060e:	4e14      	ldr	r6, [pc, #80]	; (80a0660 <_Z14get_wind_speedv+0x58>)

  deltaTime /= 1000.0; //Covert to seconds

  float windSpeed = (float)windClicks / deltaTime; //3 / 0.750s = 4
 80a0610:	4f14      	ldr	r7, [pc, #80]	; (80a0664 <_Z14get_wind_speedv+0x5c>)
  float deltaTime = millis() - lastWindCheck; //750ms
 80a0612:	6833      	ldr	r3, [r6, #0]
 80a0614:	1ac0      	subs	r0, r0, r3
 80a0616:	f006 f84b 	bl	80a66b0 <__aeabi_ui2f>
 80a061a:	4605      	mov	r5, r0
  float windSpeed = (float)windClicks / deltaTime; //3 / 0.750s = 4
 80a061c:	7838      	ldrb	r0, [r7, #0]
 80a061e:	f006 f847 	bl	80a66b0 <__aeabi_ui2f>
  deltaTime /= 1000.0; //Covert to seconds
 80a0622:	4911      	ldr	r1, [pc, #68]	; (80a0668 <_Z14get_wind_speedv+0x60>)
  float windSpeed = (float)windClicks / deltaTime; //3 / 0.750s = 4
 80a0624:	4604      	mov	r4, r0
  deltaTime /= 1000.0; //Covert to seconds
 80a0626:	4628      	mov	r0, r5
 80a0628:	f006 f94e 	bl	80a68c8 <__aeabi_fdiv>
 80a062c:	4601      	mov	r1, r0
  float windSpeed = (float)windClicks / deltaTime; //3 / 0.750s = 4
 80a062e:	4620      	mov	r0, r4
 80a0630:	f006 f94a 	bl	80a68c8 <__aeabi_fdiv>

  windClicks = 0; //Reset and start watching for new wind
 80a0634:	2300      	movs	r3, #0
  float windSpeed = (float)windClicks / deltaTime; //3 / 0.750s = 4
 80a0636:	4604      	mov	r4, r0
  windClicks = 0; //Reset and start watching for new wind
 80a0638:	703b      	strb	r3, [r7, #0]
 80a063a:	f002 fb57 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
  lastWindCheck = millis();
 80a063e:	6030      	str	r0, [r6, #0]

  windSpeed *= 1.492; //4 * 1.492 = 5.968MPH
 80a0640:	4620      	mov	r0, r4
 80a0642:	f005 fbdf 	bl	80a5e04 <__aeabi_f2d>
 80a0646:	a304      	add	r3, pc, #16	; (adr r3, 80a0658 <_Z14get_wind_speedv+0x50>)
 80a0648:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a064c:	f005 fc32 	bl	80a5eb4 <__aeabi_dmul>
 80a0650:	f005 ff28 	bl	80a64a4 <__aeabi_d2f>
  /* Serial.println();
   Serial.print("Windspeed:");
   Serial.println(windSpeed);*/

  return(windSpeed);
}
 80a0654:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a0656:	bf00      	nop
 80a0658:	645a1cac 	.word	0x645a1cac
 80a065c:	3ff7df3b 	.word	0x3ff7df3b
 80a0660:	200000e8 	.word	0x200000e8
 80a0664:	20000270 	.word	0x20000270
 80a0668:	447a0000 	.word	0x447a0000
 80a066c:	00000000 	.word	0x00000000

080a0670 <_Z10getWeatherv>:
//---------------------------------------------------------------
void getWeather()
{
 80a0670:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // Measure Relative Humidity from the HTU21D or Si7021
    humidity = sensor.getRH();
 80a0674:	488c      	ldr	r0, [pc, #560]	; (80a08a8 <_Z10getWeatherv+0x238>)
 80a0676:	f001 fecb 	bl	80a2410 <_ZN7Weather5getRHEv>
 80a067a:	f005 fbc3 	bl	80a5e04 <__aeabi_f2d>
 80a067e:	4b8b      	ldr	r3, [pc, #556]	; (80a08ac <_Z10getWeatherv+0x23c>)
    //Calc windgustdir
    //Report the largest windgust today
//    windgustmph = 0;
//    windgustdir = 0;
    //Take a speed and direction reading every second for 2 minute average
    if(++seconds_2m > 119) seconds_2m = 0;
 80a0680:	4d8b      	ldr	r5, [pc, #556]	; (80a08b0 <_Z10getWeatherv+0x240>)
    humidity = sensor.getRH();
 80a0682:	e9c3 0100 	strd	r0, r1, [r3]
    tempf = sensor.getTempF() - TEMPERATURE_OFFSET_F;
 80a0686:	4888      	ldr	r0, [pc, #544]	; (80a08a8 <_Z10getWeatherv+0x238>)
 80a0688:	f001 ff02 	bl	80a2490 <_ZN7Weather8getTempFEv>
 80a068c:	f005 fbba 	bl	80a5e04 <__aeabi_f2d>
 80a0690:	2200      	movs	r2, #0
 80a0692:	4b88      	ldr	r3, [pc, #544]	; (80a08b4 <_Z10getWeatherv+0x244>)
 80a0694:	f005 fa56 	bl	80a5b44 <__aeabi_dsub>
 80a0698:	4b87      	ldr	r3, [pc, #540]	; (80a08b8 <_Z10getWeatherv+0x248>)
 80a069a:	e9c3 0100 	strd	r0, r1, [r3]
    tempc = sensor.getTemp() - TEMPERATURE_OFFSET_C;
 80a069e:	4882      	ldr	r0, [pc, #520]	; (80a08a8 <_Z10getWeatherv+0x238>)
 80a06a0:	f001 fed2 	bl	80a2448 <_ZN7Weather7getTempEv>
 80a06a4:	f005 fbae 	bl	80a5e04 <__aeabi_f2d>
 80a06a8:	a37d      	add	r3, pc, #500	; (adr r3, 80a08a0 <_Z10getWeatherv+0x230>)
 80a06aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a06ae:	f005 fa49 	bl	80a5b44 <__aeabi_dsub>
 80a06b2:	4b82      	ldr	r3, [pc, #520]	; (80a08bc <_Z10getWeatherv+0x24c>)
 80a06b4:	e9c3 0100 	strd	r0, r1, [r3]
    baroTemp = sensor.readBaroTempF() - TEMPERATURE_OFFSET_F;
 80a06b8:	487b      	ldr	r0, [pc, #492]	; (80a08a8 <_Z10getWeatherv+0x238>)
 80a06ba:	f002 f883 	bl	80a27c4 <_ZN7Weather13readBaroTempFEv>
 80a06be:	f005 fba1 	bl	80a5e04 <__aeabi_f2d>
 80a06c2:	2200      	movs	r2, #0
 80a06c4:	4b7b      	ldr	r3, [pc, #492]	; (80a08b4 <_Z10getWeatherv+0x244>)
 80a06c6:	f005 fa3d 	bl	80a5b44 <__aeabi_dsub>
 80a06ca:	4b7d      	ldr	r3, [pc, #500]	; (80a08c0 <_Z10getWeatherv+0x250>)
 80a06cc:	e9c3 0100 	strd	r0, r1, [r3]
    pascals = sensor.readPressure();
 80a06d0:	4875      	ldr	r0, [pc, #468]	; (80a08a8 <_Z10getWeatherv+0x238>)
 80a06d2:	f001 ffbd 	bl	80a2650 <_ZN7Weather12readPressureEv>
 80a06d6:	f005 fb95 	bl	80a5e04 <__aeabi_f2d>
 80a06da:	4b7a      	ldr	r3, [pc, #488]	; (80a08c4 <_Z10getWeatherv+0x254>)
 80a06dc:	e9c3 0100 	strd	r0, r1, [r3]
    getSoilTemp();//Read the DS18B20 waterproof temp sensor
 80a06e0:	f7ff fdaa 	bl	80a0238 <_Z11getSoilTempv>
    getSoilMositure();//Read the soil moisture sensor
 80a06e4:	f7ff fd82 	bl	80a01ec <_Z15getSoilMositurev>
    if(++seconds_2m > 119) seconds_2m = 0;
 80a06e8:	782b      	ldrb	r3, [r5, #0]
 80a06ea:	3301      	adds	r3, #1
 80a06ec:	b2db      	uxtb	r3, r3
 80a06ee:	2b77      	cmp	r3, #119	; 0x77
 80a06f0:	bf88      	it	hi
 80a06f2:	2300      	movhi	r3, #0
 80a06f4:	702b      	strb	r3, [r5, #0]

    //Calc the wind speed and direction every second for 120 second to get 2 minute average
    float currentSpeed = get_wind_speed();
 80a06f6:	f7ff ff87 	bl	80a0608 <_Z14get_wind_speedv>
 80a06fa:	4682      	mov	sl, r0
    //float currentSpeed = random(5); //For testing
    int currentDirection = get_wind_direction();
 80a06fc:	f7ff fdd0 	bl	80a02a0 <_Z18get_wind_directionv>
    if (currentDirection == -1)
 80a0700:	1c43      	adds	r3, r0, #1
    int currentDirection = get_wind_direction();
 80a0702:	4604      	mov	r4, r0
    if (currentDirection == -1)
 80a0704:	d102      	bne.n	80a070c <_Z10getWeatherv+0x9c>
    {
       currentDirection = get_wind_direction(); // retry once
 80a0706:	f7ff fdcb 	bl	80a02a0 <_Z18get_wind_directionv>
 80a070a:	4604      	mov	r4, r0
    }

    winddir = currentDirection;
 80a070c:	4b6e      	ldr	r3, [pc, #440]	; (80a08c8 <_Z10getWeatherv+0x258>)
    windspeedmph = currentSpeed;
 80a070e:	4650      	mov	r0, sl
    winddir = currentDirection;
 80a0710:	601c      	str	r4, [r3, #0]
    windspeedmph = currentSpeed;
 80a0712:	f005 fb77 	bl	80a5e04 <__aeabi_f2d>
 80a0716:	460f      	mov	r7, r1
 80a0718:	4606      	mov	r6, r0
 80a071a:	4b6c      	ldr	r3, [pc, #432]	; (80a08cc <_Z10getWeatherv+0x25c>)

    windspdavg[seconds_2m] = (int)currentSpeed;
 80a071c:	4650      	mov	r0, sl
    windspeedmph = currentSpeed;
 80a071e:	e9c3 6700 	strd	r6, r7, [r3]
    windspdavg[seconds_2m] = (int)currentSpeed;
 80a0722:	f006 f9e3 	bl	80a6aec <__aeabi_f2iz>
 80a0726:	782d      	ldrb	r5, [r5, #0]
 80a0728:	4b69      	ldr	r3, [pc, #420]	; (80a08d0 <_Z10getWeatherv+0x260>)
    winddiravg[seconds_2m] = currentDirection;
    //if(seconds_2m % 10 == 0) displayArrays(); //For testing

    //Check to see if this is a gust for the minute
    if(currentSpeed > windgust_10m[minutes_10m])
 80a072a:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 80a08d4 <_Z10getWeatherv+0x264>
    windspdavg[seconds_2m] = (int)currentSpeed;
 80a072e:	5558      	strb	r0, [r3, r5]
    winddiravg[seconds_2m] = currentDirection;
 80a0730:	4b69      	ldr	r3, [pc, #420]	; (80a08d8 <_Z10getWeatherv+0x268>)
    if(currentSpeed > windgust_10m[minutes_10m])
 80a0732:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 80a08dc <_Z10getWeatherv+0x26c>
    winddiravg[seconds_2m] = currentDirection;
 80a0736:	f843 4025 	str.w	r4, [r3, r5, lsl #2]
    if(currentSpeed > windgust_10m[minutes_10m])
 80a073a:	f898 5000 	ldrb.w	r5, [r8]
 80a073e:	4651      	mov	r1, sl
 80a0740:	f859 0025 	ldr.w	r0, [r9, r5, lsl #2]
 80a0744:	f006 f9aa 	bl	80a6a9c <__aeabi_fcmplt>
 80a0748:	b120      	cbz	r0, 80a0754 <_Z10getWeatherv+0xe4>
    {
      windgust_10m[minutes_10m] = currentSpeed;
      windgustdirection_10m[minutes_10m] = currentDirection;
 80a074a:	4b65      	ldr	r3, [pc, #404]	; (80a08e0 <_Z10getWeatherv+0x270>)
      windgust_10m[minutes_10m] = currentSpeed;
 80a074c:	f849 a025 	str.w	sl, [r9, r5, lsl #2]
      windgustdirection_10m[minutes_10m] = currentDirection;
 80a0750:	f843 4025 	str.w	r4, [r3, r5, lsl #2]
    }

    //Check to see if this is a gust for the day
    if(currentSpeed > windgustmph)
 80a0754:	f8df a18c 	ldr.w	sl, [pc, #396]	; 80a08e4 <_Z10getWeatherv+0x274>
 80a0758:	4630      	mov	r0, r6
 80a075a:	e9da 2300 	ldrd	r2, r3, [sl]
 80a075e:	4639      	mov	r1, r7
 80a0760:	f005 fe38 	bl	80a63d4 <__aeabi_dcmpgt>
 80a0764:	b118      	cbz	r0, 80a076e <_Z10getWeatherv+0xfe>
    {
      windgustmph = currentSpeed;
      windgustdir = currentDirection;
 80a0766:	4b60      	ldr	r3, [pc, #384]	; (80a08e8 <_Z10getWeatherv+0x278>)
      windgustmph = currentSpeed;
 80a0768:	e9ca 6700 	strd	r6, r7, [sl]
      windgustdir = currentDirection;
 80a076c:	601c      	str	r4, [r3, #0]
    }

    if(++seconds > 59)
 80a076e:	4a5f      	ldr	r2, [pc, #380]	; (80a08ec <_Z10getWeatherv+0x27c>)
 80a0770:	2100      	movs	r1, #0
 80a0772:	7813      	ldrb	r3, [r2, #0]
 80a0774:	3301      	adds	r3, #1
 80a0776:	b2db      	uxtb	r3, r3
 80a0778:	2b3b      	cmp	r3, #59	; 0x3b
 80a077a:	d872      	bhi.n	80a0862 <_Z10getWeatherv+0x1f2>
 80a077c:	7013      	strb	r3, [r2, #0]
    }


    //Calc windspdmph_avg2m
    float temp = 0;
    for(int i = 0 ; i < 120 ; i++)
 80a077e:	2500      	movs	r5, #0
    float temp = 0;
 80a0780:	2400      	movs	r4, #0
 80a0782:	4e53      	ldr	r6, [pc, #332]	; (80a08d0 <_Z10getWeatherv+0x260>)
      temp += windspdavg[i];
 80a0784:	f816 0b01 	ldrb.w	r0, [r6], #1
 80a0788:	f005 ff96 	bl	80a66b8 <__aeabi_i2f>
 80a078c:	4601      	mov	r1, r0
 80a078e:	4620      	mov	r0, r4
 80a0790:	f005 fede 	bl	80a6550 <__addsf3>
    for(int i = 0 ; i < 120 ; i++)
 80a0794:	3501      	adds	r5, #1
 80a0796:	2d78      	cmp	r5, #120	; 0x78
      temp += windspdavg[i];
 80a0798:	4604      	mov	r4, r0
    for(int i = 0 ; i < 120 ; i++)
 80a079a:	d1f3      	bne.n	80a0784 <_Z10getWeatherv+0x114>
    temp /= 120.0;
 80a079c:	4954      	ldr	r1, [pc, #336]	; (80a08f0 <_Z10getWeatherv+0x280>)
 80a079e:	f006 f893 	bl	80a68c8 <__aeabi_fdiv>
    windspdmph_avg2m = temp;
 80a07a2:	f005 fb2f 	bl	80a5e04 <__aeabi_f2d>

    //Calc winddir_avg2m
    temp = 0; //Can't use winddir_avg2m because it's an int
    for(int i = 0 ; i < 120 ; i++)
 80a07a6:	2500      	movs	r5, #0
    temp = 0; //Can't use winddir_avg2m because it's an int
 80a07a8:	2400      	movs	r4, #0
    windspdmph_avg2m = temp;
 80a07aa:	4b52      	ldr	r3, [pc, #328]	; (80a08f4 <_Z10getWeatherv+0x284>)
 80a07ac:	4e4a      	ldr	r6, [pc, #296]	; (80a08d8 <_Z10getWeatherv+0x268>)
 80a07ae:	e9c3 0100 	strd	r0, r1, [r3]
      temp += winddiravg[i];
 80a07b2:	f856 0b04 	ldr.w	r0, [r6], #4
 80a07b6:	f005 ff7f 	bl	80a66b8 <__aeabi_i2f>
 80a07ba:	4601      	mov	r1, r0
 80a07bc:	4620      	mov	r0, r4
 80a07be:	f005 fec7 	bl	80a6550 <__addsf3>
    for(int i = 0 ; i < 120 ; i++)
 80a07c2:	3501      	adds	r5, #1
 80a07c4:	2d78      	cmp	r5, #120	; 0x78
      temp += winddiravg[i];
 80a07c6:	4604      	mov	r4, r0
    for(int i = 0 ; i < 120 ; i++)
 80a07c8:	d1f3      	bne.n	80a07b2 <_Z10getWeatherv+0x142>

    //Calc windgustmph_10m
    //Calc windgustdir_10m
    //Find the largest windgust in the last 10 minutes
    windgustmph_10m = 0;
    windgustdir_10m = 0;
 80a07ca:	2400      	movs	r4, #0
    temp /= 120;
 80a07cc:	4948      	ldr	r1, [pc, #288]	; (80a08f0 <_Z10getWeatherv+0x280>)
 80a07ce:	f006 f87b 	bl	80a68c8 <__aeabi_fdiv>
    winddir_avg2m = temp;
 80a07d2:	f006 f98b 	bl	80a6aec <__aeabi_f2iz>
    windgustmph_10m = 0;
 80a07d6:	2600      	movs	r6, #0
 80a07d8:	2700      	movs	r7, #0
    windgustdir_10m = 0;
 80a07da:	46a1      	mov	r9, r4
    //Step through the 10 minutes
    for(int i = 0; i < 10 ; i++)
 80a07dc:	4625      	mov	r5, r4
    winddir_avg2m = temp;
 80a07de:	4b46      	ldr	r3, [pc, #280]	; (80a08f8 <_Z10getWeatherv+0x288>)
    windgustmph_10m = 0;
 80a07e0:	f8df 8118 	ldr.w	r8, [pc, #280]	; 80a08fc <_Z10getWeatherv+0x28c>
    winddir_avg2m = temp;
 80a07e4:	6018      	str	r0, [r3, #0]
    windgustmph_10m = 0;
 80a07e6:	e9c8 6700 	strd	r6, r7, [r8]
    windgustdir_10m = 0;
 80a07ea:	4b45      	ldr	r3, [pc, #276]	; (80a0900 <_Z10getWeatherv+0x290>)
 80a07ec:	f8df a0ec 	ldr.w	sl, [pc, #236]	; 80a08dc <_Z10getWeatherv+0x26c>
    {
      if(windgust_10m[i] > windgustmph_10m)
      {
        windgustmph_10m = windgust_10m[i];
        windgustdir_10m = windgustdirection_10m[i];
 80a07f0:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 80a08e0 <_Z10getWeatherv+0x270>
    windgustdir_10m = 0;
 80a07f4:	601c      	str	r4, [r3, #0]
      if(windgust_10m[i] > windgustmph_10m)
 80a07f6:	f85a 0b04 	ldr.w	r0, [sl], #4
 80a07fa:	f005 fb03 	bl	80a5e04 <__aeabi_f2d>
 80a07fe:	4602      	mov	r2, r0
 80a0800:	460b      	mov	r3, r1
 80a0802:	e9cd 2300 	strd	r2, r3, [sp]
 80a0806:	4632      	mov	r2, r6
 80a0808:	463b      	mov	r3, r7
 80a080a:	f005 fde3 	bl	80a63d4 <__aeabi_dcmpgt>
 80a080e:	b128      	cbz	r0, 80a081c <_Z10getWeatherv+0x1ac>
        windgustmph_10m = windgust_10m[i];
 80a0810:	e9dd 6700 	ldrd	r6, r7, [sp]
 80a0814:	f04f 0901 	mov.w	r9, #1
        windgustdir_10m = windgustdirection_10m[i];
 80a0818:	f85b 4025 	ldr.w	r4, [fp, r5, lsl #2]
    for(int i = 0; i < 10 ; i++)
 80a081c:	3501      	adds	r5, #1
 80a081e:	2d0a      	cmp	r5, #10
 80a0820:	d1e9      	bne.n	80a07f6 <_Z10getWeatherv+0x186>
 80a0822:	f1b9 0f00 	cmp.w	r9, #0
 80a0826:	d003      	beq.n	80a0830 <_Z10getWeatherv+0x1c0>
 80a0828:	4b35      	ldr	r3, [pc, #212]	; (80a0900 <_Z10getWeatherv+0x290>)
 80a082a:	e9c8 6700 	strd	r6, r7, [r8]
 80a082e:	601c      	str	r4, [r3, #0]
    }

    //Total rainfall for the day is calculated within the interrupt
    //Calculate amount of rainfall for the last 60 minutes
    rainin = 0;
    for(int i = 0 ; i < 60 ; i++)
 80a0830:	2400      	movs	r4, #0
 80a0832:	2500      	movs	r5, #0
 80a0834:	2600      	movs	r6, #0
      rainin += rainHour[i];
 80a0836:	4f33      	ldr	r7, [pc, #204]	; (80a0904 <_Z10getWeatherv+0x294>)
 80a0838:	f857 0026 	ldr.w	r0, [r7, r6, lsl #2]
 80a083c:	f005 fae2 	bl	80a5e04 <__aeabi_f2d>
 80a0840:	4602      	mov	r2, r0
 80a0842:	460b      	mov	r3, r1
 80a0844:	4620      	mov	r0, r4
 80a0846:	4629      	mov	r1, r5
 80a0848:	f005 f97e 	bl	80a5b48 <__adddf3>
    for(int i = 0 ; i < 60 ; i++)
 80a084c:	3601      	adds	r6, #1
 80a084e:	2e3c      	cmp	r6, #60	; 0x3c
      rainin += rainHour[i];
 80a0850:	4604      	mov	r4, r0
 80a0852:	460d      	mov	r5, r1
    for(int i = 0 ; i < 60 ; i++)
 80a0854:	d1f0      	bne.n	80a0838 <_Z10getWeatherv+0x1c8>
 80a0856:	4b2c      	ldr	r3, [pc, #176]	; (80a0908 <_Z10getWeatherv+0x298>)
 80a0858:	e9c3 4500 	strd	r4, r5, [r3]
}
 80a085c:	b003      	add	sp, #12
 80a085e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      seconds = 0;
 80a0862:	2000      	movs	r0, #0
 80a0864:	7010      	strb	r0, [r2, #0]
      if(++minutes > 59) minutes = 0;
 80a0866:	4a29      	ldr	r2, [pc, #164]	; (80a090c <_Z10getWeatherv+0x29c>)
      if(++minutes_10m > 9) minutes_10m = 0;
 80a0868:	3501      	adds	r5, #1
      if(++minutes > 59) minutes = 0;
 80a086a:	7813      	ldrb	r3, [r2, #0]
      if(++minutes_10m > 9) minutes_10m = 0;
 80a086c:	b2ed      	uxtb	r5, r5
      if(++minutes > 59) minutes = 0;
 80a086e:	3301      	adds	r3, #1
 80a0870:	b2db      	uxtb	r3, r3
 80a0872:	2b3b      	cmp	r3, #59	; 0x3b
 80a0874:	bf94      	ite	ls
 80a0876:	7013      	strbls	r3, [r2, #0]
 80a0878:	7010      	strbhi	r0, [r2, #0]
      if(++minutes_10m > 9) minutes_10m = 0;
 80a087a:	2d09      	cmp	r5, #9
 80a087c:	bf88      	it	hi
 80a087e:	2300      	movhi	r3, #0
      rainHour[minutes] = 0; //Zero out this minute's rainfall amount
 80a0880:	7812      	ldrb	r2, [r2, #0]
      if(++minutes_10m > 9) minutes_10m = 0;
 80a0882:	bf88      	it	hi
 80a0884:	f888 3000 	strbhi.w	r3, [r8]
      rainHour[minutes] = 0; //Zero out this minute's rainfall amount
 80a0888:	4b1e      	ldr	r3, [pc, #120]	; (80a0904 <_Z10getWeatherv+0x294>)
      if(++minutes_10m > 9) minutes_10m = 0;
 80a088a:	bf98      	it	ls
 80a088c:	f888 5000 	strbls.w	r5, [r8]
      rainHour[minutes] = 0; //Zero out this minute's rainfall amount
 80a0890:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      windgust_10m[minutes_10m] = 0; //Zero out this minute's gust
 80a0894:	f898 3000 	ldrb.w	r3, [r8]
 80a0898:	f849 1023 	str.w	r1, [r9, r3, lsl #2]
 80a089c:	e76f      	b.n	80a077e <_Z10getWeatherv+0x10e>
 80a089e:	bf00      	nop
 80a08a0:	34d6a162 	.word	0x34d6a162
 80a08a4:	400638ef 	.word	0x400638ef
 80a08a8:	2000022e 	.word	0x2000022e
 80a08ac:	200000d0 	.word	0x200000d0
 80a08b0:	2000022d 	.word	0x2000022d
 80a08b4:	40140000 	.word	0x40140000
 80a08b8:	20000268 	.word	0x20000268
 80a08bc:	20000260 	.word	0x20000260
 80a08c0:	200000b0 	.word	0x200000b0
 80a08c4:	20000120 	.word	0x20000120
 80a08c8:	20000274 	.word	0x20000274
 80a08cc:	20000548 	.word	0x20000548
 80a08d0:	200004c8 	.word	0x200004c8
 80a08d4:	200000f1 	.word	0x200000f1
 80a08d8:	2000027c 	.word	0x2000027c
 80a08dc:	2000045c 	.word	0x2000045c
 80a08e0:	2000048c 	.word	0x2000048c
 80a08e4:	200004b8 	.word	0x200004b8
 80a08e8:	20000484 	.word	0x20000484
 80a08ec:	2000022c 	.word	0x2000022c
 80a08f0:	42f00000 	.word	0x42f00000
 80a08f4:	20000540 	.word	0x20000540
 80a08f8:	20000278 	.word	0x20000278
 80a08fc:	200004c0 	.word	0x200004c0
 80a0900:	20000488 	.word	0x20000488
 80a0904:	20000128 	.word	0x20000128
 80a0908:	20000218 	.word	0x20000218
 80a090c:	200000f0 	.word	0x200000f0

080a0910 <_Z12printRunTimev>:

//Prints the amount of time the board has been running
//Does the hour, minute, and second calcs
void printRunTime()
{
 80a0910:	b570      	push	{r4, r5, r6, lr}
 80a0912:	b090      	sub	sp, #64	; 0x40
 80a0914:	f002 f9ea 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
  char buffer[50];

  unsigned long runTime = millis();

  int hours = runTime / (60 * 60 * 1000L);
  runTime %= (60 * 60 * 1000L);
 80a0918:	4e12      	ldr	r6, [pc, #72]	; (80a0964 <_Z12printRunTimev+0x54>)
  int minutes = runTime / (60 * 1000L);
 80a091a:	f64e 2160 	movw	r1, #60000	; 0xea60
  runTime %= (60 * 60 * 1000L);
 80a091e:	fbb0 f2f6 	udiv	r2, r0, r6
 80a0922:	fb06 0512 	mls	r5, r6, r2, r0
  int minutes = runTime / (60 * 1000L);
 80a0926:	fbb5 f3f1 	udiv	r3, r5, r1
 80a092a:	4604      	mov	r4, r0
  runTime %= (60 * 1000L);
  int seconds = runTime / 1000L;
 80a092c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  runTime %= (60 * 1000L);
 80a0930:	fb01 5113 	mls	r1, r1, r3, r5
  int seconds = runTime / 1000L;
 80a0934:	fbb1 f1f0 	udiv	r1, r1, r0

  sprintf(buffer, "RunTime[%02d:%02d:%02d]", hours, minutes, seconds);
 80a0938:	a803      	add	r0, sp, #12
 80a093a:	9100      	str	r1, [sp, #0]
 80a093c:	490a      	ldr	r1, [pc, #40]	; (80a0968 <_Z12printRunTimev+0x58>)
 80a093e:	f002 fbcf 	bl	80a30e0 <sprintf>
  SERIAL_PORT.print(buffer);
 80a0942:	f003 fbe1 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0946:	a903      	add	r1, sp, #12
 80a0948:	f002 fd82 	bl	80a3450 <_ZN5Print5printEPKc>

  if (hours == 0 && minutes < 20) SERIAL_PORT.print(" RunTime Not yet valid");
 80a094c:	42b4      	cmp	r4, r6
 80a094e:	d207      	bcs.n	80a0960 <_Z12printRunTimev+0x50>
 80a0950:	4b06      	ldr	r3, [pc, #24]	; (80a096c <_Z12printRunTimev+0x5c>)
 80a0952:	429d      	cmp	r5, r3
 80a0954:	d804      	bhi.n	80a0960 <_Z12printRunTimev+0x50>
 80a0956:	f003 fbd7 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a095a:	4905      	ldr	r1, [pc, #20]	; (80a0970 <_Z12printRunTimev+0x60>)
 80a095c:	f002 fd78 	bl	80a3450 <_ZN5Print5printEPKc>
}
 80a0960:	b010      	add	sp, #64	; 0x40
 80a0962:	bd70      	pop	{r4, r5, r6, pc}
 80a0964:	0036ee80 	.word	0x0036ee80
 80a0968:	080a6dd0 	.word	0x080a6dd0
 80a096c:	00124f7f 	.word	0x00124f7f
 80a0970:	080a6de8 	.word	0x080a6de8

080a0974 <_Z9printInfov>:
{
 80a0974:	b537      	push	{r0, r1, r2, r4, r5, lr}
      SERIAL_PORT.print("Wind_Dir:");
 80a0976:	f003 fbc7 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a097a:	49bb      	ldr	r1, [pc, #748]	; (80a0c68 <_Z9printInfov+0x2f4>)
 80a097c:	f002 fd68 	bl	80a3450 <_ZN5Print5printEPKc>
      switch (winddir)
 80a0980:	4bba      	ldr	r3, [pc, #744]	; (80a0c6c <_Z9printInfov+0x2f8>)
 80a0982:	681b      	ldr	r3, [r3, #0]
 80a0984:	f5b3 6fe1 	cmp.w	r3, #1800	; 0x708
 80a0988:	f000 815a 	beq.w	80a0c40 <_Z9printInfov+0x2cc>
 80a098c:	dc2c      	bgt.n	80a09e8 <_Z9printInfov+0x74>
 80a098e:	f5b3 7f61 	cmp.w	r3, #900	; 0x384
 80a0992:	f000 8149 	beq.w	80a0c28 <_Z9printInfov+0x2b4>
 80a0996:	dc15      	bgt.n	80a09c4 <_Z9printInfov+0x50>
 80a0998:	f5b3 7fe1 	cmp.w	r3, #450	; 0x1c2
 80a099c:	f000 8140 	beq.w	80a0c20 <_Z9printInfov+0x2ac>
 80a09a0:	dc08      	bgt.n	80a09b4 <_Z9printInfov+0x40>
 80a09a2:	2b00      	cmp	r3, #0
 80a09a4:	d04a      	beq.n	80a0a3c <_Z9printInfov+0xc8>
 80a09a6:	2be1      	cmp	r3, #225	; 0xe1
 80a09a8:	f000 8136 	beq.w	80a0c18 <_Z9printInfov+0x2a4>
          SERIAL_PORT.print("No Wind");
 80a09ac:	f003 fbac 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a09b0:	49af      	ldr	r1, [pc, #700]	; (80a0c70 <_Z9printInfov+0x2fc>)
 80a09b2:	e046      	b.n	80a0a42 <_Z9printInfov+0xce>
      switch (winddir)
 80a09b4:	f240 22a3 	movw	r2, #675	; 0x2a3
 80a09b8:	4293      	cmp	r3, r2
 80a09ba:	d1f7      	bne.n	80a09ac <_Z9printInfov+0x38>
          SERIAL_PORT.print("ENE");
 80a09bc:	f003 fba4 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a09c0:	49ac      	ldr	r1, [pc, #688]	; (80a0c74 <_Z9printInfov+0x300>)
 80a09c2:	e03e      	b.n	80a0a42 <_Z9printInfov+0xce>
      switch (winddir)
 80a09c4:	f240 5246 	movw	r2, #1350	; 0x546
 80a09c8:	4293      	cmp	r3, r2
 80a09ca:	f000 8131 	beq.w	80a0c30 <_Z9printInfov+0x2bc>
 80a09ce:	f240 6227 	movw	r2, #1575	; 0x627
 80a09d2:	4293      	cmp	r3, r2
 80a09d4:	f000 8130 	beq.w	80a0c38 <_Z9printInfov+0x2c4>
 80a09d8:	f240 4265 	movw	r2, #1125	; 0x465
 80a09dc:	4293      	cmp	r3, r2
 80a09de:	d1e5      	bne.n	80a09ac <_Z9printInfov+0x38>
          SERIAL_PORT.print("ESE");
 80a09e0:	f003 fb92 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a09e4:	49a4      	ldr	r1, [pc, #656]	; (80a0c78 <_Z9printInfov+0x304>)
 80a09e6:	e02c      	b.n	80a0a42 <_Z9printInfov+0xce>
      switch (winddir)
 80a09e8:	f640 228c 	movw	r2, #2700	; 0xa8c
 80a09ec:	4293      	cmp	r3, r2
 80a09ee:	f000 8133 	beq.w	80a0c58 <_Z9printInfov+0x2e4>
 80a09f2:	dc11      	bgt.n	80a0a18 <_Z9printInfov+0xa4>
 80a09f4:	f640 02ca 	movw	r2, #2250	; 0x8ca
 80a09f8:	4293      	cmp	r3, r2
 80a09fa:	f000 8125 	beq.w	80a0c48 <_Z9printInfov+0x2d4>
 80a09fe:	f640 12ab 	movw	r2, #2475	; 0x9ab
 80a0a02:	4293      	cmp	r3, r2
 80a0a04:	f000 8124 	beq.w	80a0c50 <_Z9printInfov+0x2dc>
 80a0a08:	f240 72e9 	movw	r2, #2025	; 0x7e9
 80a0a0c:	4293      	cmp	r3, r2
 80a0a0e:	d1cd      	bne.n	80a09ac <_Z9printInfov+0x38>
          SERIAL_PORT.print("SSW");
 80a0a10:	f003 fb7a 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a14:	4999      	ldr	r1, [pc, #612]	; (80a0c7c <_Z9printInfov+0x308>)
 80a0a16:	e014      	b.n	80a0a42 <_Z9printInfov+0xce>
      switch (winddir)
 80a0a18:	f640 424e 	movw	r2, #3150	; 0xc4e
 80a0a1c:	4293      	cmp	r3, r2
 80a0a1e:	f000 811f 	beq.w	80a0c60 <_Z9printInfov+0x2ec>
 80a0a22:	f640 522f 	movw	r2, #3375	; 0xd2f
 80a0a26:	4293      	cmp	r3, r2
 80a0a28:	f000 8180 	beq.w	80a0d2c <_Z9printInfov+0x3b8>
 80a0a2c:	f640 326d 	movw	r2, #2925	; 0xb6d
 80a0a30:	4293      	cmp	r3, r2
 80a0a32:	d1bb      	bne.n	80a09ac <_Z9printInfov+0x38>
          SERIAL_PORT.print("WNW");
 80a0a34:	f003 fb68 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a38:	4991      	ldr	r1, [pc, #580]	; (80a0c80 <_Z9printInfov+0x30c>)
 80a0a3a:	e002      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("North");
 80a0a3c:	f003 fb64 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a40:	4990      	ldr	r1, [pc, #576]	; (80a0c84 <_Z9printInfov+0x310>)
          SERIAL_PORT.print("No Wind");
 80a0a42:	f002 fd05 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(" Wind_Speed:");
 80a0a46:	f003 fb5f 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a4a:	498f      	ldr	r1, [pc, #572]	; (80a0c88 <_Z9printInfov+0x314>)
 80a0a4c:	f002 fd00 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(windspeedmph, 1);
 80a0a50:	f003 fb5a 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a54:	2301      	movs	r3, #1
      SERIAL_PORT.print(rainin, 2);
 80a0a56:	2402      	movs	r4, #2
      SERIAL_PORT.print(windspeedmph, 1);
 80a0a58:	9300      	str	r3, [sp, #0]
 80a0a5a:	4b8c      	ldr	r3, [pc, #560]	; (80a0c8c <_Z9printInfov+0x318>)
 80a0a5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0a60:	f002 fdf2 	bl	80a3648 <_ZN5Print5printEdi>
      SERIAL_PORT.print("mph, ");
 80a0a64:	f003 fb50 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a68:	4989      	ldr	r1, [pc, #548]	; (80a0c90 <_Z9printInfov+0x31c>)
 80a0a6a:	f002 fcf1 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("Rain:");
 80a0a6e:	f003 fb4b 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a72:	4988      	ldr	r1, [pc, #544]	; (80a0c94 <_Z9printInfov+0x320>)
 80a0a74:	f002 fcec 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(rainin, 2);
 80a0a78:	f003 fb46 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a7c:	4b86      	ldr	r3, [pc, #536]	; (80a0c98 <_Z9printInfov+0x324>)
 80a0a7e:	9400      	str	r4, [sp, #0]
 80a0a80:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0a84:	f002 fde0 	bl	80a3648 <_ZN5Print5printEdi>
      SERIAL_PORT.print("in., ");
 80a0a88:	f003 fb3e 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a8c:	4983      	ldr	r1, [pc, #524]	; (80a0c9c <_Z9printInfov+0x328>)
 80a0a8e:	f002 fcdf 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("Daily Rain:");
 80a0a92:	f003 fb39 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0a96:	4982      	ldr	r1, [pc, #520]	; (80a0ca0 <_Z9printInfov+0x32c>)
 80a0a98:	f002 fcda 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(dailyrainin, 2);
 80a0a9c:	f003 fb34 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0aa0:	4b80      	ldr	r3, [pc, #512]	; (80a0ca4 <_Z9printInfov+0x330>)
 80a0aa2:	9400      	str	r4, [sp, #0]
 80a0aa4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0aa8:	f002 fdce 	bl	80a3648 <_ZN5Print5printEdi>
      SERIAL_PORT.print("in., ");
 80a0aac:	f003 fb2c 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0ab0:	497a      	ldr	r1, [pc, #488]	; (80a0c9c <_Z9printInfov+0x328>)
 80a0ab2:	f002 fccd 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("Temp:");
 80a0ab6:	f003 fb27 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0aba:	497b      	ldr	r1, [pc, #492]	; (80a0ca8 <_Z9printInfov+0x334>)
 80a0abc:	f002 fcc8 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(tempf);
 80a0ac0:	f003 fb22 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0ac4:	4b79      	ldr	r3, [pc, #484]	; (80a0cac <_Z9printInfov+0x338>)
 80a0ac6:	9400      	str	r4, [sp, #0]
 80a0ac8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0acc:	f002 fdbc 	bl	80a3648 <_ZN5Print5printEdi>
      SERIAL_PORT.print("F, ");
 80a0ad0:	f003 fb1a 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0ad4:	4976      	ldr	r1, [pc, #472]	; (80a0cb0 <_Z9printInfov+0x33c>)
 80a0ad6:	f002 fcbb 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("Humidity:");
 80a0ada:	f003 fb15 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0ade:	4975      	ldr	r1, [pc, #468]	; (80a0cb4 <_Z9printInfov+0x340>)
 80a0ae0:	f002 fcb6 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(humidity);
 80a0ae4:	f003 fb10 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0ae8:	4b73      	ldr	r3, [pc, #460]	; (80a0cb8 <_Z9printInfov+0x344>)
 80a0aea:	9400      	str	r4, [sp, #0]
 80a0aec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0af0:	f002 fdaa 	bl	80a3648 <_ZN5Print5printEdi>
      SERIAL_PORT.print("%%, ");
 80a0af4:	f003 fb08 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0af8:	4970      	ldr	r1, [pc, #448]	; (80a0cbc <_Z9printInfov+0x348>)
 80a0afa:	f002 fca9 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("Baro_Temp:");
 80a0afe:	f003 fb03 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b02:	496f      	ldr	r1, [pc, #444]	; (80a0cc0 <_Z9printInfov+0x34c>)
 80a0b04:	f002 fca4 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(baroTemp);
 80a0b08:	f003 fafe 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b0c:	4b6d      	ldr	r3, [pc, #436]	; (80a0cc4 <_Z9printInfov+0x350>)
 80a0b0e:	9400      	str	r4, [sp, #0]
 80a0b10:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0b14:	f002 fd98 	bl	80a3648 <_ZN5Print5printEdi>
      SERIAL_PORT.print("F, ");
 80a0b18:	f003 faf6 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b1c:	4964      	ldr	r1, [pc, #400]	; (80a0cb0 <_Z9printInfov+0x33c>)
 80a0b1e:	f002 fc97 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("Pressure:");
 80a0b22:	f003 faf1 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b26:	4968      	ldr	r1, [pc, #416]	; (80a0cc8 <_Z9printInfov+0x354>)
 80a0b28:	f002 fc92 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(pascals/100);
 80a0b2c:	f003 faec 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b30:	4966      	ldr	r1, [pc, #408]	; (80a0ccc <_Z9printInfov+0x358>)
 80a0b32:	4605      	mov	r5, r0
 80a0b34:	e9d1 0100 	ldrd	r0, r1, [r1]
 80a0b38:	2200      	movs	r2, #0
 80a0b3a:	4b65      	ldr	r3, [pc, #404]	; (80a0cd0 <_Z9printInfov+0x35c>)
 80a0b3c:	f005 fae4 	bl	80a6108 <__aeabi_ddiv>
 80a0b40:	9400      	str	r4, [sp, #0]
 80a0b42:	4602      	mov	r2, r0
 80a0b44:	460b      	mov	r3, r1
 80a0b46:	4628      	mov	r0, r5
 80a0b48:	f002 fd7e 	bl	80a3648 <_ZN5Print5printEdi>
      SERIAL_PORT.print("hPa, ");
 80a0b4c:	f003 fadc 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b50:	4960      	ldr	r1, [pc, #384]	; (80a0cd4 <_Z9printInfov+0x360>)
 80a0b52:	f002 fc7d 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("Soil_Temp:");
 80a0b56:	f003 fad7 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b5a:	495f      	ldr	r1, [pc, #380]	; (80a0cd8 <_Z9printInfov+0x364>)
 80a0b5c:	f002 fc78 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(soiltempf);
 80a0b60:	f003 fad2 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b64:	4b5d      	ldr	r3, [pc, #372]	; (80a0cdc <_Z9printInfov+0x368>)
 80a0b66:	9400      	str	r4, [sp, #0]
 80a0b68:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0b6c:	f002 fd6c 	bl	80a3648 <_ZN5Print5printEdi>
      SERIAL_PORT.print("F, ");
 80a0b70:	f003 faca 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b74:	494e      	ldr	r1, [pc, #312]	; (80a0cb0 <_Z9printInfov+0x33c>)
 80a0b76:	f002 fc6b 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("Soil_Mositure:");
 80a0b7a:	f003 fac5 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b7e:	4958      	ldr	r1, [pc, #352]	; (80a0ce0 <_Z9printInfov+0x36c>)
 80a0b80:	f002 fc66 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(soilMoisture);
 80a0b84:	f003 fac0 	bl	80a4108 <_Z22__fetch_global_Serial1v>
size_t Print::print(T n, int base)
 80a0b88:	4b56      	ldr	r3, [pc, #344]	; (80a0ce4 <_Z9printInfov+0x370>)
 80a0b8a:	220a      	movs	r2, #10
 80a0b8c:	6819      	ldr	r1, [r3, #0]
 80a0b8e:	f7ff fb05 	bl	80a019c <_ZN5Print5printIiLi0EEEjT_i.part.0.isra.0>
      SERIAL_PORT.print(" ");
 80a0b92:	f003 fab9 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0b96:	4954      	ldr	r1, [pc, #336]	; (80a0ce8 <_Z9printInfov+0x374>)
 80a0b98:	f002 fc5a 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("Luminous_Flux:");
 80a0b9c:	f003 fab4 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0ba0:	4952      	ldr	r1, [pc, #328]	; (80a0cec <_Z9printInfov+0x378>)
 80a0ba2:	f002 fc55 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(LuminousFlux,6);
 80a0ba6:	f003 faaf 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0baa:	2306      	movs	r3, #6
 80a0bac:	9300      	str	r3, [sp, #0]
 80a0bae:	4b50      	ldr	r3, [pc, #320]	; (80a0cf0 <_Z9printInfov+0x37c>)
 80a0bb0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0bb4:	f002 fd48 	bl	80a3648 <_ZN5Print5printEdi>
      SERIAL_PORT.print(" ");
 80a0bb8:	f003 faa6 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0bbc:	494a      	ldr	r1, [pc, #296]	; (80a0ce8 <_Z9printInfov+0x374>)
 80a0bbe:	f002 fc47 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("CO2:");
 80a0bc2:	f003 faa1 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0bc6:	494b      	ldr	r1, [pc, #300]	; (80a0cf4 <_Z9printInfov+0x380>)
 80a0bc8:	f002 fc42 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(airCO2);
 80a0bcc:	f003 fa9c 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0bd0:	4b49      	ldr	r3, [pc, #292]	; (80a0cf8 <_Z9printInfov+0x384>)
 80a0bd2:	220a      	movs	r2, #10
 80a0bd4:	6819      	ldr	r1, [r3, #0]
 80a0bd6:	f7ff fae1 	bl	80a019c <_ZN5Print5printIiLi0EEEjT_i.part.0.isra.0>
      SERIAL_PORT.print(" ");
 80a0bda:	f003 fa95 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0bde:	4942      	ldr	r1, [pc, #264]	; (80a0ce8 <_Z9printInfov+0x374>)
 80a0be0:	f002 fc36 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("tVOC:");
 80a0be4:	f003 fa90 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0be8:	4944      	ldr	r1, [pc, #272]	; (80a0cfc <_Z9printInfov+0x388>)
 80a0bea:	f002 fc31 	bl	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print(airTVOC);
 80a0bee:	f003 fa8b 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0bf2:	4b43      	ldr	r3, [pc, #268]	; (80a0d00 <_Z9printInfov+0x38c>)
 80a0bf4:	220a      	movs	r2, #10
 80a0bf6:	6819      	ldr	r1, [r3, #0]
 80a0bf8:	f7ff fad0 	bl	80a019c <_ZN5Print5printIiLi0EEEjT_i.part.0.isra.0>
      SERIAL_PORT.print(" ");
 80a0bfc:	f003 fa84 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c00:	4939      	ldr	r1, [pc, #228]	; (80a0ce8 <_Z9printInfov+0x374>)
 80a0c02:	f002 fc25 	bl	80a3450 <_ZN5Print5printEPKc>
      printRunTime();
 80a0c06:	f7ff fe83 	bl	80a0910 <_Z12printRunTimev>
      SERIAL_PORT.println();
 80a0c0a:	f003 fa7d 	bl	80a4108 <_Z22__fetch_global_Serial1v>
}
 80a0c0e:	b003      	add	sp, #12
 80a0c10:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
      SERIAL_PORT.println();
 80a0c14:	f002 bc23 	b.w	80a345e <_ZN5Print7printlnEv>
          SERIAL_PORT.print("NNE");
 80a0c18:	f003 fa76 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c1c:	4939      	ldr	r1, [pc, #228]	; (80a0d04 <_Z9printInfov+0x390>)
 80a0c1e:	e710      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("NE");
 80a0c20:	f003 fa72 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c24:	4938      	ldr	r1, [pc, #224]	; (80a0d08 <_Z9printInfov+0x394>)
 80a0c26:	e70c      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("East");
 80a0c28:	f003 fa6e 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c2c:	4937      	ldr	r1, [pc, #220]	; (80a0d0c <_Z9printInfov+0x398>)
 80a0c2e:	e708      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("SE");
 80a0c30:	f003 fa6a 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c34:	4936      	ldr	r1, [pc, #216]	; (80a0d10 <_Z9printInfov+0x39c>)
 80a0c36:	e704      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("SSE");
 80a0c38:	f003 fa66 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c3c:	4935      	ldr	r1, [pc, #212]	; (80a0d14 <_Z9printInfov+0x3a0>)
 80a0c3e:	e700      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("South");
 80a0c40:	f003 fa62 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c44:	4934      	ldr	r1, [pc, #208]	; (80a0d18 <_Z9printInfov+0x3a4>)
 80a0c46:	e6fc      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("SW");
 80a0c48:	f003 fa5e 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c4c:	4933      	ldr	r1, [pc, #204]	; (80a0d1c <_Z9printInfov+0x3a8>)
 80a0c4e:	e6f8      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("WSW");
 80a0c50:	f003 fa5a 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c54:	4932      	ldr	r1, [pc, #200]	; (80a0d20 <_Z9printInfov+0x3ac>)
 80a0c56:	e6f4      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("West");
 80a0c58:	f003 fa56 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c5c:	4931      	ldr	r1, [pc, #196]	; (80a0d24 <_Z9printInfov+0x3b0>)
 80a0c5e:	e6f0      	b.n	80a0a42 <_Z9printInfov+0xce>
          SERIAL_PORT.print("NW");
 80a0c60:	f003 fa52 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0c64:	4930      	ldr	r1, [pc, #192]	; (80a0d28 <_Z9printInfov+0x3b4>)
 80a0c66:	e6ec      	b.n	80a0a42 <_Z9printInfov+0xce>
 80a0c68:	080a6dff 	.word	0x080a6dff
 80a0c6c:	20000274 	.word	0x20000274
 80a0c70:	080a6e3f 	.word	0x080a6e3f
 80a0c74:	080a6e13 	.word	0x080a6e13
 80a0c78:	080a6e1c 	.word	0x080a6e1c
 80a0c7c:	080a6e2a 	.word	0x080a6e2a
 80a0c80:	080a6e37 	.word	0x080a6e37
 80a0c84:	080a6e09 	.word	0x080a6e09
 80a0c88:	080a6e47 	.word	0x080a6e47
 80a0c8c:	20000548 	.word	0x20000548
 80a0c90:	080a6e54 	.word	0x080a6e54
 80a0c94:	080a6e66 	.word	0x080a6e66
 80a0c98:	20000218 	.word	0x20000218
 80a0c9c:	080a6e5a 	.word	0x080a6e5a
 80a0ca0:	080a6e60 	.word	0x080a6e60
 80a0ca4:	200000c0 	.word	0x200000c0
 80a0ca8:	080a6e9f 	.word	0x080a6e9f
 80a0cac:	20000268 	.word	0x20000268
 80a0cb0:	080a6e6c 	.word	0x080a6e6c
 80a0cb4:	080a6e70 	.word	0x080a6e70
 80a0cb8:	200000d0 	.word	0x200000d0
 80a0cbc:	080a6e7a 	.word	0x080a6e7a
 80a0cc0:	080a6e7f 	.word	0x080a6e7f
 80a0cc4:	200000b0 	.word	0x200000b0
 80a0cc8:	080a6e8a 	.word	0x080a6e8a
 80a0ccc:	20000120 	.word	0x20000120
 80a0cd0:	40590000 	.word	0x40590000
 80a0cd4:	080a6e94 	.word	0x080a6e94
 80a0cd8:	080a6e9a 	.word	0x080a6e9a
 80a0cdc:	20000250 	.word	0x20000250
 80a0ce0:	080a6ea5 	.word	0x080a6ea5
 80a0ce4:	2000024c 	.word	0x2000024c
 80a0ce8:	080a6e7d 	.word	0x080a6e7d
 80a0cec:	080a6eb4 	.word	0x080a6eb4
 80a0cf0:	20000098 	.word	0x20000098
 80a0cf4:	080a6ec3 	.word	0x080a6ec3
 80a0cf8:	200000a4 	.word	0x200000a4
 80a0cfc:	080a6ec8 	.word	0x080a6ec8
 80a0d00:	200000a8 	.word	0x200000a8
 80a0d04:	080a6e0f 	.word	0x080a6e0f
 80a0d08:	080a6e14 	.word	0x080a6e14
 80a0d0c:	080a6e17 	.word	0x080a6e17
 80a0d10:	080a6e1d 	.word	0x080a6e1d
 80a0d14:	080a6e20 	.word	0x080a6e20
 80a0d18:	080a6e24 	.word	0x080a6e24
 80a0d1c:	080a6e2b 	.word	0x080a6e2b
 80a0d20:	080a6e2e 	.word	0x080a6e2e
 80a0d24:	080a6e32 	.word	0x080a6e32
 80a0d28:	080a6e3c 	.word	0x080a6e3c
          SERIAL_PORT.print("NNW");
 80a0d2c:	f003 f9ec 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0d30:	4900      	ldr	r1, [pc, #0]	; (80a0d34 <_Z9printInfov+0x3c0>)
 80a0d32:	e686      	b.n	80a0a42 <_Z9printInfov+0xce>
 80a0d34:	080a6e3b 	.word	0x080a6e3b

080a0d38 <_Z16printDriverErrorN10CCS811Core6statusE>:
//type of error to the serial terminal.
//
//Save the return value of any function of type CCS811Core::status, then pass
//to this function to see what the output was.
void printDriverError( CCS811Core::status errorCode )
{
 80a0d38:	b508      	push	{r3, lr}
 80a0d3a:	2804      	cmp	r0, #4
 80a0d3c:	d81b      	bhi.n	80a0d76 <_Z16printDriverErrorN10CCS811Core6statusE+0x3e>
 80a0d3e:	e8df f000 	tbb	[pc, r0]
 80a0d42:	0a03      	.short	0x0a03
 80a0d44:	120e      	.short	0x120e
 80a0d46:	16          	.byte	0x16
 80a0d47:	00          	.byte	0x00
  switch ( errorCode )
  {
    case CCS811Core::SENSOR_SUCCESS:
      SERIAL_PORT.print("SUCCESS");
 80a0d48:	f003 f9de 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0d4c:	490c      	ldr	r1, [pc, #48]	; (80a0d80 <_Z16printDriverErrorN10CCS811Core6statusE+0x48>)
      SERIAL_PORT.print("GENERIC_ERROR");
      break;
    default:
      SERIAL_PORT.print("Unspecified error.");
  }
}
 80a0d4e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      SERIAL_PORT.print("Unspecified error.");
 80a0d52:	f002 bb7d 	b.w	80a3450 <_ZN5Print5printEPKc>
      SERIAL_PORT.print("ID_ERROR");
 80a0d56:	f003 f9d7 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0d5a:	490a      	ldr	r1, [pc, #40]	; (80a0d84 <_Z16printDriverErrorN10CCS811Core6statusE+0x4c>)
 80a0d5c:	e7f7      	b.n	80a0d4e <_Z16printDriverErrorN10CCS811Core6statusE+0x16>
      SERIAL_PORT.print("I2C_ERROR");
 80a0d5e:	f003 f9d3 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0d62:	4909      	ldr	r1, [pc, #36]	; (80a0d88 <_Z16printDriverErrorN10CCS811Core6statusE+0x50>)
 80a0d64:	e7f3      	b.n	80a0d4e <_Z16printDriverErrorN10CCS811Core6statusE+0x16>
      SERIAL_PORT.print("INTERNAL_ERROR");
 80a0d66:	f003 f9cf 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0d6a:	4908      	ldr	r1, [pc, #32]	; (80a0d8c <_Z16printDriverErrorN10CCS811Core6statusE+0x54>)
 80a0d6c:	e7ef      	b.n	80a0d4e <_Z16printDriverErrorN10CCS811Core6statusE+0x16>
      SERIAL_PORT.print("GENERIC_ERROR");
 80a0d6e:	f003 f9cb 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0d72:	4907      	ldr	r1, [pc, #28]	; (80a0d90 <_Z16printDriverErrorN10CCS811Core6statusE+0x58>)
 80a0d74:	e7eb      	b.n	80a0d4e <_Z16printDriverErrorN10CCS811Core6statusE+0x16>
      SERIAL_PORT.print("Unspecified error.");
 80a0d76:	f003 f9c7 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0d7a:	4906      	ldr	r1, [pc, #24]	; (80a0d94 <_Z16printDriverErrorN10CCS811Core6statusE+0x5c>)
 80a0d7c:	e7e7      	b.n	80a0d4e <_Z16printDriverErrorN10CCS811Core6statusE+0x16>
 80a0d7e:	bf00      	nop
 80a0d80:	080a6ece 	.word	0x080a6ece
 80a0d84:	080a6ed6 	.word	0x080a6ed6
 80a0d88:	080a6edf 	.word	0x080a6edf
 80a0d8c:	080a6ee9 	.word	0x080a6ee9
 80a0d90:	080a6ef8 	.word	0x080a6ef8
 80a0d94:	080a6f06 	.word	0x080a6f06

080a0d98 <_Z14resetAirSensor6String>:
{
 80a0d98:	b510      	push	{r4, lr}
  CCS811Core::status returnCode = myCCS811.begin();
 80a0d9a:	4809      	ldr	r0, [pc, #36]	; (80a0dc0 <_Z14resetAirSensor6String+0x28>)
 80a0d9c:	f001 f99a 	bl	80a20d4 <_ZN6CCS8115beginEv>
  if (returnCode != CCS811Core::SENSOR_SUCCESS) {  // suppress extended debug print if returnCode is SENSOR_SUCCESS
 80a0da0:	4604      	mov	r4, r0
 80a0da2:	b158      	cbz	r0, 80a0dbc <_Z14resetAirSensor6String+0x24>
    SERIAL_PORT.print("myCCS811.begin exited with: ");
 80a0da4:	f003 f9b0 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0da8:	4906      	ldr	r1, [pc, #24]	; (80a0dc4 <_Z14resetAirSensor6String+0x2c>)
 80a0daa:	f002 fb51 	bl	80a3450 <_ZN5Print5printEPKc>
    printDriverError( returnCode );
 80a0dae:	4620      	mov	r0, r4
 80a0db0:	f7ff ffc2 	bl	80a0d38 <_Z16printDriverErrorN10CCS811Core6statusE>
    SERIAL_PORT.println();
 80a0db4:	f003 f9a8 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0db8:	f002 fb51 	bl	80a345e <_ZN5Print7printlnEv>
}
 80a0dbc:	4620      	mov	r0, r4
 80a0dbe:	bd10      	pop	{r4, pc}
 80a0dc0:	200000f4 	.word	0x200000f4
 80a0dc4:	080a6f19 	.word	0x080a6f19

080a0dc8 <setup>:
{
 80a0dc8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    SERIAL_PORT.begin(9600);   // open serial over dedicated serial pins
 80a0dca:	f003 f99d 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0dce:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a0dd2:	f003 f995 	bl	80a4100 <_ZN11USARTSerial5beginEm>
    sensors.begin();
 80a0dd6:	486c      	ldr	r0, [pc, #432]	; (80a0f88 <setup+0x1c0>)
 80a0dd8:	f000 ff6e 	bl	80a1cb8 <_ZN17DallasTemperature5beginEv>
    sensors.setResolution(inSoilThermometer, TEMPERATURE_PRECISION);
 80a0ddc:	220b      	movs	r2, #11
 80a0dde:	496b      	ldr	r1, [pc, #428]	; (80a0f8c <setup+0x1c4>)
 80a0de0:	4869      	ldr	r0, [pc, #420]	; (80a0f88 <setup+0x1c0>)
 80a0de2:	f000 ff24 	bl	80a1c2e <_ZN17DallasTemperature13setResolutionEPKhh>
    Wire.begin();
 80a0de6:	f003 fc21 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a0dea:	f003 fa21 	bl	80a4230 <_ZN7TwoWire5beginEv>
    apds.begin(0x39);  // We're assuming you haven't changed the I2C
 80a0dee:	2139      	movs	r1, #57	; 0x39
 80a0df0:	4867      	ldr	r0, [pc, #412]	; (80a0f90 <setup+0x1c8>)
 80a0df2:	f001 fed1 	bl	80a2b98 <_ZN8APDS93015beginEh>
    pinMode(WSPEED, INPUT_PULLUP); // input from wind meters windspeed sensor
 80a0df6:	4d67      	ldr	r5, [pc, #412]	; (80a0f94 <setup+0x1cc>)
    apds.setGain(APDS9301::LOW_GAIN); // Set the gain to low. Strictly
 80a0df8:	2100      	movs	r1, #0
 80a0dfa:	4865      	ldr	r0, [pc, #404]	; (80a0f90 <setup+0x1c8>)
 80a0dfc:	f001 fed3 	bl	80a2ba6 <_ZN8APDS93017setGainENS_4gainE>
    pinMode(RAIN, INPUT_PULLUP); // input from wind meters rain gauge sensor
 80a0e00:	4e65      	ldr	r6, [pc, #404]	; (80a0f98 <setup+0x1d0>)
    apds.setIntegrationTime(APDS9301::INT_TIME_13_7_MS); // Set the
 80a0e02:	2100      	movs	r1, #0
 80a0e04:	4862      	ldr	r0, [pc, #392]	; (80a0f90 <setup+0x1c8>)
 80a0e06:	f001 fee1 	bl	80a2bcc <_ZN8APDS930118setIntegrationTimeENS_7intTimeE>
    pinMode(WSPEED, INPUT_PULLUP); // input from wind meters windspeed sensor
 80a0e0a:	2102      	movs	r1, #2
 80a0e0c:	8828      	ldrh	r0, [r5, #0]
 80a0e0e:	f003 fb65 	bl	80a44dc <pinMode>
    pinMode(RAIN, INPUT_PULLUP); // input from wind meters rain gauge sensor
 80a0e12:	2102      	movs	r1, #2
 80a0e14:	8830      	ldrh	r0, [r6, #0]
 80a0e16:	f003 fb61 	bl	80a44dc <pinMode>
    pinMode(SOIL_MOIST_POWER, OUTPUT);//power control for soil moisture
 80a0e1a:	2101      	movs	r1, #1
 80a0e1c:	2005      	movs	r0, #5
 80a0e1e:	f003 fb5d 	bl	80a44dc <pinMode>
    digitalWrite(SOIL_MOIST_POWER, LOW);//Leave off by defualt
 80a0e22:	2100      	movs	r1, #0
 80a0e24:	2005      	movs	r0, #5
 80a0e26:	f003 fb6a 	bl	80a44fe <digitalWrite>
    CCS811Core::status returnCode = myCCS811.begin();
 80a0e2a:	485c      	ldr	r0, [pc, #368]	; (80a0f9c <setup+0x1d4>)
 80a0e2c:	f001 f952 	bl	80a20d4 <_ZN6CCS8115beginEv>
    if (returnCode != CCS811Core::SENSOR_SUCCESS) {  // suppress extended debug print if returnCode is SENSOR_SUCCESS
 80a0e30:	4604      	mov	r4, r0
 80a0e32:	b158      	cbz	r0, 80a0e4c <setup+0x84>
      SERIAL_PORT.print("myCCS811.begin exited with: ");
 80a0e34:	f003 f968 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0e38:	4959      	ldr	r1, [pc, #356]	; (80a0fa0 <setup+0x1d8>)
 80a0e3a:	f002 fb09 	bl	80a3450 <_ZN5Print5printEPKc>
      printDriverError( returnCode );
 80a0e3e:	4620      	mov	r0, r4
 80a0e40:	f7ff ff7a 	bl	80a0d38 <_Z16printDriverErrorN10CCS811Core6statusE>
      SERIAL_PORT.println();
 80a0e44:	f003 f960 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a0e48:	f002 fb09 	bl	80a345e <_ZN5Print7printlnEv>
    seconds = 0;
 80a0e4c:	2400      	movs	r4, #0
    sensor.begin();
 80a0e4e:	4855      	ldr	r0, [pc, #340]	; (80a0fa4 <setup+0x1dc>)
 80a0e50:	f001 fb58 	bl	80a2504 <_ZN7Weather5beginEv>
    sensor.setModeBarometer();//Set to Barometer Mode
 80a0e54:	4853      	ldr	r0, [pc, #332]	; (80a0fa4 <setup+0x1dc>)
 80a0e56:	f001 fbbe 	bl	80a25d6 <_ZN7Weather16setModeBarometerEv>
    sensor.setOversampleRate(7); // Set Oversample rate
 80a0e5a:	2107      	movs	r1, #7
 80a0e5c:	4851      	ldr	r0, [pc, #324]	; (80a0fa4 <setup+0x1dc>)
 80a0e5e:	f001 fbc7 	bl	80a25f0 <_ZN7Weather17setOversampleRateEh>
    sensor.enableEventFlags(); //Necessary register calls to enble temp, baro ansd alt
 80a0e62:	4850      	ldr	r0, [pc, #320]	; (80a0fa4 <setup+0x1dc>)
 80a0e64:	f001 fbd8 	bl	80a2618 <_ZN7Weather16enableEventFlagsEv>
    seconds = 0;
 80a0e68:	4b4f      	ldr	r3, [pc, #316]	; (80a0fa8 <setup+0x1e0>)
 80a0e6a:	701c      	strb	r4, [r3, #0]
 80a0e6c:	f001 ff3e 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
    lastSecond = millis();
 80a0e70:	4b4e      	ldr	r3, [pc, #312]	; (80a0fac <setup+0x1e4>)
    attachInterrupt(RAIN, rainIRQ, FALLING);
 80a0e72:	2202      	movs	r2, #2
    lastSecond = millis();
 80a0e74:	6018      	str	r0, [r3, #0]
    attachInterrupt(RAIN, rainIRQ, FALLING);
 80a0e76:	494e      	ldr	r1, [pc, #312]	; (80a0fb0 <setup+0x1e8>)
 80a0e78:	f04f 33ff 	mov.w	r3, #4294967295
 80a0e7c:	8830      	ldrh	r0, [r6, #0]
 80a0e7e:	9400      	str	r4, [sp, #0]
 80a0e80:	f003 f8ba 	bl	80a3ff8 <_Z15attachInterrupttPFvvE13InterruptModeah>
    attachInterrupt(WSPEED, wspeedIRQ, FALLING);
 80a0e84:	f04f 33ff 	mov.w	r3, #4294967295
 80a0e88:	2202      	movs	r2, #2
 80a0e8a:	494a      	ldr	r1, [pc, #296]	; (80a0fb4 <setup+0x1ec>)
 80a0e8c:	8828      	ldrh	r0, [r5, #0]
 80a0e8e:	9400      	str	r4, [sp, #0]
 80a0e90:	f003 f8b2 	bl	80a3ff8 <_Z15attachInterrupttPFvvE13InterruptModeah>
    interrupts();
 80a0e94:	f003 f8dc 	bl	80a4050 <_Z10interruptsv>
        return register_function(call_raw_user_function, (void*)func, funcKey);
 80a0e98:	4a47      	ldr	r2, [pc, #284]	; (80a0fb8 <setup+0x1f0>)
 80a0e9a:	4948      	ldr	r1, [pc, #288]	; (80a0fbc <setup+0x1f4>)
 80a0e9c:	4848      	ldr	r0, [pc, #288]	; (80a0fc0 <setup+0x1f8>)
 80a0e9e:	f002 fd2e 	bl	80a38fe <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0ea2:	4a48      	ldr	r2, [pc, #288]	; (80a0fc4 <setup+0x1fc>)
 80a0ea4:	4948      	ldr	r1, [pc, #288]	; (80a0fc8 <setup+0x200>)
 80a0ea6:	4846      	ldr	r0, [pc, #280]	; (80a0fc0 <setup+0x1f8>)
 80a0ea8:	f002 fd29 	bl	80a38fe <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0eac:	4a47      	ldr	r2, [pc, #284]	; (80a0fcc <setup+0x204>)
 80a0eae:	4948      	ldr	r1, [pc, #288]	; (80a0fd0 <setup+0x208>)
 80a0eb0:	4843      	ldr	r0, [pc, #268]	; (80a0fc0 <setup+0x1f8>)
 80a0eb2:	f002 fd24 	bl	80a38fe <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0eb6:	4a47      	ldr	r2, [pc, #284]	; (80a0fd4 <setup+0x20c>)
 80a0eb8:	4947      	ldr	r1, [pc, #284]	; (80a0fd8 <setup+0x210>)
 80a0eba:	4841      	ldr	r0, [pc, #260]	; (80a0fc0 <setup+0x1f8>)
 80a0ebc:	f002 fd1f 	bl	80a38fe <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0ec0:	4a46      	ldr	r2, [pc, #280]	; (80a0fdc <setup+0x214>)
 80a0ec2:	4947      	ldr	r1, [pc, #284]	; (80a0fe0 <setup+0x218>)
 80a0ec4:	483e      	ldr	r0, [pc, #248]	; (80a0fc0 <setup+0x1f8>)
 80a0ec6:	f002 fd1a 	bl	80a38fe <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0eca:	4a46      	ldr	r2, [pc, #280]	; (80a0fe4 <setup+0x21c>)
 80a0ecc:	4946      	ldr	r1, [pc, #280]	; (80a0fe8 <setup+0x220>)
 80a0ece:	483c      	ldr	r0, [pc, #240]	; (80a0fc0 <setup+0x1f8>)
 80a0ed0:	f002 fd15 	bl	80a38fe <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0ed4:	4a45      	ldr	r2, [pc, #276]	; (80a0fec <setup+0x224>)
 80a0ed6:	4946      	ldr	r1, [pc, #280]	; (80a0ff0 <setup+0x228>)
 80a0ed8:	4839      	ldr	r0, [pc, #228]	; (80a0fc0 <setup+0x1f8>)
 80a0eda:	f002 fd10 	bl	80a38fe <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
 80a0ede:	4a45      	ldr	r2, [pc, #276]	; (80a0ff4 <setup+0x22c>)
 80a0ee0:	4945      	ldr	r1, [pc, #276]	; (80a0ff8 <setup+0x230>)
 80a0ee2:	4837      	ldr	r0, [pc, #220]	; (80a0fc0 <setup+0x1f8>)
 80a0ee4:	f002 fd0b 	bl	80a38fe <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
        return _variable(name, std::forward<ArgsT>(args)...);
 80a0ee8:	4944      	ldr	r1, [pc, #272]	; (80a0ffc <setup+0x234>)
 80a0eea:	4845      	ldr	r0, [pc, #276]	; (80a1000 <setup+0x238>)
 80a0eec:	f7ff f97a 	bl	80a01e4 <_ZN10CloudClass9_variableEPKcRKi.isra.0>
 80a0ef0:	4944      	ldr	r1, [pc, #272]	; (80a1004 <setup+0x23c>)
 80a0ef2:	4845      	ldr	r0, [pc, #276]	; (80a1008 <setup+0x240>)
 80a0ef4:	f7ff f972 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0ef8:	4944      	ldr	r1, [pc, #272]	; (80a100c <setup+0x244>)
 80a0efa:	4845      	ldr	r0, [pc, #276]	; (80a1010 <setup+0x248>)
 80a0efc:	f7ff f96e 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f00:	4944      	ldr	r1, [pc, #272]	; (80a1014 <setup+0x24c>)
 80a0f02:	4845      	ldr	r0, [pc, #276]	; (80a1018 <setup+0x250>)
 80a0f04:	f7ff f96e 	bl	80a01e4 <_ZN10CloudClass9_variableEPKcRKi.isra.0>
 80a0f08:	4944      	ldr	r1, [pc, #272]	; (80a101c <setup+0x254>)
 80a0f0a:	4845      	ldr	r0, [pc, #276]	; (80a1020 <setup+0x258>)
 80a0f0c:	f7ff f966 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f10:	4944      	ldr	r1, [pc, #272]	; (80a1024 <setup+0x25c>)
 80a0f12:	4845      	ldr	r0, [pc, #276]	; (80a1028 <setup+0x260>)
 80a0f14:	f7ff f966 	bl	80a01e4 <_ZN10CloudClass9_variableEPKcRKi.isra.0>
 80a0f18:	4944      	ldr	r1, [pc, #272]	; (80a102c <setup+0x264>)
 80a0f1a:	4845      	ldr	r0, [pc, #276]	; (80a1030 <setup+0x268>)
 80a0f1c:	f7ff f95e 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f20:	4944      	ldr	r1, [pc, #272]	; (80a1034 <setup+0x26c>)
 80a0f22:	4845      	ldr	r0, [pc, #276]	; (80a1038 <setup+0x270>)
 80a0f24:	f7ff f95e 	bl	80a01e4 <_ZN10CloudClass9_variableEPKcRKi.isra.0>
 80a0f28:	4944      	ldr	r1, [pc, #272]	; (80a103c <setup+0x274>)
 80a0f2a:	4845      	ldr	r0, [pc, #276]	; (80a1040 <setup+0x278>)
 80a0f2c:	f7ff f956 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f30:	4944      	ldr	r1, [pc, #272]	; (80a1044 <setup+0x27c>)
 80a0f32:	4845      	ldr	r0, [pc, #276]	; (80a1048 <setup+0x280>)
 80a0f34:	f7ff f952 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f38:	4944      	ldr	r1, [pc, #272]	; (80a104c <setup+0x284>)
 80a0f3a:	4845      	ldr	r0, [pc, #276]	; (80a1050 <setup+0x288>)
 80a0f3c:	f7ff f94e 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f40:	4944      	ldr	r1, [pc, #272]	; (80a1054 <setup+0x28c>)
 80a0f42:	4845      	ldr	r0, [pc, #276]	; (80a1058 <setup+0x290>)
 80a0f44:	f7ff f94a 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f48:	4944      	ldr	r1, [pc, #272]	; (80a105c <setup+0x294>)
 80a0f4a:	4845      	ldr	r0, [pc, #276]	; (80a1060 <setup+0x298>)
 80a0f4c:	f7ff f946 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f50:	4944      	ldr	r1, [pc, #272]	; (80a1064 <setup+0x29c>)
 80a0f52:	4845      	ldr	r0, [pc, #276]	; (80a1068 <setup+0x2a0>)
 80a0f54:	f7ff f942 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f58:	4944      	ldr	r1, [pc, #272]	; (80a106c <setup+0x2a4>)
 80a0f5a:	4845      	ldr	r0, [pc, #276]	; (80a1070 <setup+0x2a8>)
 80a0f5c:	f7ff f93e 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f60:	4944      	ldr	r1, [pc, #272]	; (80a1074 <setup+0x2ac>)
 80a0f62:	4845      	ldr	r0, [pc, #276]	; (80a1078 <setup+0x2b0>)
 80a0f64:	f7ff f93e 	bl	80a01e4 <_ZN10CloudClass9_variableEPKcRKi.isra.0>
 80a0f68:	4944      	ldr	r1, [pc, #272]	; (80a107c <setup+0x2b4>)
 80a0f6a:	4845      	ldr	r0, [pc, #276]	; (80a1080 <setup+0x2b8>)
 80a0f6c:	f7ff f936 	bl	80a01dc <_ZN10CloudClass9_variableEPKcRKd.isra.0>
 80a0f70:	4944      	ldr	r1, [pc, #272]	; (80a1084 <setup+0x2bc>)
 80a0f72:	4845      	ldr	r0, [pc, #276]	; (80a1088 <setup+0x2c0>)
 80a0f74:	f7ff f936 	bl	80a01e4 <_ZN10CloudClass9_variableEPKcRKi.isra.0>
 80a0f78:	4944      	ldr	r1, [pc, #272]	; (80a108c <setup+0x2c4>)
 80a0f7a:	4845      	ldr	r0, [pc, #276]	; (80a1090 <setup+0x2c8>)
}
 80a0f7c:	b002      	add	sp, #8
 80a0f7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a0f82:	f7ff b92f 	b.w	80a01e4 <_ZN10CloudClass9_variableEPKcRKi.isra.0>
 80a0f86:	bf00      	nop
 80a0f88:	20000230 	.word	0x20000230
 80a0f8c:	20000014 	.word	0x20000014
 80a0f90:	200000ac 	.word	0x200000ac
 80a0f94:	20000008 	.word	0x20000008
 80a0f98:	20000000 	.word	0x20000000
 80a0f9c:	200000f4 	.word	0x200000f4
 80a0fa0:	080a6f19 	.word	0x080a6f19
 80a0fa4:	2000022e 	.word	0x2000022e
 80a0fa8:	2000022c 	.word	0x2000022c
 80a0fac:	200000e0 	.word	0x200000e0
 80a0fb0:	080a00f9 	.word	0x080a00f9
 80a0fb4:	080a0171 	.word	0x080a0171
 80a0fb8:	080a6f36 	.word	0x080a6f36
 80a0fbc:	080a00b9 	.word	0x080a00b9
 80a0fc0:	080a38d3 	.word	0x080a38d3
 80a0fc4:	080a6f43 	.word	0x080a6f43
 80a0fc8:	080a00d1 	.word	0x080a00d1
 80a0fcc:	080a6f50 	.word	0x080a6f50
 80a0fd0:	080a00e9 	.word	0x080a00e9
 80a0fd4:	080a6f5c 	.word	0x080a6f5c
 80a0fd8:	080a154d 	.word	0x080a154d
 80a0fdc:	080a6f68 	.word	0x080a6f68
 80a0fe0:	080a15d5 	.word	0x080a15d5
 80a0fe4:	080a6f75 	.word	0x080a6f75
 80a0fe8:	080a169d 	.word	0x080a169d
 80a0fec:	080a6f80 	.word	0x080a6f80
 80a0ff0:	080a1725 	.word	0x080a1725
 80a0ff4:	080a6f8c 	.word	0x080a6f8c
 80a0ff8:	080a0d99 	.word	0x080a0d99
 80a0ffc:	20000274 	.word	0x20000274
 80a1000:	080a6f9b 	.word	0x080a6f9b
 80a1004:	20000548 	.word	0x20000548
 80a1008:	080a6fa3 	.word	0x080a6fa3
 80a100c:	200004b8 	.word	0x200004b8
 80a1010:	080a6fb0 	.word	0x080a6fb0
 80a1014:	20000484 	.word	0x20000484
 80a1018:	080a6fbc 	.word	0x080a6fbc
 80a101c:	20000540 	.word	0x20000540
 80a1020:	080a6fc8 	.word	0x080a6fc8
 80a1024:	20000278 	.word	0x20000278
 80a1028:	080a6fd4 	.word	0x080a6fd4
 80a102c:	200004c0 	.word	0x200004c0
 80a1030:	080a6fe0 	.word	0x080a6fe0
 80a1034:	20000488 	.word	0x20000488
 80a1038:	080a6fed 	.word	0x080a6fed
 80a103c:	20000218 	.word	0x20000218
 80a1040:	080a6fff 	.word	0x080a6fff
 80a1044:	200000c8 	.word	0x200000c8
 80a1048:	080a6ffa 	.word	0x080a6ffa
 80a104c:	200000d0 	.word	0x200000d0
 80a1050:	080a7006 	.word	0x080a7006
 80a1054:	20000268 	.word	0x20000268
 80a1058:	080a7013 	.word	0x080a7013
 80a105c:	20000250 	.word	0x20000250
 80a1060:	080a700f 	.word	0x080a700f
 80a1064:	20000120 	.word	0x20000120
 80a1068:	080a7019 	.word	0x080a7019
 80a106c:	200000b0 	.word	0x200000b0
 80a1070:	080a7021 	.word	0x080a7021
 80a1074:	2000024c 	.word	0x2000024c
 80a1078:	080a702a 	.word	0x080a702a
 80a107c:	20000098 	.word	0x20000098
 80a1080:	080a7037 	.word	0x080a7037
 80a1084:	200000a8 	.word	0x200000a8
 80a1088:	080a7042 	.word	0x080a7042
 80a108c:	200000a4 	.word	0x200000a4
 80a1090:	080a704a 	.word	0x080a704a

080a1094 <_Z16printSensorErrorv>:

//printSensorError gets, clears, then prints the errors
//saved within the error register.
void printSensorError()
{
 80a1094:	b510      	push	{r4, lr}
  uint8_t error = myCCS811.getErrorRegister();
 80a1096:	4821      	ldr	r0, [pc, #132]	; (80a111c <_Z16printSensorErrorv+0x88>)
 80a1098:	f000 fff2 	bl	80a2080 <_ZN6CCS81116getErrorRegisterEv>

  if ( error == 0xFF ) //comm error
 80a109c:	28ff      	cmp	r0, #255	; 0xff
  uint8_t error = myCCS811.getErrorRegister();
 80a109e:	4604      	mov	r4, r0
  if ( error == 0xFF ) //comm error
 80a10a0:	d106      	bne.n	80a10b0 <_Z16printSensorErrorv+0x1c>
  {
    SERIAL_PORT.println("Failed to get ERROR_ID register.");
 80a10a2:	f003 f831 	bl	80a4108 <_Z22__fetch_global_Serial1v>
    if (error & 1 << 2) SERIAL_PORT.print("MeasModeInvalid");
    if (error & 1 << 1) SERIAL_PORT.print("ReadRegInvalid");
    if (error & 1 << 0) SERIAL_PORT.print("MsgInvalid");
    SERIAL_PORT.println();
  }
}
 80a10a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SERIAL_PORT.println("Failed to get ERROR_ID register.");
 80a10aa:	491d      	ldr	r1, [pc, #116]	; (80a1120 <_Z16printSensorErrorv+0x8c>)
 80a10ac:	f002 b9e3 	b.w	80a3476 <_ZN5Print7printlnEPKc>
    SERIAL_PORT.print("Error: ");
 80a10b0:	f003 f82a 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a10b4:	491b      	ldr	r1, [pc, #108]	; (80a1124 <_Z16printSensorErrorv+0x90>)
 80a10b6:	f002 f9cb 	bl	80a3450 <_ZN5Print5printEPKc>
    if (error & 1 << 5) SERIAL_PORT.print("HeaterSupply");
 80a10ba:	06a2      	lsls	r2, r4, #26
 80a10bc:	d504      	bpl.n	80a10c8 <_Z16printSensorErrorv+0x34>
 80a10be:	f003 f823 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a10c2:	4919      	ldr	r1, [pc, #100]	; (80a1128 <_Z16printSensorErrorv+0x94>)
 80a10c4:	f002 f9c4 	bl	80a3450 <_ZN5Print5printEPKc>
    if (error & 1 << 4) SERIAL_PORT.print("HeaterFault");
 80a10c8:	06e3      	lsls	r3, r4, #27
 80a10ca:	d504      	bpl.n	80a10d6 <_Z16printSensorErrorv+0x42>
 80a10cc:	f003 f81c 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a10d0:	4916      	ldr	r1, [pc, #88]	; (80a112c <_Z16printSensorErrorv+0x98>)
 80a10d2:	f002 f9bd 	bl	80a3450 <_ZN5Print5printEPKc>
    if (error & 1 << 3) SERIAL_PORT.print("MaxResistance");
 80a10d6:	0720      	lsls	r0, r4, #28
 80a10d8:	d504      	bpl.n	80a10e4 <_Z16printSensorErrorv+0x50>
 80a10da:	f003 f815 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a10de:	4914      	ldr	r1, [pc, #80]	; (80a1130 <_Z16printSensorErrorv+0x9c>)
 80a10e0:	f002 f9b6 	bl	80a3450 <_ZN5Print5printEPKc>
    if (error & 1 << 2) SERIAL_PORT.print("MeasModeInvalid");
 80a10e4:	0761      	lsls	r1, r4, #29
 80a10e6:	d504      	bpl.n	80a10f2 <_Z16printSensorErrorv+0x5e>
 80a10e8:	f003 f80e 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a10ec:	4911      	ldr	r1, [pc, #68]	; (80a1134 <_Z16printSensorErrorv+0xa0>)
 80a10ee:	f002 f9af 	bl	80a3450 <_ZN5Print5printEPKc>
    if (error & 1 << 1) SERIAL_PORT.print("ReadRegInvalid");
 80a10f2:	07a2      	lsls	r2, r4, #30
 80a10f4:	d504      	bpl.n	80a1100 <_Z16printSensorErrorv+0x6c>
 80a10f6:	f003 f807 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a10fa:	490f      	ldr	r1, [pc, #60]	; (80a1138 <_Z16printSensorErrorv+0xa4>)
 80a10fc:	f002 f9a8 	bl	80a3450 <_ZN5Print5printEPKc>
    if (error & 1 << 0) SERIAL_PORT.print("MsgInvalid");
 80a1100:	07e3      	lsls	r3, r4, #31
 80a1102:	d504      	bpl.n	80a110e <_Z16printSensorErrorv+0x7a>
 80a1104:	f003 f800 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a1108:	490c      	ldr	r1, [pc, #48]	; (80a113c <_Z16printSensorErrorv+0xa8>)
 80a110a:	f002 f9a1 	bl	80a3450 <_ZN5Print5printEPKc>
    SERIAL_PORT.println();
 80a110e:	f002 fffb 	bl	80a4108 <_Z22__fetch_global_Serial1v>
}
 80a1112:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SERIAL_PORT.println();
 80a1116:	f002 b9a2 	b.w	80a345e <_ZN5Print7printlnEv>
 80a111a:	bf00      	nop
 80a111c:	200000f4 	.word	0x200000f4
 80a1120:	080a7051 	.word	0x080a7051
 80a1124:	080a7072 	.word	0x080a7072
 80a1128:	080a707a 	.word	0x080a707a
 80a112c:	080a7087 	.word	0x080a7087
 80a1130:	080a7093 	.word	0x080a7093
 80a1134:	080a70a1 	.word	0x080a70a1
 80a1138:	080a70b1 	.word	0x080a70b1
 80a113c:	080a70c0 	.word	0x080a70c0

080a1140 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a1140:	b538      	push	{r3, r4, r5, lr}
      {
	if (_M_pi != nullptr)
 80a1142:	6804      	ldr	r4, [r0, #0]
      ~__shared_count() noexcept
 80a1144:	4605      	mov	r5, r0
	if (_M_pi != nullptr)
 80a1146:	b17c      	cbz	r4, 80a1168 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
      if (--_M_use_count == 0)
 80a1148:	6863      	ldr	r3, [r4, #4]
 80a114a:	3b01      	subs	r3, #1
 80a114c:	6063      	str	r3, [r4, #4]
 80a114e:	b95b      	cbnz	r3, 80a1168 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
          _M_dispose();
 80a1150:	6823      	ldr	r3, [r4, #0]
 80a1152:	4620      	mov	r0, r4
 80a1154:	689b      	ldr	r3, [r3, #8]
 80a1156:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a1158:	68a3      	ldr	r3, [r4, #8]
 80a115a:	3b01      	subs	r3, #1
 80a115c:	60a3      	str	r3, [r4, #8]
 80a115e:	b91b      	cbnz	r3, 80a1168 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
            _M_destroy();
 80a1160:	6823      	ldr	r3, [r4, #0]
 80a1162:	4620      	mov	r0, r4
 80a1164:	68db      	ldr	r3, [r3, #12]
 80a1166:	4798      	blx	r3
	  _M_pi->_M_release();
      }
 80a1168:	4628      	mov	r0, r5
 80a116a:	bd38      	pop	{r3, r4, r5, pc}

080a116c <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv>:
    // Constructs succeeded future
    explicit Future(ResultT result = ResultT()) :
            FutureBase<ResultT, ContextT>(std::make_shared<detail::FutureImpl<ResultT, ContextT>>(std::move(result))) {
    }

    ResultT result() const {
 80a116c:	b538      	push	{r3, r4, r5, lr}
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }

      /// Return the stored pointer.
      element_type*
      get() const noexcept
      { return _M_ptr; }
 80a116e:	6804      	ldr	r4, [r0, #0]
        return (application_thread_current(nullptr) != 0);
 80a1170:	2000      	movs	r0, #0
 80a1172:	f001 fecf 	bl	80a2f14 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
 80a1176:	b120      	cbz	r0, 80a1182 <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv+0x16>
      {
	memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_i, int(__m));
 80a1178:	7863      	ldrb	r3, [r4, #1]
                if (isDone()) { // We can use relaxed ordering here, as long as the future's result is not examined
 80a117a:	b913      	cbnz	r3, 80a1182 <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv+0x16>
        spark_process();
 80a117c:	f001 ff68 	bl	80a3050 <spark_process>
    }
 80a1180:	e7fa      	b.n	80a1178 <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv+0xc>
 80a1182:	7863      	ldrb	r3, [r4, #1]
 80a1184:	1c65      	adds	r5, r4, #1
 80a1186:	f3bf 8f5b 	dmb	ish
        if (this->acquireDone() && this->isSucceeded()) {
 80a118a:	b90b      	cbnz	r3, 80a1190 <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv+0x24>
        return std::move(defaultValue);
 80a118c:	2000      	movs	r0, #0
        return this->p_->result();
    }
 80a118e:	bd38      	pop	{r3, r4, r5, pc}
        return (application_thread_current(nullptr) != 0);
 80a1190:	2000      	movs	r0, #0
 80a1192:	f001 febf 	bl	80a2f14 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
 80a1196:	b120      	cbz	r0, 80a11a2 <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv+0x36>
 80a1198:	782b      	ldrb	r3, [r5, #0]
                if (isDone()) { // We can use relaxed ordering here, as long as the future's result is not examined
 80a119a:	b913      	cbnz	r3, 80a11a2 <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv+0x36>
        spark_process();
 80a119c:	f001 ff58 	bl	80a3050 <spark_process>
    }
 80a11a0:	e7fa      	b.n	80a1198 <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv+0x2c>
      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
	alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
	_Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
	__atomic_load(std::__addressof(_M_i), __ptr, int(__m));
 80a11a2:	7823      	ldrb	r3, [r4, #0]
        if (this->acquireDone() && this->isSucceeded()) {
 80a11a4:	2b01      	cmp	r3, #1
 80a11a6:	d1f1      	bne.n	80a118c <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv+0x20>
            return result_;
 80a11a8:	7b20      	ldrb	r0, [r4, #12]
 80a11aa:	e7f0      	b.n	80a118e <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv+0x22>
 80a11ac:	0000      	movs	r0, r0
	...

080a11b0 <loop>:
{
 80a11b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  dailyrainin_nv = dailyrainin; // particle.variable cannot seem to handle a casted volatile variable
 80a11b4:	4b98      	ldr	r3, [pc, #608]	; (80a1418 <loop+0x268>)
{
 80a11b6:	b0a1      	sub	sp, #132	; 0x84
  dailyrainin_nv = dailyrainin; // particle.variable cannot seem to handle a casted volatile variable
 80a11b8:	e9d3 0100 	ldrd	r0, r1, [r3]
 80a11bc:	4b97      	ldr	r3, [pc, #604]	; (80a141c <loop+0x26c>)
 80a11be:	e9c3 0100 	strd	r0, r1, [r3]
 80a11c2:	f001 fd93 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
  if(millis() - lastSecond >= 1000)
 80a11c6:	4a96      	ldr	r2, [pc, #600]	; (80a1420 <loop+0x270>)
 80a11c8:	6813      	ldr	r3, [r2, #0]
 80a11ca:	1ac0      	subs	r0, r0, r3
 80a11cc:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80a11d0:	f0c0 8108 	bcc.w	80a13e4 <loop+0x234>
    lastSecond += 1000;
 80a11d4:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 80a11d8:	6013      	str	r3, [r2, #0]
    getWeather();
 80a11da:	f7ff fa49 	bl	80a0670 <_Z10getWeatherv>
    LuminousFlux = apds.readLuxLevel();
 80a11de:	4891      	ldr	r0, [pc, #580]	; (80a1424 <loop+0x274>)
 80a11e0:	f001 fb76 	bl	80a28d0 <_ZN8APDS930112readLuxLevelEv>
 80a11e4:	f004 fe0e 	bl	80a5e04 <__aeabi_f2d>
 80a11e8:	4b8f      	ldr	r3, [pc, #572]	; (80a1428 <loop+0x278>)
 80a11ea:	e9c3 0100 	strd	r0, r1, [r3]
    if (myCCS811.dataAvailable())
 80a11ee:	488f      	ldr	r0, [pc, #572]	; (80a142c <loop+0x27c>)
 80a11f0:	f000 ff26 	bl	80a2040 <_ZN6CCS81113dataAvailableEv>
 80a11f4:	2800      	cmp	r0, #0
 80a11f6:	f000 816b 	beq.w	80a14d0 <loop+0x320>
      myCCS811.readAlgorithmResults();
 80a11fa:	488c      	ldr	r0, [pc, #560]	; (80a142c <loop+0x27c>)
 80a11fc:	f000 ff00 	bl	80a2000 <_ZN6CCS81120readAlgorithmResultsEv>
      airTVOC = myCCS811.getTVOC();
 80a1200:	488a      	ldr	r0, [pc, #552]	; (80a142c <loop+0x27c>)
 80a1202:	f001 f89b 	bl	80a233c <_ZN6CCS8117getTVOCEv>
 80a1206:	4b8a      	ldr	r3, [pc, #552]	; (80a1430 <loop+0x280>)
 80a1208:	6018      	str	r0, [r3, #0]
      airCO2 = myCCS811.getCO2();
 80a120a:	4888      	ldr	r0, [pc, #544]	; (80a142c <loop+0x27c>)
 80a120c:	f001 f898 	bl	80a2340 <_ZN6CCS8116getCO2Ev>
 80a1210:	4b88      	ldr	r3, [pc, #544]	; (80a1434 <loop+0x284>)
 80a1212:	6018      	str	r0, [r3, #0]
      myCCS811.readNTC();
 80a1214:	4885      	ldr	r0, [pc, #532]	; (80a142c <loop+0x27c>)
 80a1216:	f001 f817 	bl	80a2248 <_ZN6CCS8117readNTCEv>
      float readTemperature = myCCS811.getTemperature();
 80a121a:	4884      	ldr	r0, [pc, #528]	; (80a142c <loop+0x27c>)
 80a121c:	f001 f892 	bl	80a2344 <_ZN6CCS81114getTemperatureEv>
      myCCS811.setEnvironmentalData((float)humidity, readTemperature);
 80a1220:	4b85      	ldr	r3, [pc, #532]	; (80a1438 <loop+0x288>)
      float readTemperature = myCCS811.getTemperature();
 80a1222:	4604      	mov	r4, r0
      myCCS811.setEnvironmentalData((float)humidity, readTemperature);
 80a1224:	e9d3 0100 	ldrd	r0, r1, [r3]
 80a1228:	f005 f93c 	bl	80a64a4 <__aeabi_d2f>
 80a122c:	4622      	mov	r2, r4
 80a122e:	4601      	mov	r1, r0
 80a1230:	487e      	ldr	r0, [pc, #504]	; (80a142c <loop+0x27c>)
 80a1232:	f000 ff91 	bl	80a2158 <_ZN6CCS81120setEnvironmentalDataEff>
    count++;
 80a1236:	4c81      	ldr	r4, [pc, #516]	; (80a143c <loop+0x28c>)
 80a1238:	6823      	ldr	r3, [r4, #0]
 80a123a:	3301      	adds	r3, #1
    if(count == 5)
 80a123c:	2b05      	cmp	r3, #5
    count++;
 80a123e:	6023      	str	r3, [r4, #0]
    if(count == 5)
 80a1240:	d103      	bne.n	80a124a <loop+0x9a>
       printInfo();
 80a1242:	f7ff fb97 	bl	80a0974 <_Z9printInfov>
       count = 0;
 80a1246:	2300      	movs	r3, #0
 80a1248:	6023      	str	r3, [r4, #0]
 80a124a:	f001 fd4f 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
    if(millis() - lastPublish > delayPublish) //Publishes every 60000 milliseconds, or 60 seconds
 80a124e:	4c7c      	ldr	r4, [pc, #496]	; (80a1440 <loop+0x290>)
 80a1250:	6823      	ldr	r3, [r4, #0]
 80a1252:	1ac0      	subs	r0, r0, r3
 80a1254:	4b7b      	ldr	r3, [pc, #492]	; (80a1444 <loop+0x294>)
 80a1256:	681b      	ldr	r3, [r3, #0]
 80a1258:	4298      	cmp	r0, r3
 80a125a:	d96e      	bls.n	80a133a <loop+0x18a>
 80a125c:	f001 fd46 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
      success = Particle.publish("MMWEATHER", String::format("{\"humidity\":%f,\"tempF\":%f,\"pressurehPa\":%f,\"pressureHg\":%f,\"baroTempF\":%f,\"SoilTempF\":%f,\"SoilMoisture\":%d,\"LuminousFlux\":%f,\"AirTVOC\":%d,\"airCO2\":%d}",humidity,tempf,(pascals/100),((pascals/100) * 0.0295300),baroTemp,soiltempf,soilMoisture,LuminousFlux > 65534 ? 65534 : LuminousFlux,airTVOC, airCO2), 60, PRIVATE);
 80a1260:	4b75      	ldr	r3, [pc, #468]	; (80a1438 <loop+0x288>)
 80a1262:	4979      	ldr	r1, [pc, #484]	; (80a1448 <loop+0x298>)
 80a1264:	e9d3 6700 	ldrd	r6, r7, [r3]
 80a1268:	4b78      	ldr	r3, [pc, #480]	; (80a144c <loop+0x29c>)
      lastPublish = millis();
 80a126a:	6020      	str	r0, [r4, #0]
      success = Particle.publish("MMWEATHER", String::format("{\"humidity\":%f,\"tempF\":%f,\"pressurehPa\":%f,\"pressureHg\":%f,\"baroTempF\":%f,\"SoilTempF\":%f,\"SoilMoisture\":%d,\"LuminousFlux\":%f,\"AirTVOC\":%d,\"airCO2\":%d}",humidity,tempf,(pascals/100),((pascals/100) * 0.0295300),baroTemp,soiltempf,soilMoisture,LuminousFlux > 65534 ? 65534 : LuminousFlux,airTVOC, airCO2), 60, PRIVATE);
 80a126c:	2200      	movs	r2, #0
 80a126e:	e9d3 ab00 	ldrd	sl, fp, [r3]
 80a1272:	e9d1 0100 	ldrd	r0, r1, [r1]
 80a1276:	4b76      	ldr	r3, [pc, #472]	; (80a1450 <loop+0x2a0>)
 80a1278:	f004 ff46 	bl	80a6108 <__aeabi_ddiv>
 80a127c:	4602      	mov	r2, r0
 80a127e:	460b      	mov	r3, r1
 80a1280:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
 80a1284:	a360      	add	r3, pc, #384	; (adr r3, 80a1408 <loop+0x258>)
 80a1286:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a128a:	f004 fe13 	bl	80a5eb4 <__aeabi_dmul>
 80a128e:	4b71      	ldr	r3, [pc, #452]	; (80a1454 <loop+0x2a4>)
 80a1290:	e9cd 0114 	strd	r0, r1, [sp, #80]	; 0x50
 80a1294:	cb18      	ldmia	r3, {r3, r4}
 80a1296:	e9cd 3416 	strd	r3, r4, [sp, #88]	; 0x58
 80a129a:	4b6f      	ldr	r3, [pc, #444]	; (80a1458 <loop+0x2a8>)
 80a129c:	e9d3 8900 	ldrd	r8, r9, [r3]
 80a12a0:	4b6e      	ldr	r3, [pc, #440]	; (80a145c <loop+0x2ac>)
 80a12a2:	681b      	ldr	r3, [r3, #0]
 80a12a4:	9319      	str	r3, [sp, #100]	; 0x64
 80a12a6:	4b60      	ldr	r3, [pc, #384]	; (80a1428 <loop+0x278>)
 80a12a8:	e9d3 4500 	ldrd	r4, r5, [r3]
 80a12ac:	a358      	add	r3, pc, #352	; (adr r3, 80a1410 <loop+0x260>)
 80a12ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a12b2:	4620      	mov	r0, r4
 80a12b4:	4629      	mov	r1, r5
 80a12b6:	f005 f88d 	bl	80a63d4 <__aeabi_dcmpgt>
 80a12ba:	b110      	cbz	r0, 80a12c2 <loop+0x112>
 80a12bc:	a554      	add	r5, pc, #336	; (adr r5, 80a1410 <loop+0x260>)
 80a12be:	e9d5 4500 	ldrd	r4, r5, [r5]
 80a12c2:	4b5c      	ldr	r3, [pc, #368]	; (80a1434 <loop+0x284>)
 80a12c4:	4632      	mov	r2, r6
 80a12c6:	681b      	ldr	r3, [r3, #0]
 80a12c8:	4965      	ldr	r1, [pc, #404]	; (80a1460 <loop+0x2b0>)
 80a12ca:	930f      	str	r3, [sp, #60]	; 0x3c
 80a12cc:	4b58      	ldr	r3, [pc, #352]	; (80a1430 <loop+0x280>)
 80a12ce:	a81c      	add	r0, sp, #112	; 0x70
 80a12d0:	681b      	ldr	r3, [r3, #0]
 80a12d2:	e9cd 450c 	strd	r4, r5, [sp, #48]	; 0x30
 80a12d6:	930e      	str	r3, [sp, #56]	; 0x38
 80a12d8:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80a12da:	e9cd 8908 	strd	r8, r9, [sp, #32]
 80a12de:	930a      	str	r3, [sp, #40]	; 0x28
 80a12e0:	e9cd ab00 	strd	sl, fp, [sp]
 80a12e4:	e9dd 3416 	ldrd	r3, r4, [sp, #88]	; 0x58
 80a12e8:	e9cd 3406 	strd	r3, r4, [sp, #24]
 80a12ec:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
 80a12f0:	e9cd 3404 	strd	r3, r4, [sp, #16]
 80a12f4:	e9dd 3412 	ldrd	r3, r4, [sp, #72]	; 0x48
 80a12f8:	e9cd 3402 	strd	r3, r4, [sp, #8]
 80a12fc:	463b      	mov	r3, r7
 80a12fe:	f002 f859 	bl	80a33b4 <_ZN6String6formatEPKcz>
inline particle::Flags<TagT, ValueT>::Flags(Flag<TagT, ValueT> flag) :
        val_(flag.value()) {
}

template<typename TagT, typename ValueT>
inline particle::Flags<TagT, ValueT>::Flags(ValueT val) :
 80a1302:	4b58      	ldr	r3, [pc, #352]	; (80a1464 <loop+0x2b4>)
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
 80a1304:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 80a1306:	781b      	ldrb	r3, [r3, #0]
 80a1308:	4957      	ldr	r1, [pc, #348]	; (80a1468 <loop+0x2b8>)
 80a130a:	f88d 3000 	strb.w	r3, [sp]
 80a130e:	a81a      	add	r0, sp, #104	; 0x68
 80a1310:	233c      	movs	r3, #60	; 0x3c
 80a1312:	f002 fbeb 	bl	80a3aec <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
    ResultT result(ResultT defaultValue) const {
        return this->p_->result(std::move(defaultValue));
    }

    operator ResultT() const {
        return result();
 80a1316:	a81a      	add	r0, sp, #104	; 0x68
 80a1318:	f7ff ff28 	bl	80a116c <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv>
 80a131c:	4c53      	ldr	r4, [pc, #332]	; (80a146c <loop+0x2bc>)
 80a131e:	7020      	strb	r0, [r4, #0]
      ~__shared_ptr() = default;
 80a1320:	a81b      	add	r0, sp, #108	; 0x6c
 80a1322:	f7ff ff0d 	bl	80a1140 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a1326:	a81c      	add	r0, sp, #112	; 0x70
 80a1328:	f001 ff62 	bl	80a31f0 <_ZN6StringD1Ev>
      if (!success) {
 80a132c:	7823      	ldrb	r3, [r4, #0]
 80a132e:	b923      	cbnz	r3, 80a133a <loop+0x18a>
        SERIAL_PORT.println("MMWEATHER Publish Failed");
 80a1330:	f002 feea 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a1334:	494e      	ldr	r1, [pc, #312]	; (80a1470 <loop+0x2c0>)
 80a1336:	f002 f89e 	bl	80a3476 <_ZN5Print7printlnEPKc>
 80a133a:	f001 fcd7 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
    if(millis() - lastPublish2 > delayPublish2) //Publishes every 60000 milliseconds, or 60 seconds
 80a133e:	4c4d      	ldr	r4, [pc, #308]	; (80a1474 <loop+0x2c4>)
 80a1340:	6823      	ldr	r3, [r4, #0]
 80a1342:	1ac0      	subs	r0, r0, r3
 80a1344:	4b4c      	ldr	r3, [pc, #304]	; (80a1478 <loop+0x2c8>)
 80a1346:	681b      	ldr	r3, [r3, #0]
 80a1348:	4298      	cmp	r0, r3
 80a134a:	d94b      	bls.n	80a13e4 <loop+0x234>
 80a134c:	f001 fcce 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
      success = Particle.publish("MMWIND", String::format("{\"winddir\":%d,\"windspeedmph\":%f,\"windgustmph\":%f,\"windgustdir\":%d,\"windspdmph_avg2m\":%f,\"winddir_avg2m\":%d,\"windgustmph_10m\":%f,\"windgustdir_10m\":%d,\"rainin\":%f,\"dailyrainin\":%f}", winddir,windspeedmph,windgustmph,windgustdir,windspdmph_avg2m,winddir_avg2m,windgustmph_10m,windgustdir_10m,rainin,dailyrainin), 60, PRIVATE);
 80a1350:	4b31      	ldr	r3, [pc, #196]	; (80a1418 <loop+0x268>)
      lastPublish2 = millis();
 80a1352:	6020      	str	r0, [r4, #0]
      success = Particle.publish("MMWIND", String::format("{\"winddir\":%d,\"windspeedmph\":%f,\"windgustmph\":%f,\"windgustdir\":%d,\"windspdmph_avg2m\":%f,\"winddir_avg2m\":%d,\"windgustmph_10m\":%f,\"windgustdir_10m\":%d,\"rainin\":%f,\"dailyrainin\":%f}", winddir,windspeedmph,windgustmph,windgustdir,windspdmph_avg2m,winddir_avg2m,windgustmph_10m,windgustdir_10m,rainin,dailyrainin), 60, PRIVATE);
 80a1354:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a1358:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
 80a135c:	4b47      	ldr	r3, [pc, #284]	; (80a147c <loop+0x2cc>)
 80a135e:	4948      	ldr	r1, [pc, #288]	; (80a1480 <loop+0x2d0>)
 80a1360:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a1364:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 80a1368:	4b46      	ldr	r3, [pc, #280]	; (80a1484 <loop+0x2d4>)
 80a136a:	a81c      	add	r0, sp, #112	; 0x70
 80a136c:	681b      	ldr	r3, [r3, #0]
 80a136e:	4c3f      	ldr	r4, [pc, #252]	; (80a146c <loop+0x2bc>)
 80a1370:	930c      	str	r3, [sp, #48]	; 0x30
 80a1372:	4b45      	ldr	r3, [pc, #276]	; (80a1488 <loop+0x2d8>)
 80a1374:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a1378:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 80a137c:	4b43      	ldr	r3, [pc, #268]	; (80a148c <loop+0x2dc>)
 80a137e:	681b      	ldr	r3, [r3, #0]
 80a1380:	9308      	str	r3, [sp, #32]
 80a1382:	4b43      	ldr	r3, [pc, #268]	; (80a1490 <loop+0x2e0>)
 80a1384:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a1388:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80a138c:	4b41      	ldr	r3, [pc, #260]	; (80a1494 <loop+0x2e4>)
 80a138e:	681b      	ldr	r3, [r3, #0]
 80a1390:	9304      	str	r3, [sp, #16]
 80a1392:	4b41      	ldr	r3, [pc, #260]	; (80a1498 <loop+0x2e8>)
 80a1394:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a1398:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80a139c:	4b3f      	ldr	r3, [pc, #252]	; (80a149c <loop+0x2ec>)
 80a139e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a13a2:	e9cd 2300 	strd	r2, r3, [sp]
 80a13a6:	4b3e      	ldr	r3, [pc, #248]	; (80a14a0 <loop+0x2f0>)
 80a13a8:	681a      	ldr	r2, [r3, #0]
 80a13aa:	f002 f803 	bl	80a33b4 <_ZN6String6formatEPKcz>
 80a13ae:	4b2d      	ldr	r3, [pc, #180]	; (80a1464 <loop+0x2b4>)
 80a13b0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 80a13b2:	781b      	ldrb	r3, [r3, #0]
 80a13b4:	493b      	ldr	r1, [pc, #236]	; (80a14a4 <loop+0x2f4>)
 80a13b6:	f88d 3000 	strb.w	r3, [sp]
 80a13ba:	a81a      	add	r0, sp, #104	; 0x68
 80a13bc:	233c      	movs	r3, #60	; 0x3c
 80a13be:	f002 fb95 	bl	80a3aec <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
 80a13c2:	a81a      	add	r0, sp, #104	; 0x68
 80a13c4:	f7ff fed2 	bl	80a116c <_ZNK8particle6FutureIbNS_6detail13FutureContextEE6resultEv>
 80a13c8:	7020      	strb	r0, [r4, #0]
 80a13ca:	a81b      	add	r0, sp, #108	; 0x6c
 80a13cc:	f7ff feb8 	bl	80a1140 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a13d0:	a81c      	add	r0, sp, #112	; 0x70
 80a13d2:	f001 ff0d 	bl	80a31f0 <_ZN6StringD1Ev>
      if (!success) {
 80a13d6:	7823      	ldrb	r3, [r4, #0]
 80a13d8:	b923      	cbnz	r3, 80a13e4 <loop+0x234>
        SERIAL_PORT.println("MMWIND Publish Failed");
 80a13da:	f002 fe95 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a13de:	4932      	ldr	r1, [pc, #200]	; (80a14a8 <loop+0x2f8>)
 80a13e0:	f002 f849 	bl	80a3476 <_ZN5Print7printlnEPKc>
 80a13e4:	f001 fc82 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
  if (millis() - lastSync > ONE_DAY_MILLIS) {
 80a13e8:	4c30      	ldr	r4, [pc, #192]	; (80a14ac <loop+0x2fc>)
 80a13ea:	6823      	ldr	r3, [r4, #0]
 80a13ec:	1ac0      	subs	r0, r0, r3
 80a13ee:	4b30      	ldr	r3, [pc, #192]	; (80a14b0 <loop+0x300>)
 80a13f0:	4298      	cmp	r0, r3
 80a13f2:	d97b      	bls.n	80a14ec <loop+0x33c>
    windgustmph = 0;
 80a13f4:	2200      	movs	r2, #0
 80a13f6:	2300      	movs	r3, #0
    windgustdir = 0;
 80a13f8:	2500      	movs	r5, #0
    windgustmph = 0;
 80a13fa:	4927      	ldr	r1, [pc, #156]	; (80a1498 <loop+0x2e8>)
 80a13fc:	e9c1 2300 	strd	r2, r3, [r1]
    windgustdir = 0;
 80a1400:	4924      	ldr	r1, [pc, #144]	; (80a1494 <loop+0x2e4>)
 80a1402:	600d      	str	r5, [r1, #0]
    dailyrainin = 0; // we meed to figure out how to do this right!!
 80a1404:	4904      	ldr	r1, [pc, #16]	; (80a1418 <loop+0x268>)
 80a1406:	e055      	b.n	80a14b4 <loop+0x304>
 80a1408:	c100e6b0 	.word	0xc100e6b0
 80a140c:	3f9e3d1c 	.word	0x3f9e3d1c
 80a1410:	00000000 	.word	0x00000000
 80a1414:	40efffc0 	.word	0x40efffc0
 80a1418:	200000c0 	.word	0x200000c0
 80a141c:	200000c8 	.word	0x200000c8
 80a1420:	200000e0 	.word	0x200000e0
 80a1424:	200000ac 	.word	0x200000ac
 80a1428:	20000098 	.word	0x20000098
 80a142c:	200000f4 	.word	0x200000f4
 80a1430:	200000a8 	.word	0x200000a8
 80a1434:	200000a4 	.word	0x200000a4
 80a1438:	200000d0 	.word	0x200000d0
 80a143c:	200000b8 	.word	0x200000b8
 80a1440:	200000d8 	.word	0x200000d8
 80a1444:	2000000c 	.word	0x2000000c
 80a1448:	20000120 	.word	0x20000120
 80a144c:	20000268 	.word	0x20000268
 80a1450:	40590000 	.word	0x40590000
 80a1454:	200000b0 	.word	0x200000b0
 80a1458:	20000250 	.word	0x20000250
 80a145c:	2000024c 	.word	0x2000024c
 80a1460:	080a70cb 	.word	0x080a70cb
 80a1464:	200000a0 	.word	0x200000a0
 80a1468:	080a7162 	.word	0x080a7162
 80a146c:	20000258 	.word	0x20000258
 80a1470:	080a716c 	.word	0x080a716c
 80a1474:	200000dc 	.word	0x200000dc
 80a1478:	20000010 	.word	0x20000010
 80a147c:	20000218 	.word	0x20000218
 80a1480:	080a7185 	.word	0x080a7185
 80a1484:	20000488 	.word	0x20000488
 80a1488:	200004c0 	.word	0x200004c0
 80a148c:	20000278 	.word	0x20000278
 80a1490:	20000540 	.word	0x20000540
 80a1494:	20000484 	.word	0x20000484
 80a1498:	200004b8 	.word	0x200004b8
 80a149c:	20000548 	.word	0x20000548
 80a14a0:	20000274 	.word	0x20000274
 80a14a4:	080a7238 	.word	0x080a7238
 80a14a8:	080a723f 	.word	0x080a723f
 80a14ac:	200000e4 	.word	0x200000e4
 80a14b0:	05265c00 	.word	0x05265c00
 80a14b4:	e9c1 2300 	strd	r2, r3, [r1]
    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a14b8:	f001 fdd2 	bl	80a3060 <spark_cloud_flag_connected>
        if (!connected()) {
 80a14bc:	b110      	cbz	r0, 80a14c4 <loop+0x314>
        return spark_sync_time(NULL);
 80a14be:	4628      	mov	r0, r5
 80a14c0:	f001 fdde 	bl	80a3080 <spark_sync_time>
    waitUntil(Particle.syncTimeDone);
 80a14c4:	f7fe fe7d 	bl	80a01c2 <_ZN10CloudClass12syncTimeDoneEv.isra.0>

    static uint32_t freeMemory();

    template<typename Condition, typename While>
    static bool waitConditionWhile(Condition _condition, While _while) {
        while (_while() && !_condition()) {
 80a14c8:	b958      	cbnz	r0, 80a14e2 <loop+0x332>
            spark_process();
 80a14ca:	f001 fdc1 	bl	80a3050 <spark_process>
        while (_while() && !_condition()) {
 80a14ce:	e7f9      	b.n	80a14c4 <loop+0x314>
    else if (myCCS811.checkForStatusError())
 80a14d0:	4808      	ldr	r0, [pc, #32]	; (80a14f4 <loop+0x344>)
 80a14d2:	f000 fda8 	bl	80a2026 <_ZN6CCS81119checkForStatusErrorEv>
 80a14d6:	2800      	cmp	r0, #0
 80a14d8:	f43f aead 	beq.w	80a1236 <loop+0x86>
      printSensorError();
 80a14dc:	f7ff fdda 	bl	80a1094 <_Z16printSensorErrorv>
 80a14e0:	e6a9      	b.n	80a1236 <loop+0x86>
    waitUntil(Particle.syncTimeDone);
 80a14e2:	f7fe fe6e 	bl	80a01c2 <_ZN10CloudClass12syncTimeDoneEv.isra.0>
 80a14e6:	f001 fc01 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
    lastSync = millis();
 80a14ea:	6020      	str	r0, [r4, #0]
}
 80a14ec:	b021      	add	sp, #132	; 0x84
 80a14ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a14f2:	bf00      	nop
 80a14f4:	200000f4 	.word	0x200000f4

080a14f8 <_GLOBAL__sub_I_oneWire>:
        val_(val) {
 80a14f8:	2201      	movs	r2, #1
}
 80a14fa:	b510      	push	{r4, lr}
 80a14fc:	4b0c      	ldr	r3, [pc, #48]	; (80a1530 <_GLOBAL__sub_I_oneWire+0x38>)
OneWire oneWire(ONE_WIRE_BUS);
 80a14fe:	4c0d      	ldr	r4, [pc, #52]	; (80a1534 <_GLOBAL__sub_I_oneWire+0x3c>)
 80a1500:	701a      	strb	r2, [r3, #0]
 80a1502:	2104      	movs	r1, #4
 80a1504:	4620      	mov	r0, r4
 80a1506:	f000 f970 	bl	80a17ea <_ZN7OneWireC1Et>
DallasTemperature sensors(&oneWire);
 80a150a:	4621      	mov	r1, r4
 80a150c:	480a      	ldr	r0, [pc, #40]	; (80a1538 <_GLOBAL__sub_I_oneWire+0x40>)
 80a150e:	f000 fadf 	bl	80a1ad0 <_ZN17DallasTemperatureC1EP7OneWire>
APDS9301 apds;
 80a1512:	480a      	ldr	r0, [pc, #40]	; (80a153c <_GLOBAL__sub_I_oneWire+0x44>)
 80a1514:	f001 f974 	bl	80a2800 <_ZN8APDS9301C1Ev>
Weather sensor;
 80a1518:	4809      	ldr	r0, [pc, #36]	; (80a1540 <_GLOBAL__sub_I_oneWire+0x48>)
 80a151a:	f000 ff19 	bl	80a2350 <_ZN7WeatherC1Ev>
CCS811 myCCS811(CCS811_ADDR);
 80a151e:	215b      	movs	r1, #91	; 0x5b
 80a1520:	4808      	ldr	r0, [pc, #32]	; (80a1544 <_GLOBAL__sub_I_oneWire+0x4c>)
 80a1522:	f000 fd61 	bl	80a1fe8 <_ZN6CCS811C1Eh>
 80a1526:	f001 fbe1 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
unsigned long lastSync = millis();
 80a152a:	4b07      	ldr	r3, [pc, #28]	; (80a1548 <_GLOBAL__sub_I_oneWire+0x50>)
 80a152c:	6018      	str	r0, [r3, #0]
}
 80a152e:	bd10      	pop	{r4, pc}
 80a1530:	200000a0 	.word	0x200000a0
 80a1534:	2000010c 	.word	0x2000010c
 80a1538:	20000230 	.word	0x20000230
 80a153c:	200000ac 	.word	0x200000ac
 80a1540:	2000022e 	.word	0x2000022e
 80a1544:	200000f4 	.word	0x200000f4
 80a1548:	200000e4 	.word	0x200000e4

080a154c <_Z17tinkerDigitalRead6String>:
 * Output         : None.
 * Return         : Value of the pin (0 or 1) in INT type
                    Returns a negative number on failure
 *******************************************************************************/
int tinkerDigitalRead(String pin)
{
 80a154c:	b5f0      	push	{r4, r5, r6, r7, lr}
	//convert ascii to integer
	int pinNumber = pin.charAt(1) - '0';
 80a154e:	2101      	movs	r1, #1
{
 80a1550:	b085      	sub	sp, #20
 80a1552:	4606      	mov	r6, r0
	int pinNumber = pin.charAt(1) - '0';
 80a1554:	f001 fefd 	bl	80a3352 <_ZNK6String6charAtEj>
 80a1558:	f1a0 0530 	sub.w	r5, r0, #48	; 0x30
	//Sanity check to see if the pin numbers are within limits
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a155c:	2d07      	cmp	r5, #7
	int pinNumber = pin.charAt(1) - '0';
 80a155e:	4604      	mov	r4, r0
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a1560:	d82c      	bhi.n	80a15bc <_Z17tinkerDigitalRead6String+0x70>

	if(pin.startsWith("D"))
 80a1562:	491a      	ldr	r1, [pc, #104]	; (80a15cc <_Z17tinkerDigitalRead6String+0x80>)
 80a1564:	4668      	mov	r0, sp
 80a1566:	f001 fe8d 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
 80a156a:	4669      	mov	r1, sp
 80a156c:	4630      	mov	r0, r6
 80a156e:	f001 fede 	bl	80a332e <_ZNK6String10startsWithERKS_>
 80a1572:	4607      	mov	r7, r0
 80a1574:	4668      	mov	r0, sp
 80a1576:	f001 fe3b 	bl	80a31f0 <_ZN6StringD1Ev>
 80a157a:	b157      	cbz	r7, 80a1592 <_Z17tinkerDigitalRead6String+0x46>
	{
		pinMode(pinNumber, INPUT_PULLDOWN);
 80a157c:	b2ad      	uxth	r5, r5
 80a157e:	4628      	mov	r0, r5
 80a1580:	2103      	movs	r1, #3
 80a1582:	f002 ffab 	bl	80a44dc <pinMode>
		return digitalRead(pinNumber);
 80a1586:	4628      	mov	r0, r5
	{
		pinMode(pinNumber+10, INPUT_PULLDOWN);
		return digitalRead(pinNumber+10);
	}
	return -2;
}
 80a1588:	b005      	add	sp, #20
 80a158a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		return digitalRead(pinNumber+10);
 80a158e:	f002 bfcf 	b.w	80a4530 <digitalRead>
	else if (pin.startsWith("A"))
 80a1592:	490f      	ldr	r1, [pc, #60]	; (80a15d0 <_Z17tinkerDigitalRead6String+0x84>)
 80a1594:	4668      	mov	r0, sp
 80a1596:	f001 fe75 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
 80a159a:	4669      	mov	r1, sp
 80a159c:	4630      	mov	r0, r6
 80a159e:	f001 fec6 	bl	80a332e <_ZNK6String10startsWithERKS_>
 80a15a2:	4605      	mov	r5, r0
 80a15a4:	4668      	mov	r0, sp
 80a15a6:	f001 fe23 	bl	80a31f0 <_ZN6StringD1Ev>
 80a15aa:	b15d      	cbz	r5, 80a15c4 <_Z17tinkerDigitalRead6String+0x78>
		pinMode(pinNumber+10, INPUT_PULLDOWN);
 80a15ac:	3c26      	subs	r4, #38	; 0x26
 80a15ae:	b2a4      	uxth	r4, r4
 80a15b0:	4620      	mov	r0, r4
 80a15b2:	2103      	movs	r1, #3
 80a15b4:	f002 ff92 	bl	80a44dc <pinMode>
		return digitalRead(pinNumber+10);
 80a15b8:	4620      	mov	r0, r4
 80a15ba:	e7e5      	b.n	80a1588 <_Z17tinkerDigitalRead6String+0x3c>
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a15bc:	f04f 30ff 	mov.w	r0, #4294967295
}
 80a15c0:	b005      	add	sp, #20
 80a15c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return -2;
 80a15c4:	f06f 0001 	mvn.w	r0, #1
 80a15c8:	e7fa      	b.n	80a15c0 <_Z17tinkerDigitalRead6String+0x74>
 80a15ca:	bf00      	nop
 80a15cc:	080a723d 	.word	0x080a723d
 80a15d0:	080a7255 	.word	0x080a7255

080a15d4 <_Z18tinkerDigitalWrite6String>:
 * Input          : Pin and value
 * Output         : None.
 * Return         : 1 on success and a negative number on failure
 *******************************************************************************/
int tinkerDigitalWrite(String command)
{
 80a15d4:	b5f0      	push	{r4, r5, r6, r7, lr}
	bool value = 0;
	//convert ascii to integer
	int pinNumber = command.charAt(1) - '0';
 80a15d6:	2101      	movs	r1, #1
{
 80a15d8:	b085      	sub	sp, #20
 80a15da:	4606      	mov	r6, r0
	int pinNumber = command.charAt(1) - '0';
 80a15dc:	f001 feb9 	bl	80a3352 <_ZNK6String6charAtEj>
 80a15e0:	f1a0 0430 	sub.w	r4, r0, #48	; 0x30
	//Sanity check to see if the pin numbers are within limits
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a15e4:	2c07      	cmp	r4, #7
 80a15e6:	d847      	bhi.n	80a1678 <_Z18tinkerDigitalWrite6String+0xa4>

	if(command.substring(3,7) == "HIGH") value = 1;
 80a15e8:	2307      	movs	r3, #7
 80a15ea:	2203      	movs	r2, #3
 80a15ec:	4631      	mov	r1, r6
 80a15ee:	4668      	mov	r0, sp
 80a15f0:	f001 feb2 	bl	80a3358 <_ZNK6String9substringEjj>
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
 80a15f4:	4668      	mov	r0, sp
 80a15f6:	4925      	ldr	r1, [pc, #148]	; (80a168c <_Z18tinkerDigitalWrite6String+0xb8>)
 80a15f8:	f001 fe71 	bl	80a32de <_ZNK6String6equalsEPKc>
 80a15fc:	4605      	mov	r5, r0
 80a15fe:	4668      	mov	r0, sp
 80a1600:	f001 fdf6 	bl	80a31f0 <_ZN6StringD1Ev>
 80a1604:	bb3d      	cbnz	r5, 80a1656 <_Z18tinkerDigitalWrite6String+0x82>
	else if(command.substring(3,6) == "LOW") value = 0;
 80a1606:	2306      	movs	r3, #6
 80a1608:	2203      	movs	r2, #3
 80a160a:	4631      	mov	r1, r6
 80a160c:	4668      	mov	r0, sp
 80a160e:	f001 fea3 	bl	80a3358 <_ZNK6String9substringEjj>
 80a1612:	4668      	mov	r0, sp
 80a1614:	491e      	ldr	r1, [pc, #120]	; (80a1690 <_Z18tinkerDigitalWrite6String+0xbc>)
 80a1616:	f001 fe62 	bl	80a32de <_ZNK6String6equalsEPKc>
 80a161a:	4607      	mov	r7, r0
 80a161c:	4668      	mov	r0, sp
 80a161e:	f001 fde7 	bl	80a31f0 <_ZN6StringD1Ev>
 80a1622:	b367      	cbz	r7, 80a167e <_Z18tinkerDigitalWrite6String+0xaa>
	else return -2;

	if(command.startsWith("D"))
 80a1624:	491b      	ldr	r1, [pc, #108]	; (80a1694 <_Z18tinkerDigitalWrite6String+0xc0>)
 80a1626:	4668      	mov	r0, sp
 80a1628:	f001 fe2c 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
 80a162c:	4669      	mov	r1, sp
 80a162e:	4630      	mov	r0, r6
 80a1630:	f001 fe7d 	bl	80a332e <_ZNK6String10startsWithERKS_>
 80a1634:	4607      	mov	r7, r0
 80a1636:	4668      	mov	r0, sp
 80a1638:	f001 fdda 	bl	80a31f0 <_ZN6StringD1Ev>
 80a163c:	b16f      	cbz	r7, 80a165a <_Z18tinkerDigitalWrite6String+0x86>
		digitalWrite(pinNumber, value);
		return 1;
	}
	else if(command.startsWith("A"))
	{
		pinMode(pinNumber+10, OUTPUT);
 80a163e:	b2a4      	uxth	r4, r4
 80a1640:	2101      	movs	r1, #1
 80a1642:	4620      	mov	r0, r4
 80a1644:	f002 ff4a 	bl	80a44dc <pinMode>
		digitalWrite(pinNumber+10, value);
 80a1648:	4620      	mov	r0, r4
 80a164a:	4629      	mov	r1, r5
 80a164c:	f002 ff57 	bl	80a44fe <digitalWrite>
		return 1;
 80a1650:	2001      	movs	r0, #1
	}
	else return -3;
}
 80a1652:	b005      	add	sp, #20
 80a1654:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if(command.substring(3,7) == "HIGH") value = 1;
 80a1656:	2501      	movs	r5, #1
 80a1658:	e7e4      	b.n	80a1624 <_Z18tinkerDigitalWrite6String+0x50>
	else if(command.startsWith("A"))
 80a165a:	490f      	ldr	r1, [pc, #60]	; (80a1698 <_Z18tinkerDigitalWrite6String+0xc4>)
 80a165c:	4668      	mov	r0, sp
 80a165e:	f001 fe11 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
 80a1662:	4630      	mov	r0, r6
 80a1664:	4669      	mov	r1, sp
 80a1666:	f001 fe62 	bl	80a332e <_ZNK6String10startsWithERKS_>
 80a166a:	4606      	mov	r6, r0
 80a166c:	4668      	mov	r0, sp
 80a166e:	f001 fdbf 	bl	80a31f0 <_ZN6StringD1Ev>
 80a1672:	b13e      	cbz	r6, 80a1684 <_Z18tinkerDigitalWrite6String+0xb0>
		pinMode(pinNumber+10, OUTPUT);
 80a1674:	340a      	adds	r4, #10
 80a1676:	e7e2      	b.n	80a163e <_Z18tinkerDigitalWrite6String+0x6a>
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a1678:	f04f 30ff 	mov.w	r0, #4294967295
 80a167c:	e7e9      	b.n	80a1652 <_Z18tinkerDigitalWrite6String+0x7e>
	else return -2;
 80a167e:	f06f 0001 	mvn.w	r0, #1
 80a1682:	e7e6      	b.n	80a1652 <_Z18tinkerDigitalWrite6String+0x7e>
	else return -3;
 80a1684:	f06f 0002 	mvn.w	r0, #2
 80a1688:	e7e3      	b.n	80a1652 <_Z18tinkerDigitalWrite6String+0x7e>
 80a168a:	bf00      	nop
 80a168c:	080a7257 	.word	0x080a7257
 80a1690:	080a725c 	.word	0x080a725c
 80a1694:	080a723d 	.word	0x080a723d
 80a1698:	080a7255 	.word	0x080a7255

080a169c <_Z16tinkerAnalogRead6String>:
 * Output         : None.
 * Return         : Returns the analog value in INT type (0 to 4095)
                    Returns a negative number on failure
 *******************************************************************************/
int tinkerAnalogRead(String pin)
{
 80a169c:	b5f0      	push	{r4, r5, r6, r7, lr}
	//convert ascii to integer
	int pinNumber = pin.charAt(1) - '0';
 80a169e:	2101      	movs	r1, #1
{
 80a16a0:	b085      	sub	sp, #20
 80a16a2:	4607      	mov	r7, r0
	int pinNumber = pin.charAt(1) - '0';
 80a16a4:	f001 fe55 	bl	80a3352 <_ZNK6String6charAtEj>
 80a16a8:	f1a0 0530 	sub.w	r5, r0, #48	; 0x30
	//Sanity check to see if the pin numbers are within limits
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a16ac:	2d07      	cmp	r5, #7
	int pinNumber = pin.charAt(1) - '0';
 80a16ae:	4604      	mov	r4, r0
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a16b0:	d82c      	bhi.n	80a170c <_Z16tinkerAnalogRead6String+0x70>

	if(pin.startsWith("D"))
 80a16b2:	491a      	ldr	r1, [pc, #104]	; (80a171c <_Z16tinkerAnalogRead6String+0x80>)
 80a16b4:	4668      	mov	r0, sp
 80a16b6:	f001 fde5 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
 80a16ba:	4669      	mov	r1, sp
 80a16bc:	4638      	mov	r0, r7
 80a16be:	f001 fe36 	bl	80a332e <_ZNK6String10startsWithERKS_>
 80a16c2:	4606      	mov	r6, r0
 80a16c4:	4668      	mov	r0, sp
 80a16c6:	f001 fd93 	bl	80a31f0 <_ZN6StringD1Ev>
 80a16ca:	b156      	cbz	r6, 80a16e2 <_Z16tinkerAnalogRead6String+0x46>
	{
		pinMode(pinNumber, INPUT);
 80a16cc:	b2ad      	uxth	r5, r5
 80a16ce:	4628      	mov	r0, r5
 80a16d0:	2100      	movs	r1, #0
 80a16d2:	f002 ff03 	bl	80a44dc <pinMode>
		return analogRead(pinNumber);
 80a16d6:	4628      	mov	r0, r5
	{
		pinMode(pinNumber+10, INPUT);
		return analogRead(pinNumber+10);
	}
	return -2;
}
 80a16d8:	b005      	add	sp, #20
 80a16da:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		return analogRead(pinNumber+10);
 80a16de:	f002 bf3a 	b.w	80a4556 <analogRead>
	else if (pin.startsWith("A"))
 80a16e2:	490f      	ldr	r1, [pc, #60]	; (80a1720 <_Z16tinkerAnalogRead6String+0x84>)
 80a16e4:	4668      	mov	r0, sp
 80a16e6:	f001 fdcd 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
 80a16ea:	4669      	mov	r1, sp
 80a16ec:	4638      	mov	r0, r7
 80a16ee:	f001 fe1e 	bl	80a332e <_ZNK6String10startsWithERKS_>
 80a16f2:	4605      	mov	r5, r0
 80a16f4:	4668      	mov	r0, sp
 80a16f6:	f001 fd7b 	bl	80a31f0 <_ZN6StringD1Ev>
 80a16fa:	b15d      	cbz	r5, 80a1714 <_Z16tinkerAnalogRead6String+0x78>
		pinMode(pinNumber+10, INPUT);
 80a16fc:	3c26      	subs	r4, #38	; 0x26
 80a16fe:	b2a4      	uxth	r4, r4
 80a1700:	4620      	mov	r0, r4
 80a1702:	4631      	mov	r1, r6
 80a1704:	f002 feea 	bl	80a44dc <pinMode>
		return analogRead(pinNumber+10);
 80a1708:	4620      	mov	r0, r4
 80a170a:	e7e5      	b.n	80a16d8 <_Z16tinkerAnalogRead6String+0x3c>
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a170c:	f04f 30ff 	mov.w	r0, #4294967295
}
 80a1710:	b005      	add	sp, #20
 80a1712:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return -2;
 80a1714:	f06f 0001 	mvn.w	r0, #1
 80a1718:	e7fa      	b.n	80a1710 <_Z16tinkerAnalogRead6String+0x74>
 80a171a:	bf00      	nop
 80a171c:	080a723d 	.word	0x080a723d
 80a1720:	080a7255 	.word	0x080a7255

080a1724 <_Z17tinkerAnalogWrite6String>:
 * Input          : Pin and Value (0 to 255)
 * Output         : None.
 * Return         : 1 on success and a negative number on failure
 *******************************************************************************/
int tinkerAnalogWrite(String command)
{
 80a1724:	b5f0      	push	{r4, r5, r6, r7, lr}
	//convert ascii to integer
	int pinNumber = command.charAt(1) - '0';
 80a1726:	2101      	movs	r1, #1
{
 80a1728:	b089      	sub	sp, #36	; 0x24
 80a172a:	4605      	mov	r5, r0
	int pinNumber = command.charAt(1) - '0';
 80a172c:	f001 fe11 	bl	80a3352 <_ZNK6String6charAtEj>
 80a1730:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	//Sanity check to see if the pin numbers are within limits
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a1734:	2e07      	cmp	r6, #7
	int pinNumber = command.charAt(1) - '0';
 80a1736:	4604      	mov	r4, r0
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a1738:	d840      	bhi.n	80a17bc <_Z17tinkerAnalogWrite6String+0x98>

	String value = command.substring(3);
 80a173a:	2203      	movs	r2, #3
 80a173c:	4629      	mov	r1, r5
 80a173e:	4668      	mov	r0, sp
 80a1740:	f001 fe2c 	bl	80a339c <_ZNK6String9substringEj>

	if(command.startsWith("D"))
 80a1744:	491f      	ldr	r1, [pc, #124]	; (80a17c4 <_Z17tinkerAnalogWrite6String+0xa0>)
 80a1746:	a804      	add	r0, sp, #16
 80a1748:	f001 fd9c 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
 80a174c:	4628      	mov	r0, r5
 80a174e:	a904      	add	r1, sp, #16
 80a1750:	f001 fded 	bl	80a332e <_ZNK6String10startsWithERKS_>
 80a1754:	4607      	mov	r7, r0
 80a1756:	a804      	add	r0, sp, #16
 80a1758:	f001 fd4a 	bl	80a31f0 <_ZN6StringD1Ev>
 80a175c:	b197      	cbz	r7, 80a1784 <_Z17tinkerAnalogWrite6String+0x60>
	{
		pinMode(pinNumber, OUTPUT);
 80a175e:	b2b6      	uxth	r6, r6
 80a1760:	2101      	movs	r1, #1
 80a1762:	4630      	mov	r0, r6
 80a1764:	f002 feba 	bl	80a44dc <pinMode>
		analogWrite(pinNumber, value.toInt());
 80a1768:	4668      	mov	r0, sp
 80a176a:	f001 fe1e 	bl	80a33aa <_ZNK6String5toIntEv>
 80a176e:	4601      	mov	r1, r0
 80a1770:	4630      	mov	r0, r6
		return 1;
	}
	else if(command.startsWith("A"))
	{
		pinMode(pinNumber+10, OUTPUT);
		analogWrite(pinNumber+10, value.toInt());
 80a1772:	f002 ff07 	bl	80a4584 <_Z11analogWritetm>
		return 1;
 80a1776:	2401      	movs	r4, #1
	String value = command.substring(3);
 80a1778:	4668      	mov	r0, sp
 80a177a:	f001 fd39 	bl	80a31f0 <_ZN6StringD1Ev>
	}
	else return -2;
}
 80a177e:	4620      	mov	r0, r4
 80a1780:	b009      	add	sp, #36	; 0x24
 80a1782:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else if(command.startsWith("A"))
 80a1784:	4910      	ldr	r1, [pc, #64]	; (80a17c8 <_Z17tinkerAnalogWrite6String+0xa4>)
 80a1786:	a804      	add	r0, sp, #16
 80a1788:	f001 fd7c 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
 80a178c:	4628      	mov	r0, r5
 80a178e:	a904      	add	r1, sp, #16
 80a1790:	f001 fdcd 	bl	80a332e <_ZNK6String10startsWithERKS_>
 80a1794:	4605      	mov	r5, r0
 80a1796:	a804      	add	r0, sp, #16
 80a1798:	f001 fd2a 	bl	80a31f0 <_ZN6StringD1Ev>
 80a179c:	b15d      	cbz	r5, 80a17b6 <_Z17tinkerAnalogWrite6String+0x92>
		pinMode(pinNumber+10, OUTPUT);
 80a179e:	3c26      	subs	r4, #38	; 0x26
 80a17a0:	b2a4      	uxth	r4, r4
 80a17a2:	2101      	movs	r1, #1
 80a17a4:	4620      	mov	r0, r4
 80a17a6:	f002 fe99 	bl	80a44dc <pinMode>
		analogWrite(pinNumber+10, value.toInt());
 80a17aa:	4668      	mov	r0, sp
 80a17ac:	f001 fdfd 	bl	80a33aa <_ZNK6String5toIntEv>
 80a17b0:	4601      	mov	r1, r0
 80a17b2:	4620      	mov	r0, r4
 80a17b4:	e7dd      	b.n	80a1772 <_Z17tinkerAnalogWrite6String+0x4e>
	else return -2;
 80a17b6:	f06f 0401 	mvn.w	r4, #1
 80a17ba:	e7dd      	b.n	80a1778 <_Z17tinkerAnalogWrite6String+0x54>
	if (pinNumber< 0 || pinNumber >7) return -1;
 80a17bc:	f04f 34ff 	mov.w	r4, #4294967295
 80a17c0:	e7dd      	b.n	80a177e <_Z17tinkerAnalogWrite6String+0x5a>
 80a17c2:	bf00      	nop
 80a17c4:	080a723d 	.word	0x080a723d
 80a17c8:	080a7255 	.word	0x080a7255

080a17cc <_ZN7OneWire16pinModeFastInputEv.isra.0>:
    }

    inline void pinModeFastInput(void){
      // This could probably be speed up by digging a little deeper past
      // the HAL_Pin_Mode function.
      HAL_Pin_Mode(_pin, INPUT);
 80a17cc:	2100      	movs	r1, #0
 80a17ce:	f001 ba25 	b.w	80a2c1c <HAL_Pin_Mode>

080a17d2 <_ZN7OneWire17pinModeFastOutputEv.isra.0>:
      HAL_Pin_Mode(_pin, OUTPUT);
 80a17d2:	2101      	movs	r1, #1
 80a17d4:	f001 ba22 	b.w	80a2c1c <HAL_Pin_Mode>

080a17d8 <_ZN7OneWire19digitalWriteFastLowEv>:
      PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a17d8:	221c      	movs	r2, #28
 80a17da:	8803      	ldrh	r3, [r0, #0]
 80a17dc:	4353      	muls	r3, r2
 80a17de:	6842      	ldr	r2, [r0, #4]
 80a17e0:	18d1      	adds	r1, r2, r3
 80a17e2:	58d3      	ldr	r3, [r2, r3]
 80a17e4:	888a      	ldrh	r2, [r1, #4]
 80a17e6:	835a      	strh	r2, [r3, #26]
    }
 80a17e8:	4770      	bx	lr

080a17ea <_ZN7OneWireC1Et>:
*/

#include "OneWire.h"
#include "application.h"

OneWire::OneWire(uint16_t pin)
 80a17ea:	b538      	push	{r3, r4, r5, lr}
 80a17ec:	4604      	mov	r4, r0
 80a17ee:	460d      	mov	r5, r1
 80a17f0:	f001 fa04 	bl	80a2bfc <HAL_Pin_Map>
{
    pinMode(pin, INPUT);
 80a17f4:	2100      	movs	r1, #0
OneWire::OneWire(uint16_t pin)
 80a17f6:	6060      	str	r0, [r4, #4]
    pinMode(pin, INPUT);
 80a17f8:	4628      	mov	r0, r5
 80a17fa:	f002 fe6f 	bl	80a44dc <pinMode>
    _pin = pin;
}
 80a17fe:	4620      	mov	r0, r4
    _pin = pin;
 80a1800:	8025      	strh	r5, [r4, #0]
}
 80a1802:	bd38      	pop	{r3, r4, r5, pc}

080a1804 <_ZN7OneWire5resetEv>:
// the bus to come high, if it doesn't then it is broken or shorted
// and we return a 0;
//
// Returns 1 if a device asserted a presence pulse, 0 otherwise.
//
uint8_t OneWire::reset(void){
 80a1804:	b538      	push	{r3, r4, r5, lr}
 80a1806:	4605      	mov	r5, r0
    uint8_t r;
    uint8_t retries = 125;

    noInterrupts();
 80a1808:	f002 fc20 	bl	80a404c <_Z12noInterruptsv>
    pinModeFastInput();
 80a180c:	8828      	ldrh	r0, [r5, #0]
 80a180e:	f7ff ffdd 	bl	80a17cc <_ZN7OneWire16pinModeFastInputEv.isra.0>
    interrupts();
 80a1812:	247d      	movs	r4, #125	; 0x7d
 80a1814:	f002 fc1c 	bl	80a4050 <_Z10interruptsv>
    // wait until the wire is high... just in case
    do {
        if (--retries == 0) return 0;
 80a1818:	3c01      	subs	r4, #1
 80a181a:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 80a181e:	d02b      	beq.n	80a1878 <_ZN7OneWire5resetEv+0x74>
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
void delay(unsigned long ms);
inline void delayMicroseconds(unsigned int us) { HAL_Delay_Microseconds(us); }
 80a1820:	2002      	movs	r0, #2
 80a1822:	f001 fa5b 	bl	80a2cdc <HAL_Delay_Microseconds>
    }

    inline uint8_t digitalReadFast(void){
      // This could probably be speed up by digging a little deeper past
      // the HAL_GPIO_Read function.
      return HAL_GPIO_Read(_pin);
 80a1826:	8828      	ldrh	r0, [r5, #0]
 80a1828:	f001 fa10 	bl	80a2c4c <HAL_GPIO_Read>

        delayMicroseconds(2);
    } while ( !digitalReadFast());
 80a182c:	b2c0      	uxtb	r0, r0
 80a182e:	2800      	cmp	r0, #0
 80a1830:	d0f2      	beq.n	80a1818 <_ZN7OneWire5resetEv+0x14>

    noInterrupts();
 80a1832:	f002 fc0b 	bl	80a404c <_Z12noInterruptsv>

    digitalWriteFastLow();
 80a1836:	4628      	mov	r0, r5
 80a1838:	f7ff ffce 	bl	80a17d8 <_ZN7OneWire19digitalWriteFastLowEv>
    pinModeFastOutput();   // drive output low
 80a183c:	8828      	ldrh	r0, [r5, #0]
 80a183e:	f7ff ffc8 	bl	80a17d2 <_ZN7OneWire17pinModeFastOutputEv.isra.0>

    interrupts();
 80a1842:	f002 fc05 	bl	80a4050 <_Z10interruptsv>
 80a1846:	f44f 70f0 	mov.w	r0, #480	; 0x1e0
 80a184a:	f001 fa47 	bl	80a2cdc <HAL_Delay_Microseconds>
    delayMicroseconds(480);
    noInterrupts();
 80a184e:	f002 fbfd 	bl	80a404c <_Z12noInterruptsv>

    pinModeFastInput();    // allow it to float
 80a1852:	8828      	ldrh	r0, [r5, #0]
 80a1854:	f7ff ffba 	bl	80a17cc <_ZN7OneWire16pinModeFastInputEv.isra.0>
 80a1858:	2046      	movs	r0, #70	; 0x46
 80a185a:	f001 fa3f 	bl	80a2cdc <HAL_Delay_Microseconds>
 80a185e:	8828      	ldrh	r0, [r5, #0]
 80a1860:	f001 f9f4 	bl	80a2c4c <HAL_GPIO_Read>

    delayMicroseconds(70);

    r =! digitalReadFast();
 80a1864:	b2c4      	uxtb	r4, r0
 80a1866:	fab4 f484 	clz	r4, r4

    interrupts();
 80a186a:	f002 fbf1 	bl	80a4050 <_Z10interruptsv>
 80a186e:	f44f 70cd 	mov.w	r0, #410	; 0x19a
    r =! digitalReadFast();
 80a1872:	0964      	lsrs	r4, r4, #5
 80a1874:	f001 fa32 	bl	80a2cdc <HAL_Delay_Microseconds>

    delayMicroseconds(410);

    return r;
}
 80a1878:	4620      	mov	r0, r4
 80a187a:	bd38      	pop	{r3, r4, r5, pc}

080a187c <_ZN7OneWire9write_bitEh>:

void OneWire::write_bit(uint8_t v){
    if (v & 1) {
 80a187c:	07cb      	lsls	r3, r1, #31
void OneWire::write_bit(uint8_t v){
 80a187e:	b510      	push	{r4, lr}
 80a1880:	4604      	mov	r4, r0
    if (v & 1) {
 80a1882:	d519      	bpl.n	80a18b8 <_ZN7OneWire9write_bitEh+0x3c>
        noInterrupts();
 80a1884:	f002 fbe2 	bl	80a404c <_Z12noInterruptsv>

        digitalWriteFastLow();
 80a1888:	4620      	mov	r0, r4
 80a188a:	f7ff ffa5 	bl	80a17d8 <_ZN7OneWire19digitalWriteFastLowEv>
        pinModeFastOutput();   // drive output low
 80a188e:	8820      	ldrh	r0, [r4, #0]
 80a1890:	f7ff ff9f 	bl	80a17d2 <_ZN7OneWire17pinModeFastOutputEv.isra.0>
 80a1894:	200a      	movs	r0, #10
 80a1896:	f001 fa21 	bl	80a2cdc <HAL_Delay_Microseconds>
      PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a189a:	221c      	movs	r2, #28
 80a189c:	8823      	ldrh	r3, [r4, #0]
 80a189e:	4353      	muls	r3, r2
 80a18a0:	6862      	ldr	r2, [r4, #4]
 80a18a2:	18d1      	adds	r1, r2, r3
 80a18a4:	58d3      	ldr	r3, [r2, r3]
 80a18a6:	888a      	ldrh	r2, [r1, #4]
 80a18a8:	831a      	strh	r2, [r3, #24]

        delayMicroseconds(10);

        digitalWriteFastHigh();    // drive output high

        interrupts();
 80a18aa:	f002 fbd1 	bl	80a4050 <_Z10interruptsv>
 80a18ae:	2037      	movs	r0, #55	; 0x37

        interrupts();

        delayMicroseconds(5);
    }
}
 80a18b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a18b4:	f001 ba12 	b.w	80a2cdc <HAL_Delay_Microseconds>
        noInterrupts();
 80a18b8:	f002 fbc8 	bl	80a404c <_Z12noInterruptsv>
        digitalWriteFastLow();
 80a18bc:	4620      	mov	r0, r4
 80a18be:	f7ff ff8b 	bl	80a17d8 <_ZN7OneWire19digitalWriteFastLowEv>
        pinModeFastOutput();   // drive output low
 80a18c2:	8820      	ldrh	r0, [r4, #0]
 80a18c4:	f7ff ff85 	bl	80a17d2 <_ZN7OneWire17pinModeFastOutputEv.isra.0>
 80a18c8:	2041      	movs	r0, #65	; 0x41
 80a18ca:	f001 fa07 	bl	80a2cdc <HAL_Delay_Microseconds>
 80a18ce:	221c      	movs	r2, #28
 80a18d0:	8823      	ldrh	r3, [r4, #0]
 80a18d2:	4353      	muls	r3, r2
 80a18d4:	6862      	ldr	r2, [r4, #4]
 80a18d6:	18d1      	adds	r1, r2, r3
 80a18d8:	58d3      	ldr	r3, [r2, r3]
 80a18da:	888a      	ldrh	r2, [r1, #4]
 80a18dc:	831a      	strh	r2, [r3, #24]
        interrupts();
 80a18de:	f002 fbb7 	bl	80a4050 <_Z10interruptsv>
 80a18e2:	2005      	movs	r0, #5
 80a18e4:	e7e4      	b.n	80a18b0 <_ZN7OneWire9write_bitEh+0x34>

080a18e6 <_ZN7OneWire8read_bitEv>:

//
// Read a bit. Port and bit is used to cut lookup time and provide
// more certain timing.
//
uint8_t OneWire::read_bit(void){
 80a18e6:	b510      	push	{r4, lr}
 80a18e8:	4604      	mov	r4, r0
    uint8_t r;

    noInterrupts();
 80a18ea:	f002 fbaf 	bl	80a404c <_Z12noInterruptsv>

    pinModeFastOutput();
 80a18ee:	8820      	ldrh	r0, [r4, #0]
 80a18f0:	f7ff ff6f 	bl	80a17d2 <_ZN7OneWire17pinModeFastOutputEv.isra.0>
    digitalWriteFastLow();
 80a18f4:	4620      	mov	r0, r4
 80a18f6:	f7ff ff6f 	bl	80a17d8 <_ZN7OneWire19digitalWriteFastLowEv>
 80a18fa:	2003      	movs	r0, #3
 80a18fc:	f001 f9ee 	bl	80a2cdc <HAL_Delay_Microseconds>

    delayMicroseconds(3);

    pinModeFastInput();    // let pin float, pull up will raise
 80a1900:	8820      	ldrh	r0, [r4, #0]
 80a1902:	f7ff ff63 	bl	80a17cc <_ZN7OneWire16pinModeFastInputEv.isra.0>
 80a1906:	200a      	movs	r0, #10
 80a1908:	f001 f9e8 	bl	80a2cdc <HAL_Delay_Microseconds>
      return HAL_GPIO_Read(_pin);
 80a190c:	8820      	ldrh	r0, [r4, #0]
 80a190e:	f001 f99d 	bl	80a2c4c <HAL_GPIO_Read>
 80a1912:	4604      	mov	r4, r0

    delayMicroseconds(10);

    r = digitalReadFast();

    interrupts();
 80a1914:	f002 fb9c 	bl	80a4050 <_Z10interruptsv>
 80a1918:	2035      	movs	r0, #53	; 0x35
 80a191a:	f001 f9df 	bl	80a2cdc <HAL_Delay_Microseconds>
    delayMicroseconds(53);

    return r;
}
 80a191e:	b2e0      	uxtb	r0, r4
 80a1920:	bd10      	pop	{r4, pc}

080a1922 <_ZN7OneWire5writeEhh>:
// pin high, if you need power after the write (e.g. DS18S20 in
// parasite power mode) then set 'power' to 1, otherwise the pin will
// go tri-state at the end of the write to avoid heating in a short or
// other mishap.
//
void OneWire::write(uint8_t v, uint8_t power /* = 0 */) {
 80a1922:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a1926:	4604      	mov	r4, r0
 80a1928:	4688      	mov	r8, r1
 80a192a:	4616      	mov	r6, r2
 80a192c:	2708      	movs	r7, #8
    uint8_t bitMask;

    for (bitMask = 0x01; bitMask; bitMask <<= 1) {
 80a192e:	2501      	movs	r5, #1
        OneWire::write_bit( (bitMask & v)?1:0);
 80a1930:	ea18 0f05 	tst.w	r8, r5
 80a1934:	bf14      	ite	ne
 80a1936:	2101      	movne	r1, #1
 80a1938:	2100      	moveq	r1, #0
 80a193a:	4620      	mov	r0, r4
 80a193c:	f7ff ff9e 	bl	80a187c <_ZN7OneWire9write_bitEh>
    for (bitMask = 0x01; bitMask; bitMask <<= 1) {
 80a1940:	006d      	lsls	r5, r5, #1
 80a1942:	3f01      	subs	r7, #1
 80a1944:	b2ed      	uxtb	r5, r5
 80a1946:	d1f3      	bne.n	80a1930 <_ZN7OneWire5writeEhh+0xe>
    }

    if ( !power) {
 80a1948:	b95e      	cbnz	r6, 80a1962 <_ZN7OneWire5writeEhh+0x40>
        noInterrupts();
 80a194a:	f002 fb7f 	bl	80a404c <_Z12noInterruptsv>

        pinModeFastInput();
 80a194e:	8820      	ldrh	r0, [r4, #0]
 80a1950:	f7ff ff3c 	bl	80a17cc <_ZN7OneWire16pinModeFastInputEv.isra.0>
        digitalWriteFastLow();
 80a1954:	4620      	mov	r0, r4
 80a1956:	f7ff ff3f 	bl	80a17d8 <_ZN7OneWire19digitalWriteFastLowEv>

        interrupts();
    }
}
 80a195a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        interrupts();
 80a195e:	f002 bb77 	b.w	80a4050 <_Z10interruptsv>
}
 80a1962:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a1966 <_ZN7OneWire4readEv>:
}

//
// Read a byte
//
uint8_t OneWire::read() {
 80a1966:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1968:	4607      	mov	r7, r0
 80a196a:	2608      	movs	r6, #8
    uint8_t bitMask;
    uint8_t r = 0;
 80a196c:	2500      	movs	r5, #0

    for (bitMask = 0x01; bitMask; bitMask <<= 1) {
 80a196e:	2401      	movs	r4, #1
        if ( OneWire::read_bit()) r |= bitMask;
 80a1970:	4638      	mov	r0, r7
 80a1972:	f7ff ffb8 	bl	80a18e6 <_ZN7OneWire8read_bitEv>
 80a1976:	b100      	cbz	r0, 80a197a <_ZN7OneWire4readEv+0x14>
 80a1978:	4325      	orrs	r5, r4
    for (bitMask = 0x01; bitMask; bitMask <<= 1) {
 80a197a:	0064      	lsls	r4, r4, #1
 80a197c:	3e01      	subs	r6, #1
 80a197e:	b2e4      	uxtb	r4, r4
 80a1980:	d1f6      	bne.n	80a1970 <_ZN7OneWire4readEv+0xa>
    }

    return r;
}
 80a1982:	4628      	mov	r0, r5
 80a1984:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1986 <_ZN7OneWire6selectEPKh>:
}

//
// Do a ROM select
//
void OneWire::select(const uint8_t rom[8]){
 80a1986:	b570      	push	{r4, r5, r6, lr}
    uint8_t i;

    write(0x55);           // Choose ROM
 80a1988:	2200      	movs	r2, #0
void OneWire::select(const uint8_t rom[8]){
 80a198a:	460c      	mov	r4, r1
    write(0x55);           // Choose ROM
 80a198c:	2155      	movs	r1, #85	; 0x55
void OneWire::select(const uint8_t rom[8]){
 80a198e:	4606      	mov	r6, r0
    write(0x55);           // Choose ROM
 80a1990:	f7ff ffc7 	bl	80a1922 <_ZN7OneWire5writeEhh>

    for (i = 0; i < 8; i++) write(rom[i]);
 80a1994:	1e65      	subs	r5, r4, #1
 80a1996:	3407      	adds	r4, #7
 80a1998:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80a199c:	2200      	movs	r2, #0
 80a199e:	4630      	mov	r0, r6
 80a19a0:	f7ff ffbf 	bl	80a1922 <_ZN7OneWire5writeEhh>
 80a19a4:	42a5      	cmp	r5, r4
 80a19a6:	d1f7      	bne.n	80a1998 <_ZN7OneWire6selectEPKh+0x12>
}
 80a19a8:	bd70      	pop	{r4, r5, r6, pc}

080a19aa <_ZN7OneWire4skipEv>:

//
// Do a ROM skip
//
void OneWire::skip(){
    write(0xCC);           // Skip ROM
 80a19aa:	2200      	movs	r2, #0
 80a19ac:	21cc      	movs	r1, #204	; 0xcc
 80a19ae:	f7ff bfb8 	b.w	80a1922 <_ZN7OneWire5writeEhh>

080a19b2 <_ZN7OneWire12reset_searchEv>:
// You need to use this function to start a search again from the beginning.
// You do not need to do it for the first search, though you could.
//
void OneWire::reset_search(){
    // reset the search state
    LastDiscrepancy = 0;
 80a19b2:	2300      	movs	r3, #0
 80a19b4:	8203      	strh	r3, [r0, #16]
    LastDeviceFlag = FALSE;
 80a19b6:	7483      	strb	r3, [r0, #18]
    LastFamilyDiscrepancy = 0;

    for(int i = 7; ; i--) {
        ROM_NO[i] = 0;
 80a19b8:	6083      	str	r3, [r0, #8]
 80a19ba:	60c3      	str	r3, [r0, #12]
        if ( i == 0) break;
    }
}
 80a19bc:	4770      	bx	lr

080a19be <_ZN7OneWire6searchEPh>:
// Perform the 1-Wire Search Algorithm on the 1-Wire bus using the existing
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
uint8_t OneWire::search(uint8_t *newAddr){
 80a19be:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    rom_byte_number = 0;
    rom_byte_mask = 1;
    search_result = 0;

    // if the last call was not the last one
    if (!LastDeviceFlag)
 80a19c2:	7c85      	ldrb	r5, [r0, #18]
uint8_t OneWire::search(uint8_t *newAddr){
 80a19c4:	4604      	mov	r4, r0
 80a19c6:	4688      	mov	r8, r1
    if (!LastDeviceFlag)
 80a19c8:	b175      	cbz	r5, 80a19e8 <_ZN7OneWire6searchEPh+0x2a>
        }
    }

    // if no device found then reset counters so next 'search' will be like a first
    if (!search_result || !ROM_NO[0]){
        LastDiscrepancy = 0;
 80a19ca:	2000      	movs	r0, #0
 80a19cc:	8220      	strh	r0, [r4, #16]
        LastDeviceFlag = FALSE;
 80a19ce:	74a0      	strb	r0, [r4, #18]
        LastFamilyDiscrepancy = 0;
        search_result = FALSE;
    }

    for (int i = 0; i < 8; i++) newAddr[i] = ROM_NO[i];
 80a19d0:	f104 0308 	add.w	r3, r4, #8
 80a19d4:	f108 38ff 	add.w	r8, r8, #4294967295
 80a19d8:	3410      	adds	r4, #16
 80a19da:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a19de:	429c      	cmp	r4, r3
 80a19e0:	f808 2f01 	strb.w	r2, [r8, #1]!
 80a19e4:	d1f9      	bne.n	80a19da <_ZN7OneWire6searchEPh+0x1c>
 80a19e6:	e004      	b.n	80a19f2 <_ZN7OneWire6searchEPh+0x34>
        if (!reset()){
 80a19e8:	f7ff ff0c 	bl	80a1804 <_ZN7OneWire5resetEv>
 80a19ec:	b918      	cbnz	r0, 80a19f6 <_ZN7OneWire6searchEPh+0x38>
            LastDiscrepancy = 0;
 80a19ee:	8220      	strh	r0, [r4, #16]
            LastDeviceFlag = FALSE;
 80a19f0:	74a0      	strb	r0, [r4, #18]

    return search_result;
}
 80a19f2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    rom_byte_mask = 1;
 80a19f6:	2701      	movs	r7, #1
        write(0xF0);
 80a19f8:	462a      	mov	r2, r5
 80a19fa:	21f0      	movs	r1, #240	; 0xf0
 80a19fc:	4620      	mov	r0, r4
 80a19fe:	f7ff ff90 	bl	80a1922 <_ZN7OneWire5writeEhh>
    last_zero = 0;
 80a1a02:	46aa      	mov	sl, r5
    id_bit_number = 1;
 80a1a04:	463e      	mov	r6, r7
            id_bit = read_bit();
 80a1a06:	4620      	mov	r0, r4
 80a1a08:	f7ff ff6d 	bl	80a18e6 <_ZN7OneWire8read_bitEv>
 80a1a0c:	4681      	mov	r9, r0
 80a1a0e:	4683      	mov	fp, r0
            cmp_id_bit = read_bit();
 80a1a10:	4620      	mov	r0, r4
 80a1a12:	f7ff ff68 	bl	80a18e6 <_ZN7OneWire8read_bitEv>
            if ((id_bit == 1) && (cmp_id_bit == 1)){
 80a1a16:	f1b9 0f01 	cmp.w	r9, #1
 80a1a1a:	d10f      	bne.n	80a1a3c <_ZN7OneWire6searchEPh+0x7e>
 80a1a1c:	2801      	cmp	r0, #1
 80a1a1e:	d117      	bne.n	80a1a50 <_ZN7OneWire6searchEPh+0x92>
        if (!(id_bit_number < 65))
 80a1a20:	2e40      	cmp	r6, #64	; 0x40
 80a1a22:	d9d2      	bls.n	80a19ca <_ZN7OneWire6searchEPh+0xc>
            LastDiscrepancy = last_zero;
 80a1a24:	f884 a010 	strb.w	sl, [r4, #16]
            if (LastDiscrepancy == 0)
 80a1a28:	f1ba 0f00 	cmp.w	sl, #0
 80a1a2c:	d101      	bne.n	80a1a32 <_ZN7OneWire6searchEPh+0x74>
                LastDeviceFlag = TRUE;
 80a1a2e:	2301      	movs	r3, #1
 80a1a30:	74a3      	strb	r3, [r4, #18]
    if (!search_result || !ROM_NO[0]){
 80a1a32:	7a23      	ldrb	r3, [r4, #8]
 80a1a34:	2b00      	cmp	r3, #0
 80a1a36:	d0c8      	beq.n	80a19ca <_ZN7OneWire6searchEPh+0xc>
            search_result = TRUE;
 80a1a38:	2001      	movs	r0, #1
 80a1a3a:	e7c9      	b.n	80a19d0 <_ZN7OneWire6searchEPh+0x12>
                if (id_bit != cmp_id_bit){
 80a1a3c:	4581      	cmp	r9, r0
 80a1a3e:	eb04 0305 	add.w	r3, r4, r5
 80a1a42:	d122      	bne.n	80a1a8a <_ZN7OneWire6searchEPh+0xcc>
                    if (id_bit_number < LastDiscrepancy)
 80a1a44:	7c22      	ldrb	r2, [r4, #16]
 80a1a46:	42b2      	cmp	r2, r6
 80a1a48:	d918      	bls.n	80a1a7c <_ZN7OneWire6searchEPh+0xbe>
                        search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
 80a1a4a:	7a1a      	ldrb	r2, [r3, #8]
                    if (search_direction == 0){
 80a1a4c:	4217      	tst	r7, r2
 80a1a4e:	d016      	beq.n	80a1a7e <_ZN7OneWire6searchEPh+0xc0>
                  ROM_NO[rom_byte_number] |= rom_byte_mask;
 80a1a50:	f04f 0b01 	mov.w	fp, #1
 80a1a54:	1962      	adds	r2, r4, r5
 80a1a56:	7a13      	ldrb	r3, [r2, #8]
 80a1a58:	433b      	orrs	r3, r7
 80a1a5a:	7213      	strb	r3, [r2, #8]
                write_bit(search_direction);
 80a1a5c:	4659      	mov	r1, fp
 80a1a5e:	4620      	mov	r0, r4
                rom_byte_mask <<= 1;
 80a1a60:	007f      	lsls	r7, r7, #1
                write_bit(search_direction);
 80a1a62:	f7ff ff0b 	bl	80a187c <_ZN7OneWire9write_bitEh>
                id_bit_number++;
 80a1a66:	3601      	adds	r6, #1
                if (rom_byte_mask == 0)
 80a1a68:	f017 07ff 	ands.w	r7, r7, #255	; 0xff
                id_bit_number++;
 80a1a6c:	b2f6      	uxtb	r6, r6
                if (rom_byte_mask == 0)
 80a1a6e:	d1ca      	bne.n	80a1a06 <_ZN7OneWire6searchEPh+0x48>
                    rom_byte_number++;
 80a1a70:	3501      	adds	r5, #1
 80a1a72:	b2ed      	uxtb	r5, r5
        }while(rom_byte_number < 8);  // loop until through all ROM bytes 0-7
 80a1a74:	2d08      	cmp	r5, #8
 80a1a76:	d0d3      	beq.n	80a1a20 <_ZN7OneWire6searchEPh+0x62>
                    rom_byte_mask = 1;
 80a1a78:	2701      	movs	r7, #1
 80a1a7a:	e7c4      	b.n	80a1a06 <_ZN7OneWire6searchEPh+0x48>
                    if (search_direction == 0){
 80a1a7c:	d0e8      	beq.n	80a1a50 <_ZN7OneWire6searchEPh+0x92>
                        if (last_zero < 9)
 80a1a7e:	2e08      	cmp	r6, #8
 80a1a80:	d800      	bhi.n	80a1a84 <_ZN7OneWire6searchEPh+0xc6>
                            LastFamilyDiscrepancy = last_zero;
 80a1a82:	7466      	strb	r6, [r4, #17]
                if (search_direction == 1)
 80a1a84:	f04f 0b00 	mov.w	fp, #0
 80a1a88:	46b2      	mov	sl, r6
                  ROM_NO[rom_byte_number] &= ~rom_byte_mask;
 80a1a8a:	7a1a      	ldrb	r2, [r3, #8]
 80a1a8c:	ea22 0207 	bic.w	r2, r2, r7
 80a1a90:	721a      	strb	r2, [r3, #8]
 80a1a92:	e7e3      	b.n	80a1a5c <_ZN7OneWire6searchEPh+0x9e>

080a1a94 <_ZN7OneWire4crc8EPhh>:

//
// Compute a Dallas Semiconductor 8 bit CRC directly.
// this is much slower, but much smaller, than the lookup table.
//
uint8_t OneWire::crc8( uint8_t *addr, uint8_t len){
 80a1a94:	4603      	mov	r3, r0
    uint8_t crc = 0;
 80a1a96:	4401      	add	r1, r0
 80a1a98:	2000      	movs	r0, #0
uint8_t OneWire::crc8( uint8_t *addr, uint8_t len){
 80a1a9a:	b530      	push	{r4, r5, lr}

    while (len--) {
 80a1a9c:	428b      	cmp	r3, r1
 80a1a9e:	d015      	beq.n	80a1acc <_ZN7OneWire4crc8EPhh+0x38>
        uint8_t inbyte = *addr++;
 80a1aa0:	2208      	movs	r2, #8
 80a1aa2:	f813 4b01 	ldrb.w	r4, [r3], #1
        for (uint8_t i = 8; i; i--) {
            uint8_t mix = (crc ^ inbyte) & 0x01;
 80a1aa6:	ea80 0504 	eor.w	r5, r0, r4
            crc >>= 1;
            if (mix) crc ^= 0x8C;
 80a1aaa:	f015 0f01 	tst.w	r5, #1
 80a1aae:	ea4f 0050 	mov.w	r0, r0, lsr #1
 80a1ab2:	bf18      	it	ne
 80a1ab4:	f080 008c 	eorne.w	r0, r0, #140	; 0x8c
        for (uint8_t i = 8; i; i--) {
 80a1ab8:	f102 32ff 	add.w	r2, r2, #4294967295
            if (mix) crc ^= 0x8C;
 80a1abc:	bf18      	it	ne
 80a1abe:	b2c0      	uxtbne	r0, r0
        for (uint8_t i = 8; i; i--) {
 80a1ac0:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
                inbyte >>= 1;
 80a1ac4:	ea4f 0454 	mov.w	r4, r4, lsr #1
        for (uint8_t i = 8; i; i--) {
 80a1ac8:	d1ed      	bne.n	80a1aa6 <_ZN7OneWire4crc8EPhh+0x12>
 80a1aca:	e7e7      	b.n	80a1a9c <_ZN7OneWire4crc8EPhh+0x8>
        }
    }

    return crc;
}
 80a1acc:	bd30      	pop	{r4, r5, pc}

080a1ace <_ZN17DallasTemperature19defaultAlarmHandlerEPKh>:
}

// The default alarm handler
void DallasTemperature::defaultAlarmHandler(const uint8_t* deviceAddress)
{
}
 80a1ace:	4770      	bx	lr

080a1ad0 <_ZN17DallasTemperatureC1EP7OneWire>:
    : _AlarmHandler(&defaultAlarmHandler)
 80a1ad0:	4a03      	ldr	r2, [pc, #12]	; (80a1ae0 <_ZN17DallasTemperatureC1EP7OneWire+0x10>)
    _wire = _oneWire;
 80a1ad2:	6081      	str	r1, [r0, #8]
    : _AlarmHandler(&defaultAlarmHandler)
 80a1ad4:	6182      	str	r2, [r0, #24]
    parasite = false;
 80a1ad6:	4a03      	ldr	r2, [pc, #12]	; (80a1ae4 <_ZN17DallasTemperatureC1EP7OneWire+0x14>)
 80a1ad8:	6002      	str	r2, [r0, #0]
    devices = 0;
 80a1ada:	2200      	movs	r2, #0
 80a1adc:	7102      	strb	r2, [r0, #4]
}
 80a1ade:	4770      	bx	lr
 80a1ae0:	080a1acf 	.word	0x080a1acf
 80a1ae4:	01010900 	.word	0x01010900

080a1ae8 <_ZN17DallasTemperature12validAddressEPKh>:
{
 80a1ae8:	b510      	push	{r4, lr}
 80a1aea:	460c      	mov	r4, r1
    return (_wire->crc8((uint8_t*)deviceAddress, 7) == deviceAddress[7]);
 80a1aec:	2107      	movs	r1, #7
 80a1aee:	4620      	mov	r0, r4
 80a1af0:	f7ff ffd0 	bl	80a1a94 <_ZN7OneWire4crc8EPhh>
 80a1af4:	79e3      	ldrb	r3, [r4, #7]
}
 80a1af6:	1a1b      	subs	r3, r3, r0
 80a1af8:	4258      	negs	r0, r3
 80a1afa:	4158      	adcs	r0, r3
 80a1afc:	bd10      	pop	{r4, pc}

080a1afe <_ZN17DallasTemperature14readScratchPadEPKhPh>:
{
 80a1afe:	b570      	push	{r4, r5, r6, lr}
 80a1b00:	4604      	mov	r4, r0
 80a1b02:	460e      	mov	r6, r1
    _wire->reset();
 80a1b04:	6880      	ldr	r0, [r0, #8]
{
 80a1b06:	4615      	mov	r5, r2
    _wire->reset();
 80a1b08:	f7ff fe7c 	bl	80a1804 <_ZN7OneWire5resetEv>
    _wire->select(deviceAddress);
 80a1b0c:	4631      	mov	r1, r6
 80a1b0e:	68a0      	ldr	r0, [r4, #8]
 80a1b10:	f7ff ff39 	bl	80a1986 <_ZN7OneWire6selectEPKh>
    _wire->write(READSCRATCH);
 80a1b14:	2200      	movs	r2, #0
 80a1b16:	21be      	movs	r1, #190	; 0xbe
 80a1b18:	68a0      	ldr	r0, [r4, #8]
 80a1b1a:	f7ff ff02 	bl	80a1922 <_ZN7OneWire5writeEhh>
    scratchPad[TEMP_LSB] = _wire->read();
 80a1b1e:	68a0      	ldr	r0, [r4, #8]
 80a1b20:	f7ff ff21 	bl	80a1966 <_ZN7OneWire4readEv>
 80a1b24:	7028      	strb	r0, [r5, #0]
    scratchPad[TEMP_MSB] = _wire->read();
 80a1b26:	68a0      	ldr	r0, [r4, #8]
 80a1b28:	f7ff ff1d 	bl	80a1966 <_ZN7OneWire4readEv>
 80a1b2c:	7068      	strb	r0, [r5, #1]
    scratchPad[HIGH_ALARM_TEMP] = _wire->read();
 80a1b2e:	68a0      	ldr	r0, [r4, #8]
 80a1b30:	f7ff ff19 	bl	80a1966 <_ZN7OneWire4readEv>
 80a1b34:	70a8      	strb	r0, [r5, #2]
    scratchPad[LOW_ALARM_TEMP] = _wire->read();
 80a1b36:	68a0      	ldr	r0, [r4, #8]
 80a1b38:	f7ff ff15 	bl	80a1966 <_ZN7OneWire4readEv>
 80a1b3c:	70e8      	strb	r0, [r5, #3]
    scratchPad[CONFIGURATION] = _wire->read();
 80a1b3e:	68a0      	ldr	r0, [r4, #8]
 80a1b40:	f7ff ff11 	bl	80a1966 <_ZN7OneWire4readEv>
 80a1b44:	7128      	strb	r0, [r5, #4]
    scratchPad[INTERNAL_BYTE] = _wire->read();
 80a1b46:	68a0      	ldr	r0, [r4, #8]
 80a1b48:	f7ff ff0d 	bl	80a1966 <_ZN7OneWire4readEv>
 80a1b4c:	7168      	strb	r0, [r5, #5]
    scratchPad[COUNT_REMAIN] = _wire->read();
 80a1b4e:	68a0      	ldr	r0, [r4, #8]
 80a1b50:	f7ff ff09 	bl	80a1966 <_ZN7OneWire4readEv>
 80a1b54:	71a8      	strb	r0, [r5, #6]
    scratchPad[COUNT_PER_C] = _wire->read();
 80a1b56:	68a0      	ldr	r0, [r4, #8]
 80a1b58:	f7ff ff05 	bl	80a1966 <_ZN7OneWire4readEv>
 80a1b5c:	71e8      	strb	r0, [r5, #7]
    scratchPad[SCRATCHPAD_CRC] = _wire->read();
 80a1b5e:	68a0      	ldr	r0, [r4, #8]
 80a1b60:	f7ff ff01 	bl	80a1966 <_ZN7OneWire4readEv>
 80a1b64:	7228      	strb	r0, [r5, #8]
    _wire->reset();
 80a1b66:	68a0      	ldr	r0, [r4, #8]
}
 80a1b68:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    _wire->reset();
 80a1b6c:	f7ff be4a 	b.w	80a1804 <_ZN7OneWire5resetEv>

080a1b70 <_ZN17DallasTemperature11isConnectedEPKhPh>:
{
 80a1b70:	b510      	push	{r4, lr}
 80a1b72:	4614      	mov	r4, r2
    readScratchPad(deviceAddress, scratchPad);
 80a1b74:	f7ff ffc3 	bl	80a1afe <_ZN17DallasTemperature14readScratchPadEPKhPh>
    return (_wire->crc8(scratchPad, 8) == scratchPad[SCRATCHPAD_CRC]);
 80a1b78:	2108      	movs	r1, #8
 80a1b7a:	4620      	mov	r0, r4
 80a1b7c:	f7ff ff8a 	bl	80a1a94 <_ZN7OneWire4crc8EPhh>
 80a1b80:	7a23      	ldrb	r3, [r4, #8]
}
 80a1b82:	1a1b      	subs	r3, r3, r0
 80a1b84:	4258      	negs	r0, r3
 80a1b86:	4158      	adcs	r0, r3
 80a1b88:	bd10      	pop	{r4, pc}

080a1b8a <_ZN17DallasTemperature15writeScratchPadEPKhS1_>:
{
 80a1b8a:	b570      	push	{r4, r5, r6, lr}
 80a1b8c:	4604      	mov	r4, r0
 80a1b8e:	460d      	mov	r5, r1
 80a1b90:	4616      	mov	r6, r2
    _wire->reset();
 80a1b92:	6880      	ldr	r0, [r0, #8]
 80a1b94:	f7ff fe36 	bl	80a1804 <_ZN7OneWire5resetEv>
    _wire->select(deviceAddress);
 80a1b98:	4629      	mov	r1, r5
 80a1b9a:	68a0      	ldr	r0, [r4, #8]
 80a1b9c:	f7ff fef3 	bl	80a1986 <_ZN7OneWire6selectEPKh>
    _wire->write(WRITESCRATCH);
 80a1ba0:	2200      	movs	r2, #0
 80a1ba2:	214e      	movs	r1, #78	; 0x4e
 80a1ba4:	68a0      	ldr	r0, [r4, #8]
 80a1ba6:	f7ff febc 	bl	80a1922 <_ZN7OneWire5writeEhh>
    _wire->write(scratchPad[HIGH_ALARM_TEMP]); // high alarm temp
 80a1baa:	2200      	movs	r2, #0
 80a1bac:	78b1      	ldrb	r1, [r6, #2]
 80a1bae:	68a0      	ldr	r0, [r4, #8]
 80a1bb0:	f7ff feb7 	bl	80a1922 <_ZN7OneWire5writeEhh>
    _wire->write(scratchPad[LOW_ALARM_TEMP]); // low alarm temp
 80a1bb4:	2200      	movs	r2, #0
 80a1bb6:	78f1      	ldrb	r1, [r6, #3]
 80a1bb8:	68a0      	ldr	r0, [r4, #8]
 80a1bba:	f7ff feb2 	bl	80a1922 <_ZN7OneWire5writeEhh>
    if (deviceAddress[0] != DS18S20MODEL) _wire->write(scratchPad[CONFIGURATION]); // configuration
 80a1bbe:	782b      	ldrb	r3, [r5, #0]
 80a1bc0:	2b10      	cmp	r3, #16
 80a1bc2:	d004      	beq.n	80a1bce <_ZN17DallasTemperature15writeScratchPadEPKhS1_+0x44>
 80a1bc4:	2200      	movs	r2, #0
 80a1bc6:	7931      	ldrb	r1, [r6, #4]
 80a1bc8:	68a0      	ldr	r0, [r4, #8]
 80a1bca:	f7ff feaa 	bl	80a1922 <_ZN7OneWire5writeEhh>
    _wire->reset();
 80a1bce:	68a0      	ldr	r0, [r4, #8]
 80a1bd0:	f7ff fe18 	bl	80a1804 <_ZN7OneWire5resetEv>
    _wire->select(deviceAddress); //<--this line was missing
 80a1bd4:	4629      	mov	r1, r5
 80a1bd6:	68a0      	ldr	r0, [r4, #8]
 80a1bd8:	f7ff fed5 	bl	80a1986 <_ZN7OneWire6selectEPKh>
    _wire->write(COPYSCRATCH, parasite);
 80a1bdc:	2148      	movs	r1, #72	; 0x48
 80a1bde:	7822      	ldrb	r2, [r4, #0]
 80a1be0:	68a0      	ldr	r0, [r4, #8]
 80a1be2:	f7ff fe9e 	bl	80a1922 <_ZN7OneWire5writeEhh>
    if (parasite) delay(10); // 10ms delay
 80a1be6:	7823      	ldrb	r3, [r4, #0]
 80a1be8:	b113      	cbz	r3, 80a1bf0 <_ZN17DallasTemperature15writeScratchPadEPKhS1_+0x66>
 80a1bea:	200a      	movs	r0, #10
 80a1bec:	f001 fd4a 	bl	80a3684 <delay>
    _wire->reset();
 80a1bf0:	68a0      	ldr	r0, [r4, #8]
}
 80a1bf2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    _wire->reset();
 80a1bf6:	f7ff be05 	b.w	80a1804 <_ZN7OneWire5resetEv>

080a1bfa <_ZN17DallasTemperature15readPowerSupplyEPKh>:
{
 80a1bfa:	b538      	push	{r3, r4, r5, lr}
 80a1bfc:	4604      	mov	r4, r0
 80a1bfe:	460d      	mov	r5, r1
    _wire->reset();
 80a1c00:	6880      	ldr	r0, [r0, #8]
 80a1c02:	f7ff fdff 	bl	80a1804 <_ZN7OneWire5resetEv>
    _wire->select(deviceAddress);
 80a1c06:	4629      	mov	r1, r5
 80a1c08:	68a0      	ldr	r0, [r4, #8]
 80a1c0a:	f7ff febc 	bl	80a1986 <_ZN7OneWire6selectEPKh>
    _wire->write(READPOWERSUPPLY);
 80a1c0e:	2200      	movs	r2, #0
 80a1c10:	21b4      	movs	r1, #180	; 0xb4
 80a1c12:	68a0      	ldr	r0, [r4, #8]
 80a1c14:	f7ff fe85 	bl	80a1922 <_ZN7OneWire5writeEhh>
    if (_wire->read_bit() == 0) ret = true;
 80a1c18:	68a0      	ldr	r0, [r4, #8]
 80a1c1a:	f7ff fe64 	bl	80a18e6 <_ZN7OneWire8read_bitEv>
 80a1c1e:	4605      	mov	r5, r0
    _wire->reset();
 80a1c20:	68a0      	ldr	r0, [r4, #8]
 80a1c22:	f7ff fdef 	bl	80a1804 <_ZN7OneWire5resetEv>
}
 80a1c26:	fab5 f085 	clz	r0, r5
 80a1c2a:	0940      	lsrs	r0, r0, #5
 80a1c2c:	bd38      	pop	{r3, r4, r5, pc}

080a1c2e <_ZN17DallasTemperature13setResolutionEPKhh>:
{
 80a1c2e:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a1c30:	b085      	sub	sp, #20
 80a1c32:	4614      	mov	r4, r2
    if (isConnected(deviceAddress, scratchPad))
 80a1c34:	aa01      	add	r2, sp, #4
{
 80a1c36:	4607      	mov	r7, r0
 80a1c38:	460e      	mov	r6, r1
    if (isConnected(deviceAddress, scratchPad))
 80a1c3a:	f7ff ff99 	bl	80a1b70 <_ZN17DallasTemperature11isConnectedEPKhPh>
 80a1c3e:	4605      	mov	r5, r0
 80a1c40:	b190      	cbz	r0, 80a1c68 <_ZN17DallasTemperature13setResolutionEPKhh+0x3a>
        if (deviceAddress[0] != DS18S20MODEL)
 80a1c42:	7833      	ldrb	r3, [r6, #0]
 80a1c44:	2b10      	cmp	r3, #16
 80a1c46:	d00f      	beq.n	80a1c68 <_ZN17DallasTemperature13setResolutionEPKhh+0x3a>
            switch (newResolution)
 80a1c48:	2c0b      	cmp	r4, #11
 80a1c4a:	d010      	beq.n	80a1c6e <_ZN17DallasTemperature13setResolutionEPKhh+0x40>
 80a1c4c:	2c0c      	cmp	r4, #12
 80a1c4e:	d003      	beq.n	80a1c58 <_ZN17DallasTemperature13setResolutionEPKhh+0x2a>
 80a1c50:	2c0a      	cmp	r4, #10
 80a1c52:	d10e      	bne.n	80a1c72 <_ZN17DallasTemperature13setResolutionEPKhh+0x44>
                scratchPad[CONFIGURATION] = TEMP_10_BIT;
 80a1c54:	233f      	movs	r3, #63	; 0x3f
 80a1c56:	e000      	b.n	80a1c5a <_ZN17DallasTemperature13setResolutionEPKhh+0x2c>
                scratchPad[CONFIGURATION] = TEMP_12_BIT;
 80a1c58:	237f      	movs	r3, #127	; 0x7f
            writeScratchPad(deviceAddress, scratchPad);
 80a1c5a:	4631      	mov	r1, r6
 80a1c5c:	4638      	mov	r0, r7
 80a1c5e:	aa01      	add	r2, sp, #4
                scratchPad[CONFIGURATION] = TEMP_9_BIT;
 80a1c60:	f88d 3008 	strb.w	r3, [sp, #8]
            writeScratchPad(deviceAddress, scratchPad);
 80a1c64:	f7ff ff91 	bl	80a1b8a <_ZN17DallasTemperature15writeScratchPadEPKhS1_>
}
 80a1c68:	4628      	mov	r0, r5
 80a1c6a:	b005      	add	sp, #20
 80a1c6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                scratchPad[CONFIGURATION] = TEMP_11_BIT;
 80a1c6e:	235f      	movs	r3, #95	; 0x5f
 80a1c70:	e7f3      	b.n	80a1c5a <_ZN17DallasTemperature13setResolutionEPKhh+0x2c>
                scratchPad[CONFIGURATION] = TEMP_9_BIT;
 80a1c72:	231f      	movs	r3, #31
 80a1c74:	e7f1      	b.n	80a1c5a <_ZN17DallasTemperature13setResolutionEPKhh+0x2c>

080a1c76 <_ZN17DallasTemperature13getResolutionEPKh>:
{
 80a1c76:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (deviceAddress[0] == DS18S20MODEL) return 12;
 80a1c78:	780b      	ldrb	r3, [r1, #0]
 80a1c7a:	2b10      	cmp	r3, #16
 80a1c7c:	d016      	beq.n	80a1cac <_ZN17DallasTemperature13getResolutionEPKh+0x36>
    if (isConnected(deviceAddress, scratchPad))
 80a1c7e:	aa01      	add	r2, sp, #4
 80a1c80:	f7ff ff76 	bl	80a1b70 <_ZN17DallasTemperature11isConnectedEPKhPh>
 80a1c84:	b150      	cbz	r0, 80a1c9c <_ZN17DallasTemperature13getResolutionEPKh+0x26>
        switch (scratchPad[CONFIGURATION])
 80a1c86:	f89d 3008 	ldrb.w	r3, [sp, #8]
 80a1c8a:	2b5f      	cmp	r3, #95	; 0x5f
 80a1c8c:	d010      	beq.n	80a1cb0 <_ZN17DallasTemperature13getResolutionEPKh+0x3a>
 80a1c8e:	d808      	bhi.n	80a1ca2 <_ZN17DallasTemperature13getResolutionEPKh+0x2c>
 80a1c90:	2b1f      	cmp	r3, #31
 80a1c92:	d00f      	beq.n	80a1cb4 <_ZN17DallasTemperature13getResolutionEPKh+0x3e>
            return 10;
 80a1c94:	2b3f      	cmp	r3, #63	; 0x3f
 80a1c96:	bf14      	ite	ne
 80a1c98:	2000      	movne	r0, #0
 80a1c9a:	200a      	moveq	r0, #10
}
 80a1c9c:	b005      	add	sp, #20
 80a1c9e:	f85d fb04 	ldr.w	pc, [sp], #4
        switch (scratchPad[CONFIGURATION])
 80a1ca2:	2b7f      	cmp	r3, #127	; 0x7f
 80a1ca4:	bf14      	ite	ne
 80a1ca6:	2000      	movne	r0, #0
 80a1ca8:	200c      	moveq	r0, #12
 80a1caa:	e7f7      	b.n	80a1c9c <_ZN17DallasTemperature13getResolutionEPKh+0x26>
    if (deviceAddress[0] == DS18S20MODEL) return 12;
 80a1cac:	200c      	movs	r0, #12
 80a1cae:	e7f5      	b.n	80a1c9c <_ZN17DallasTemperature13getResolutionEPKh+0x26>
            return 11;
 80a1cb0:	200b      	movs	r0, #11
 80a1cb2:	e7f3      	b.n	80a1c9c <_ZN17DallasTemperature13getResolutionEPKh+0x26>
            return 9;
 80a1cb4:	2009      	movs	r0, #9
 80a1cb6:	e7f1      	b.n	80a1c9c <_ZN17DallasTemperature13getResolutionEPKh+0x26>

080a1cb8 <_ZN17DallasTemperature5beginEv>:
{
 80a1cb8:	b570      	push	{r4, r5, r6, lr}
 80a1cba:	4604      	mov	r4, r0
 80a1cbc:	b086      	sub	sp, #24
    _wire->reset_search();
 80a1cbe:	6880      	ldr	r0, [r0, #8]
 80a1cc0:	f7ff fe77 	bl	80a19b2 <_ZN7OneWire12reset_searchEv>
    devices = 0; // Reset the number of devices when we enumerate wire devices
 80a1cc4:	2300      	movs	r3, #0
            if (!parasite && readPowerSupply(deviceAddress)) parasite = true;
 80a1cc6:	2601      	movs	r6, #1
    devices = 0; // Reset the number of devices when we enumerate wire devices
 80a1cc8:	7123      	strb	r3, [r4, #4]
    while (_wire->search(deviceAddress))
 80a1cca:	68a0      	ldr	r0, [r4, #8]
 80a1ccc:	a901      	add	r1, sp, #4
 80a1cce:	f7ff fe76 	bl	80a19be <_ZN7OneWire6searchEPh>
 80a1cd2:	b1f8      	cbz	r0, 80a1d14 <_ZN17DallasTemperature5beginEv+0x5c>
        if (validAddress(deviceAddress))
 80a1cd4:	4620      	mov	r0, r4
 80a1cd6:	a901      	add	r1, sp, #4
 80a1cd8:	f7ff ff06 	bl	80a1ae8 <_ZN17DallasTemperature12validAddressEPKh>
 80a1cdc:	2800      	cmp	r0, #0
 80a1cde:	d0f4      	beq.n	80a1cca <_ZN17DallasTemperature5beginEv+0x12>
            if (!parasite && readPowerSupply(deviceAddress)) parasite = true;
 80a1ce0:	7823      	ldrb	r3, [r4, #0]
 80a1ce2:	b92b      	cbnz	r3, 80a1cf0 <_ZN17DallasTemperature5beginEv+0x38>
 80a1ce4:	4620      	mov	r0, r4
 80a1ce6:	a901      	add	r1, sp, #4
 80a1ce8:	f7ff ff87 	bl	80a1bfa <_ZN17DallasTemperature15readPowerSupplyEPKh>
 80a1cec:	b100      	cbz	r0, 80a1cf0 <_ZN17DallasTemperature5beginEv+0x38>
 80a1cee:	7026      	strb	r6, [r4, #0]
            readScratchPad(deviceAddress, scratchPad);
 80a1cf0:	4620      	mov	r0, r4
 80a1cf2:	aa03      	add	r2, sp, #12
 80a1cf4:	a901      	add	r1, sp, #4
 80a1cf6:	f7ff ff02 	bl	80a1afe <_ZN17DallasTemperature14readScratchPadEPKhPh>
            bitResolution = max(bitResolution, getResolution(deviceAddress));
 80a1cfa:	4620      	mov	r0, r4
 80a1cfc:	a901      	add	r1, sp, #4
 80a1cfe:	7865      	ldrb	r5, [r4, #1]
 80a1d00:	f7ff ffb9 	bl	80a1c76 <_ZN17DallasTemperature13getResolutionEPKh>
 80a1d04:	4285      	cmp	r5, r0
 80a1d06:	bf38      	it	cc
 80a1d08:	4605      	movcc	r5, r0
            devices++;
 80a1d0a:	7923      	ldrb	r3, [r4, #4]
            bitResolution = max(bitResolution, getResolution(deviceAddress));
 80a1d0c:	7065      	strb	r5, [r4, #1]
            devices++;
 80a1d0e:	3301      	adds	r3, #1
 80a1d10:	7123      	strb	r3, [r4, #4]
 80a1d12:	e7da      	b.n	80a1cca <_ZN17DallasTemperature5beginEv+0x12>
}
 80a1d14:	b006      	add	sp, #24
 80a1d16:	bd70      	pop	{r4, r5, r6, pc}

080a1d18 <_ZN17DallasTemperature21isConversionAvailableEPKh>:
{
 80a1d18:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    readScratchPad(deviceAddress, scratchPad);
 80a1d1a:	aa01      	add	r2, sp, #4
 80a1d1c:	f7ff feef 	bl	80a1afe <_ZN17DallasTemperature14readScratchPadEPKhPh>
    return scratchPad[0];
 80a1d20:	f89d 0004 	ldrb.w	r0, [sp, #4]
}
 80a1d24:	3800      	subs	r0, #0
 80a1d26:	bf18      	it	ne
 80a1d28:	2001      	movne	r0, #1
 80a1d2a:	b005      	add	sp, #20
 80a1d2c:	f85d fb04 	ldr.w	pc, [sp], #4

080a1d30 <_ZN17DallasTemperature25millisToWaitForConversionEh>:
    switch (bitResolution)
 80a1d30:	3909      	subs	r1, #9
 80a1d32:	b2c9      	uxtb	r1, r1
 80a1d34:	2902      	cmp	r1, #2
 80a1d36:	bf9a      	itte	ls
 80a1d38:	4b02      	ldrls	r3, [pc, #8]	; (80a1d44 <_ZN17DallasTemperature25millisToWaitForConversionEh+0x14>)
 80a1d3a:	f933 0011 	ldrshls.w	r0, [r3, r1, lsl #1]
{
 80a1d3e:	f240 20ee 	movwhi	r0, #750	; 0x2ee
}
 80a1d42:	4770      	bx	lr
 80a1d44:	080a7260 	.word	0x080a7260

080a1d48 <_ZN17DallasTemperature27blockTillConversionCompleteEhPKh>:
{
 80a1d48:	b570      	push	{r4, r5, r6, lr}
 80a1d4a:	4604      	mov	r4, r0
    int delms = millisToWaitForConversion(bitResolution);
 80a1d4c:	f7ff fff0 	bl	80a1d30 <_ZN17DallasTemperature25millisToWaitForConversionEh>
{
 80a1d50:	4616      	mov	r6, r2
    int delms = millisToWaitForConversion(bitResolution);
 80a1d52:	4605      	mov	r5, r0
    if (deviceAddress != NULL && checkForConversion && !parasite)
 80a1d54:	b182      	cbz	r2, 80a1d78 <_ZN17DallasTemperature27blockTillConversionCompleteEhPKh+0x30>
 80a1d56:	78e3      	ldrb	r3, [r4, #3]
 80a1d58:	b173      	cbz	r3, 80a1d78 <_ZN17DallasTemperature27blockTillConversionCompleteEhPKh+0x30>
 80a1d5a:	7823      	ldrb	r3, [r4, #0]
 80a1d5c:	b963      	cbnz	r3, 80a1d78 <_ZN17DallasTemperature27blockTillConversionCompleteEhPKh+0x30>
inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a1d5e:	f000 ffc5 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
        unsigned long timend = millis() + delms;
 80a1d62:	4405      	add	r5, r0
        while(!isConversionAvailable(deviceAddress) && (millis() < timend));
 80a1d64:	4631      	mov	r1, r6
 80a1d66:	4620      	mov	r0, r4
 80a1d68:	f7ff ffd6 	bl	80a1d18 <_ZN17DallasTemperature21isConversionAvailableEPKh>
 80a1d6c:	b918      	cbnz	r0, 80a1d76 <_ZN17DallasTemperature27blockTillConversionCompleteEhPKh+0x2e>
 80a1d6e:	f000 ffbd 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
 80a1d72:	4285      	cmp	r5, r0
 80a1d74:	d8f6      	bhi.n	80a1d64 <_ZN17DallasTemperature27blockTillConversionCompleteEhPKh+0x1c>
}
 80a1d76:	bd70      	pop	{r4, r5, r6, pc}
        delay(delms);
 80a1d78:	4628      	mov	r0, r5
}
 80a1d7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        delay(delms);
 80a1d7e:	f001 bc81 	b.w	80a3684 <delay>

080a1d82 <_ZN17DallasTemperature19requestTemperaturesEv>:
{
 80a1d82:	b510      	push	{r4, lr}
 80a1d84:	4604      	mov	r4, r0
    _wire->reset();
 80a1d86:	6880      	ldr	r0, [r0, #8]
 80a1d88:	f7ff fd3c 	bl	80a1804 <_ZN7OneWire5resetEv>
    _wire->skip();
 80a1d8c:	68a0      	ldr	r0, [r4, #8]
 80a1d8e:	f7ff fe0c 	bl	80a19aa <_ZN7OneWire4skipEv>
    _wire->write(STARTCONVO, parasite);
 80a1d92:	2144      	movs	r1, #68	; 0x44
 80a1d94:	7822      	ldrb	r2, [r4, #0]
 80a1d96:	68a0      	ldr	r0, [r4, #8]
 80a1d98:	f7ff fdc3 	bl	80a1922 <_ZN7OneWire5writeEhh>
    if (!waitForConversion) return;
 80a1d9c:	78a3      	ldrb	r3, [r4, #2]
 80a1d9e:	b133      	cbz	r3, 80a1dae <_ZN17DallasTemperature19requestTemperaturesEv+0x2c>
    blockTillConversionComplete(bitResolution, NULL);
 80a1da0:	4620      	mov	r0, r4
 80a1da2:	7861      	ldrb	r1, [r4, #1]
 80a1da4:	2200      	movs	r2, #0
}
 80a1da6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    blockTillConversionComplete(bitResolution, NULL);
 80a1daa:	f7ff bfcd 	b.w	80a1d48 <_ZN17DallasTemperature27blockTillConversionCompleteEhPKh>
}
 80a1dae:	bd10      	pop	{r4, pc}

080a1db0 <_ZN17DallasTemperature20calculateTemperatureEPKhPh>:
        (((int16_t) scratchPad[TEMP_LSB]) << 3);
 80a1db0:	7810      	ldrb	r0, [r2, #0]
        (((int16_t) scratchPad[TEMP_MSB]) << 11) |
 80a1db2:	7853      	ldrb	r3, [r2, #1]
        (((int16_t) scratchPad[TEMP_LSB]) << 3);
 80a1db4:	00c0      	lsls	r0, r0, #3
    int16_t fpTemperature =
 80a1db6:	ea40 20c3 	orr.w	r0, r0, r3, lsl #11
    if (deviceAddress[0] == DS18S20MODEL)
 80a1dba:	780b      	ldrb	r3, [r1, #0]
    int16_t fpTemperature =
 80a1dbc:	b200      	sxth	r0, r0
    if (deviceAddress[0] == DS18S20MODEL)
 80a1dbe:	2b10      	cmp	r3, #16
 80a1dc0:	d10b      	bne.n	80a1dda <_ZN17DallasTemperature20calculateTemperatureEPKhPh+0x2a>
                ((scratchPad[COUNT_PER_C] - scratchPad[COUNT_REMAIN]) << 7) /
 80a1dc2:	79d1      	ldrb	r1, [r2, #7]
 80a1dc4:	7993      	ldrb	r3, [r2, #6]
        fpTemperature = ((fpTemperature & 0xfff0) << 3) - 16 +
 80a1dc6:	00c0      	lsls	r0, r0, #3
                ((scratchPad[COUNT_PER_C] - scratchPad[COUNT_REMAIN]) << 7) /
 80a1dc8:	1acb      	subs	r3, r1, r3
 80a1dca:	01db      	lsls	r3, r3, #7
 80a1dcc:	fb93 f3f1 	sdiv	r3, r3, r1
        fpTemperature = ((fpTemperature & 0xfff0) << 3) - 16 +
 80a1dd0:	f020 007f 	bic.w	r0, r0, #127	; 0x7f
 80a1dd4:	3b10      	subs	r3, #16
 80a1dd6:	4418      	add	r0, r3
 80a1dd8:	b200      	sxth	r0, r0
}
 80a1dda:	4770      	bx	lr

080a1ddc <_ZN17DallasTemperature7getTempEPKh>:
{
 80a1ddc:	b530      	push	{r4, r5, lr}
 80a1dde:	b085      	sub	sp, #20
    if (isConnected(deviceAddress, scratchPad)) return calculateTemperature(deviceAddress, scratchPad);
 80a1de0:	aa01      	add	r2, sp, #4
{
 80a1de2:	4604      	mov	r4, r0
 80a1de4:	460d      	mov	r5, r1
    if (isConnected(deviceAddress, scratchPad)) return calculateTemperature(deviceAddress, scratchPad);
 80a1de6:	f7ff fec3 	bl	80a1b70 <_ZN17DallasTemperature11isConnectedEPKhPh>
 80a1dea:	b130      	cbz	r0, 80a1dfa <_ZN17DallasTemperature7getTempEPKh+0x1e>
 80a1dec:	4629      	mov	r1, r5
 80a1dee:	4620      	mov	r0, r4
 80a1df0:	aa01      	add	r2, sp, #4
 80a1df2:	f7ff ffdd 	bl	80a1db0 <_ZN17DallasTemperature20calculateTemperatureEPKhPh>
}
 80a1df6:	b005      	add	sp, #20
 80a1df8:	bd30      	pop	{r4, r5, pc}
    return DEVICE_DISCONNECTED_RAW;
 80a1dfa:	4801      	ldr	r0, [pc, #4]	; (80a1e00 <_ZN17DallasTemperature7getTempEPKh+0x24>)
 80a1dfc:	e7fb      	b.n	80a1df6 <_ZN17DallasTemperature7getTempEPKh+0x1a>
 80a1dfe:	bf00      	nop
 80a1e00:	fffff810 	.word	0xfffff810

080a1e04 <_ZN17DallasTemperature12rawToCelsiusEs>:
}

// convert from raw to Celsius
float DallasTemperature::rawToCelsius(int16_t raw)
{
    if (raw <= DEVICE_DISCONNECTED_RAW)
 80a1e04:	f510 6ffe 	cmn.w	r0, #2032	; 0x7f0
{
 80a1e08:	b508      	push	{r3, lr}
    if (raw <= DEVICE_DISCONNECTED_RAW)
 80a1e0a:	dd06      	ble.n	80a1e1a <_ZN17DallasTemperature12rawToCelsiusEs+0x16>
        return DEVICE_DISCONNECTED_C;
    // C = RAW/128
    return (float)raw * 0.0078125;
 80a1e0c:	f004 fc54 	bl	80a66b8 <__aeabi_i2f>
 80a1e10:	f04f 5170 	mov.w	r1, #1006632960	; 0x3c000000
 80a1e14:	f004 fca4 	bl	80a6760 <__aeabi_fmul>
}
 80a1e18:	bd08      	pop	{r3, pc}
        return DEVICE_DISCONNECTED_C;
 80a1e1a:	4801      	ldr	r0, [pc, #4]	; (80a1e20 <_ZN17DallasTemperature12rawToCelsiusEs+0x1c>)
 80a1e1c:	e7fc      	b.n	80a1e18 <_ZN17DallasTemperature12rawToCelsiusEs+0x14>
 80a1e1e:	bf00      	nop
 80a1e20:	c2fe0000 	.word	0xc2fe0000

080a1e24 <_ZN17DallasTemperature8getTempCEPKh>:
{
 80a1e24:	b508      	push	{r3, lr}
    return rawToCelsius(getTemp(deviceAddress));
 80a1e26:	f7ff ffd9 	bl	80a1ddc <_ZN17DallasTemperature7getTempEPKh>
}
 80a1e2a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return rawToCelsius(getTemp(deviceAddress));
 80a1e2e:	f7ff bfe9 	b.w	80a1e04 <_ZN17DallasTemperature12rawToCelsiusEs>

080a1e32 <_ZN10CCS811Core12readRegisterEhPh>:
//    offset -- register to read
//    *outputPointer -- Pass &variable (address of) to save read data to
//
//****************************************************************************//
CCS811Core::status CCS811Core::readRegister(uint8_t offset, uint8_t* outputPointer)
{
 80a1e32:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1e34:	4606      	mov	r6, r0
 80a1e36:	4617      	mov	r7, r2
 80a1e38:	460c      	mov	r4, r1
	//Return value
	uint8_t result;
	uint8_t numBytes = 1;
	CCS811Core::status returnError = SENSOR_SUCCESS;
	Wire.beginTransmission(I2CAddress);
 80a1e3a:	f002 fbf7 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1e3e:	7831      	ldrb	r1, [r6, #0]
 80a1e40:	f002 fa28 	bl	80a4294 <_ZN7TwoWire17beginTransmissionEh>
	Wire.write(offset);
 80a1e44:	f002 fbf2 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1e48:	6803      	ldr	r3, [r0, #0]
 80a1e4a:	4621      	mov	r1, r4
 80a1e4c:	689b      	ldr	r3, [r3, #8]
 80a1e4e:	4798      	blx	r3
	if( Wire.endTransmission() != 0 )
 80a1e50:	f002 fbec 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1e54:	f002 fa29 	bl	80a42aa <_ZN7TwoWire15endTransmissionEv>
	{
		returnError = SENSOR_I2C_ERROR;
 80a1e58:	1e04      	subs	r4, r0, #0
 80a1e5a:	bf18      	it	ne
 80a1e5c:	2402      	movne	r4, #2
	}
	Wire.requestFrom(I2CAddress, numBytes);
 80a1e5e:	f002 fbe5 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1e62:	2201      	movs	r2, #1
 80a1e64:	7831      	ldrb	r1, [r6, #0]
{
 80a1e66:	2500      	movs	r5, #0
	Wire.requestFrom(I2CAddress, numBytes);
 80a1e68:	f002 fa11 	bl	80a428e <_ZN7TwoWire11requestFromEhj>
	while ( Wire.available() ) // slave may send less than requested
 80a1e6c:	f002 fbde 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1e70:	6803      	ldr	r3, [r0, #0]
 80a1e72:	691b      	ldr	r3, [r3, #16]
 80a1e74:	4798      	blx	r3
 80a1e76:	b130      	cbz	r0, 80a1e86 <_ZN10CCS811Core12readRegisterEhPh+0x54>
	{
		result = Wire.read(); // receive a byte as a proper uint8_t
 80a1e78:	f002 fbd8 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1e7c:	6803      	ldr	r3, [r0, #0]
 80a1e7e:	695b      	ldr	r3, [r3, #20]
 80a1e80:	4798      	blx	r3
 80a1e82:	b2c5      	uxtb	r5, r0
	while ( Wire.available() ) // slave may send less than requested
 80a1e84:	e7f2      	b.n	80a1e6c <_ZN10CCS811Core12readRegisterEhPh+0x3a>
	}
	*outputPointer = result;

	return returnError;
}
 80a1e86:	4620      	mov	r0, r4
	*outputPointer = result;
 80a1e88:	703d      	strb	r5, [r7, #0]
}
 80a1e8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1e8c <_ZN10CCS811Core9beginCoreEv>:
{
 80a1e8c:	b513      	push	{r0, r1, r4, lr}
 80a1e8e:	4604      	mov	r4, r0
	Wire.begin();
 80a1e90:	f002 fbcc 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1e94:	f002 f9cc 	bl	80a4230 <_ZN7TwoWire5beginEv>
	volatile uint8_t temp = 0;
 80a1e98:	2300      	movs	r3, #0
 80a1e9a:	f88d 3006 	strb.w	r3, [sp, #6]
 80a1e9e:	f242 7310 	movw	r3, #10000	; 0x2710
		temp++;
 80a1ea2:	f89d 2006 	ldrb.w	r2, [sp, #6]
	for( uint16_t i = 0; i < 10000; i++ )
 80a1ea6:	3b01      	subs	r3, #1
		temp++;
 80a1ea8:	3201      	adds	r2, #1
 80a1eaa:	b2d2      	uxtb	r2, r2
	for( uint16_t i = 0; i < 10000; i++ )
 80a1eac:	b29b      	uxth	r3, r3
		temp++;
 80a1eae:	f88d 2006 	strb.w	r2, [sp, #6]
	for( uint16_t i = 0; i < 10000; i++ )
 80a1eb2:	2b00      	cmp	r3, #0
 80a1eb4:	d1f5      	bne.n	80a1ea2 <_ZN10CCS811Core9beginCoreEv+0x16>
	while ( Wire.available() ) //Clear wire as a precaution
 80a1eb6:	f002 fbb9 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1eba:	6803      	ldr	r3, [r0, #0]
 80a1ebc:	691b      	ldr	r3, [r3, #16]
 80a1ebe:	4798      	blx	r3
 80a1ec0:	b128      	cbz	r0, 80a1ece <_ZN10CCS811Core9beginCoreEv+0x42>
		Wire.read();
 80a1ec2:	f002 fbb3 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1ec6:	6803      	ldr	r3, [r0, #0]
 80a1ec8:	695b      	ldr	r3, [r3, #20]
 80a1eca:	4798      	blx	r3
	while ( Wire.available() ) //Clear wire as a precaution
 80a1ecc:	e7f3      	b.n	80a1eb6 <_ZN10CCS811Core9beginCoreEv+0x2a>
	readCheck = 0;
 80a1ece:	f88d 0007 	strb.w	r0, [sp, #7]
	returnError = readRegister(CSS811_HW_ID, &readCheck);
 80a1ed2:	2120      	movs	r1, #32
 80a1ed4:	4620      	mov	r0, r4
 80a1ed6:	f10d 0207 	add.w	r2, sp, #7
 80a1eda:	f7ff ffaa 	bl	80a1e32 <_ZN10CCS811Core12readRegisterEhPh>
	if( returnError != SENSOR_SUCCESS ) return returnError;
 80a1ede:	b920      	cbnz	r0, 80a1eea <_ZN10CCS811Core9beginCoreEv+0x5e>
	if( readCheck != 0x81 )
 80a1ee0:	f89d 0007 	ldrb.w	r0, [sp, #7]
	returnError = readRegister(CSS811_HW_ID, &readCheck);
 80a1ee4:	3881      	subs	r0, #129	; 0x81
 80a1ee6:	bf18      	it	ne
 80a1ee8:	2001      	movne	r0, #1
}
 80a1eea:	b002      	add	sp, #8
 80a1eec:	bd10      	pop	{r4, pc}

080a1eee <_ZN10CCS811Core17multiReadRegisterEhPhh>:
//    two bytes long and 3 bytes are requested, this will over-write some
//    other memory!
//
//****************************************************************************//
CCS811Core::status CCS811Core::multiReadRegister(uint8_t offset, uint8_t *outputPointer, uint8_t length)
{
 80a1eee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1ef0:	4607      	mov	r7, r0
 80a1ef2:	4614      	mov	r4, r2
 80a1ef4:	460e      	mov	r6, r1
 80a1ef6:	461d      	mov	r5, r3

	//define pointer that will point to the external space
	uint8_t i = 0;
	uint8_t c = 0;
	//Set the address
	Wire.beginTransmission(I2CAddress);
 80a1ef8:	f002 fb98 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1efc:	7839      	ldrb	r1, [r7, #0]
 80a1efe:	f002 f9c9 	bl	80a4294 <_ZN7TwoWire17beginTransmissionEh>
	Wire.write(offset);
 80a1f02:	f002 fb93 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f06:	6803      	ldr	r3, [r0, #0]
 80a1f08:	4631      	mov	r1, r6
 80a1f0a:	689b      	ldr	r3, [r3, #8]
 80a1f0c:	4798      	blx	r3
	if( Wire.endTransmission() != 0 )
 80a1f0e:	f002 fb8d 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f12:	f002 f9ca 	bl	80a42aa <_ZN7TwoWire15endTransmissionEv>
 80a1f16:	4606      	mov	r6, r0
 80a1f18:	bb10      	cbnz	r0, 80a1f60 <_ZN10CCS811Core17multiReadRegisterEhPhh+0x72>
		returnError = SENSOR_I2C_ERROR;
	}
	else  //OK, all worked, keep going
	{
		// request 6 bytes from slave device
		Wire.requestFrom(I2CAddress, length);
 80a1f1a:	f002 fb87 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f1e:	462a      	mov	r2, r5
 80a1f20:	7839      	ldrb	r1, [r7, #0]
 80a1f22:	f002 f9b4 	bl	80a428e <_ZN7TwoWire11requestFromEhj>
 80a1f26:	4425      	add	r5, r4
		while ( (Wire.available()) && (i < length))  // slave may send less than requested
 80a1f28:	f002 fb80 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f2c:	6803      	ldr	r3, [r0, #0]
 80a1f2e:	691b      	ldr	r3, [r3, #16]
 80a1f30:	4798      	blx	r3
 80a1f32:	b148      	cbz	r0, 80a1f48 <_ZN10CCS811Core17multiReadRegisterEhPhh+0x5a>
 80a1f34:	42ac      	cmp	r4, r5
 80a1f36:	d007      	beq.n	80a1f48 <_ZN10CCS811Core17multiReadRegisterEhPhh+0x5a>
		{
			c = Wire.read(); // receive a byte as character
 80a1f38:	f002 fb78 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f3c:	6803      	ldr	r3, [r0, #0]
 80a1f3e:	695b      	ldr	r3, [r3, #20]
 80a1f40:	4798      	blx	r3
 80a1f42:	f804 0b01 	strb.w	r0, [r4], #1
		while ( (Wire.available()) && (i < length))  // slave may send less than requested
 80a1f46:	e7ef      	b.n	80a1f28 <_ZN10CCS811Core17multiReadRegisterEhPhh+0x3a>
			*outputPointer = c;
			outputPointer++;
			i++;
		}
		//dump extra
		while(Wire.available())
 80a1f48:	f002 fb70 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f4c:	6803      	ldr	r3, [r0, #0]
 80a1f4e:	691b      	ldr	r3, [r3, #16]
 80a1f50:	4798      	blx	r3
 80a1f52:	b130      	cbz	r0, 80a1f62 <_ZN10CCS811Core17multiReadRegisterEhPhh+0x74>
		{
			Wire.read();
 80a1f54:	f002 fb6a 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f58:	6803      	ldr	r3, [r0, #0]
 80a1f5a:	695b      	ldr	r3, [r3, #20]
 80a1f5c:	4798      	blx	r3
		while(Wire.available())
 80a1f5e:	e7f3      	b.n	80a1f48 <_ZN10CCS811Core17multiReadRegisterEhPhh+0x5a>
		returnError = SENSOR_I2C_ERROR;
 80a1f60:	2602      	movs	r6, #2
		}
	}


	return returnError;
}
 80a1f62:	4630      	mov	r0, r6
 80a1f64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1f66 <_ZN10CCS811Core13writeRegisterEhh>:
//  Parameters:
//    offset -- register to write
//    dataToWrite -- 8 bit data to write to register
//
//****************************************************************************//
CCS811Core::status CCS811Core::writeRegister(uint8_t offset, uint8_t dataToWrite) {
 80a1f66:	b570      	push	{r4, r5, r6, lr}
 80a1f68:	4606      	mov	r6, r0
 80a1f6a:	4614      	mov	r4, r2
 80a1f6c:	460d      	mov	r5, r1
	CCS811Core::status returnError = SENSOR_SUCCESS;
	
	Wire.beginTransmission(I2CAddress);
 80a1f6e:	f002 fb5d 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f72:	7831      	ldrb	r1, [r6, #0]
 80a1f74:	f002 f98e 	bl	80a4294 <_ZN7TwoWire17beginTransmissionEh>
	Wire.write(offset);
 80a1f78:	f002 fb58 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f7c:	6803      	ldr	r3, [r0, #0]
 80a1f7e:	4629      	mov	r1, r5
 80a1f80:	689b      	ldr	r3, [r3, #8]
 80a1f82:	4798      	blx	r3
	Wire.write(dataToWrite);
 80a1f84:	f002 fb52 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f88:	6803      	ldr	r3, [r0, #0]
 80a1f8a:	4621      	mov	r1, r4
 80a1f8c:	689b      	ldr	r3, [r3, #8]
 80a1f8e:	4798      	blx	r3
	if( Wire.endTransmission() != 0 )
 80a1f90:	f002 fb4c 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1f94:	f002 f989 	bl	80a42aa <_ZN7TwoWire15endTransmissionEv>
	{
		returnError = SENSOR_I2C_ERROR;
 80a1f98:	2800      	cmp	r0, #0
	}
	return returnError;
}
 80a1f9a:	bf18      	it	ne
 80a1f9c:	2002      	movne	r0, #2
 80a1f9e:	bd70      	pop	{r4, r5, r6, pc}

080a1fa0 <_ZN10CCS811Core18multiWriteRegisterEhPhh>:
//    two bytes long and 3 bytes are requested, this will over-write some
//    other memory!
//
//****************************************************************************//
CCS811Core::status CCS811Core::multiWriteRegister(uint8_t offset, uint8_t *inputPointer, uint8_t length)
{
 80a1fa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1fa2:	4607      	mov	r7, r0
 80a1fa4:	4614      	mov	r4, r2
 80a1fa6:	461d      	mov	r5, r3
 80a1fa8:	460e      	mov	r6, r1
	CCS811Core::status returnError = SENSOR_SUCCESS;
	//define pointer that will point to the external space
	uint8_t i = 0;
	//Set the address
	Wire.beginTransmission(I2CAddress);
 80a1faa:	f002 fb3f 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1fae:	7839      	ldrb	r1, [r7, #0]
 80a1fb0:	f002 f970 	bl	80a4294 <_ZN7TwoWire17beginTransmissionEh>
	Wire.write(offset);
 80a1fb4:	f002 fb3a 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1fb8:	6803      	ldr	r3, [r0, #0]
 80a1fba:	4631      	mov	r1, r6
 80a1fbc:	689b      	ldr	r3, [r3, #8]
 80a1fbe:	4798      	blx	r3
 80a1fc0:	4425      	add	r5, r4
	while ( i < length )  // send data bytes
 80a1fc2:	42ac      	cmp	r4, r5
 80a1fc4:	d007      	beq.n	80a1fd6 <_ZN10CCS811Core18multiWriteRegisterEhPhh+0x36>
	{
		Wire.write(*inputPointer); // receive a byte as character
 80a1fc6:	f002 fb31 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1fca:	6803      	ldr	r3, [r0, #0]
 80a1fcc:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a1fd0:	689b      	ldr	r3, [r3, #8]
 80a1fd2:	4798      	blx	r3
	while ( i < length )  // send data bytes
 80a1fd4:	e7f5      	b.n	80a1fc2 <_ZN10CCS811Core18multiWriteRegisterEhPhh+0x22>
		inputPointer++;
		i++;
	}
	if( Wire.endTransmission() != 0 )
 80a1fd6:	f002 fb29 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a1fda:	f002 f966 	bl	80a42aa <_ZN7TwoWire15endTransmissionEv>
	{
		returnError = SENSOR_I2C_ERROR;
 80a1fde:	2800      	cmp	r0, #0
	}
	return returnError;
}
 80a1fe0:	bf18      	it	ne
 80a1fe2:	2002      	movne	r0, #2
 80a1fe4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080a1fe8 <_ZN6CCS811C1Eh>:
//  Construct with same rules as the core ( uint8_t busType, uint8_t inputArg )
//
//****************************************************************************//
CCS811::CCS811( uint8_t inputArg ) : CCS811Core( inputArg )
{
	refResistance = 10000;
 80a1fe8:	4a04      	ldr	r2, [pc, #16]	; (80a1ffc <_ZN6CCS811C1Eh+0x14>)
	I2CAddress = inputArg;
 80a1fea:	7001      	strb	r1, [r0, #0]
	refResistance = 10000;
 80a1fec:	6042      	str	r2, [r0, #4]
	resistance = 0;
	temperature = 0;
	tVOC = 0;
 80a1fee:	2100      	movs	r1, #0
	resistance = 0;
 80a1ff0:	2200      	movs	r2, #0
CCS811::CCS811( uint8_t inputArg ) : CCS811Core( inputArg )
 80a1ff2:	e9c0 1103 	strd	r1, r1, [r0, #12]
	resistance = 0;
 80a1ff6:	6082      	str	r2, [r0, #8]
	temperature = 0;
 80a1ff8:	6142      	str	r2, [r0, #20]
	CO2 = 0;
}
 80a1ffa:	4770      	bx	lr
 80a1ffc:	461c4000 	.word	0x461c4000

080a2000 <_ZN6CCS81120readAlgorithmResultsEv>:
//and the CO2 value
//Returns nothing
CCS811Core::status CCS811::readAlgorithmResults( void )
{
	uint8_t data[4];
	CCS811Core::status returnError = multiReadRegister(CSS811_ALG_RESULT_DATA, data, 4);
 80a2000:	2304      	movs	r3, #4
{
 80a2002:	b513      	push	{r0, r1, r4, lr}
	CCS811Core::status returnError = multiReadRegister(CSS811_ALG_RESULT_DATA, data, 4);
 80a2004:	2102      	movs	r1, #2
 80a2006:	eb0d 0203 	add.w	r2, sp, r3
{
 80a200a:	4604      	mov	r4, r0
	CCS811Core::status returnError = multiReadRegister(CSS811_ALG_RESULT_DATA, data, 4);
 80a200c:	f7ff ff6f 	bl	80a1eee <_ZN10CCS811Core17multiReadRegisterEhPhh>
	if( returnError != SENSOR_SUCCESS ) return returnError;
 80a2010:	b938      	cbnz	r0, 80a2022 <_ZN6CCS81120readAlgorithmResultsEv+0x22>
	// Data ordered:
	// co2MSB, co2LSB, tvocMSB, tvocLSB

	CO2 = ((uint16_t)data[0] << 8) | data[1];
 80a2012:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 80a2016:	ba5b      	rev16	r3, r3
 80a2018:	81e3      	strh	r3, [r4, #14]
	tVOC = ((uint16_t)data[2] << 8) | data[3];
 80a201a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80a201e:	ba5b      	rev16	r3, r3
 80a2020:	81a3      	strh	r3, [r4, #12]
	return SENSOR_SUCCESS;
}
 80a2022:	b002      	add	sp, #8
 80a2024:	bd10      	pop	{r4, pc}

080a2026 <_ZN6CCS81119checkForStatusErrorEv>:

//Checks to see if error bit is set
bool CCS811::checkForStatusError( void )
{
 80a2026:	b507      	push	{r0, r1, r2, lr}
	uint8_t value;
	//return the status bit
	readRegister( CSS811_STATUS, &value );
 80a2028:	2100      	movs	r1, #0
 80a202a:	f10d 0207 	add.w	r2, sp, #7
 80a202e:	f7ff ff00 	bl	80a1e32 <_ZN10CCS811Core12readRegisterEhPh>
	return (value & 1 << 0);
 80a2032:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 80a2036:	f000 0001 	and.w	r0, r0, #1
 80a203a:	b003      	add	sp, #12
 80a203c:	f85d fb04 	ldr.w	pc, [sp], #4

080a2040 <_ZN6CCS81113dataAvailableEv>:

//Checks to see if DATA_READ flag is set in the status register
bool CCS811::dataAvailable( void )
{
 80a2040:	b507      	push	{r0, r1, r2, lr}
	uint8_t value;
	CCS811Core::status returnError = readRegister( CSS811_STATUS, &value );
 80a2042:	2100      	movs	r1, #0
 80a2044:	f10d 0207 	add.w	r2, sp, #7
 80a2048:	f7ff fef3 	bl	80a1e32 <_ZN10CCS811Core12readRegisterEhPh>
	if( returnError != SENSOR_SUCCESS )
 80a204c:	b930      	cbnz	r0, 80a205c <_ZN6CCS81113dataAvailableEv+0x1c>
	{
		return 0;
	}
	else
	{
		return (value & 1 << 3);
 80a204e:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80a2052:	f3c0 00c0 	ubfx	r0, r0, #3, #1
	}
}
 80a2056:	b003      	add	sp, #12
 80a2058:	f85d fb04 	ldr.w	pc, [sp], #4
		return 0;
 80a205c:	2000      	movs	r0, #0
 80a205e:	e7fa      	b.n	80a2056 <_ZN6CCS81113dataAvailableEv+0x16>

080a2060 <_ZN6CCS8118appValidEv>:

//Checks to see if APP_VALID flag is set in the status register
bool CCS811::appValid( void )
{
 80a2060:	b507      	push	{r0, r1, r2, lr}
	uint8_t value;
	CCS811Core::status returnError = readRegister( CSS811_STATUS, &value );
 80a2062:	2100      	movs	r1, #0
 80a2064:	f10d 0207 	add.w	r2, sp, #7
 80a2068:	f7ff fee3 	bl	80a1e32 <_ZN10CCS811Core12readRegisterEhPh>
	if( returnError != SENSOR_SUCCESS )
 80a206c:	b930      	cbnz	r0, 80a207c <_ZN6CCS8118appValidEv+0x1c>
	{
		return 0;
	}
	else
	{
		return (value & 1 << 4);
 80a206e:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80a2072:	f3c0 1000 	ubfx	r0, r0, #4, #1
	}
}
 80a2076:	b003      	add	sp, #12
 80a2078:	f85d fb04 	ldr.w	pc, [sp], #4
		return 0;
 80a207c:	2000      	movs	r0, #0
 80a207e:	e7fa      	b.n	80a2076 <_ZN6CCS8118appValidEv+0x16>

080a2080 <_ZN6CCS81116getErrorRegisterEv>:

uint8_t CCS811::getErrorRegister( void )
{
 80a2080:	b507      	push	{r0, r1, r2, lr}
	uint8_t value;
	
	CCS811Core::status returnError = readRegister( CSS811_ERROR_ID, &value );
 80a2082:	21e0      	movs	r1, #224	; 0xe0
 80a2084:	f10d 0207 	add.w	r2, sp, #7
 80a2088:	f7ff fed3 	bl	80a1e32 <_ZN10CCS811Core12readRegisterEhPh>
	if( returnError != SENSOR_SUCCESS )
 80a208c:	b920      	cbnz	r0, 80a2098 <_ZN6CCS81116getErrorRegisterEv+0x18>
	{
		return 0xFF;
	}
	else
	{
		return value;  //Send all errors in the event of communication error
 80a208e:	f89d 0007 	ldrb.w	r0, [sp, #7]
	}
}
 80a2092:	b003      	add	sp, #12
 80a2094:	f85d fb04 	ldr.w	pc, [sp], #4
		return 0xFF;
 80a2098:	20ff      	movs	r0, #255	; 0xff
 80a209a:	e7fa      	b.n	80a2092 <_ZN6CCS81116getErrorRegisterEv+0x12>

080a209c <_ZN6CCS81112setDriveModeEh>:
//Mode 1 = read every 1s
//Mode 2 = every 10s
//Mode 3 = every 60s
//Mode 4 = RAW mode
CCS811Core::status CCS811::setDriveMode( uint8_t mode )
{
 80a209c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a209e:	460c      	mov	r4, r1
	if (mode > 4) mode = 4; //sanitize input

	uint8_t value;
	CCS811Core::status returnError = readRegister( CSS811_MEAS_MODE, &value ); //Read what's currently there
 80a20a0:	f10d 0207 	add.w	r2, sp, #7
 80a20a4:	2101      	movs	r1, #1
{
 80a20a6:	4605      	mov	r5, r0
	CCS811Core::status returnError = readRegister( CSS811_MEAS_MODE, &value ); //Read what's currently there
 80a20a8:	f7ff fec3 	bl	80a1e32 <_ZN10CCS811Core12readRegisterEhPh>
	if( returnError != SENSOR_SUCCESS ) return returnError;
 80a20ac:	b978      	cbnz	r0, 80a20ce <_ZN6CCS81112setDriveModeEh+0x32>
	value &= ~(0b00000111 << 4); //Clear DRIVE_MODE bits
	value |= (mode << 4); //Mask in mode
 80a20ae:	2c04      	cmp	r4, #4
 80a20b0:	bf28      	it	cs
 80a20b2:	2404      	movcs	r4, #4
	value &= ~(0b00000111 << 4); //Clear DRIVE_MODE bits
 80a20b4:	f89d 2007 	ldrb.w	r2, [sp, #7]
	returnError = writeRegister(CSS811_MEAS_MODE, value);
 80a20b8:	2101      	movs	r1, #1
	value &= ~(0b00000111 << 4); //Clear DRIVE_MODE bits
 80a20ba:	f022 0270 	bic.w	r2, r2, #112	; 0x70
	value |= (mode << 4); //Mask in mode
 80a20be:	ea42 1204 	orr.w	r2, r2, r4, lsl #4
 80a20c2:	b2d2      	uxtb	r2, r2
	returnError = writeRegister(CSS811_MEAS_MODE, value);
 80a20c4:	4628      	mov	r0, r5
	value |= (mode << 4); //Mask in mode
 80a20c6:	f88d 2007 	strb.w	r2, [sp, #7]
	returnError = writeRegister(CSS811_MEAS_MODE, value);
 80a20ca:	f7ff ff4c 	bl	80a1f66 <_ZN10CCS811Core13writeRegisterEhh>
	return returnError;
}
 80a20ce:	b003      	add	sp, #12
 80a20d0:	bd30      	pop	{r4, r5, pc}
	...

080a20d4 <_ZN6CCS8115beginEv>:
{
 80a20d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t data[4] = {0x11,0xE5,0x72,0x8A}; //Reset key
 80a20d6:	4b1e      	ldr	r3, [pc, #120]	; (80a2150 <_ZN6CCS8115beginEv+0x7c>)
{
 80a20d8:	4604      	mov	r4, r0
	uint8_t data[4] = {0x11,0xE5,0x72,0x8A}; //Reset key
 80a20da:	9301      	str	r3, [sp, #4]
	returnError = beginCore();
 80a20dc:	f7ff fed6 	bl	80a1e8c <_ZN10CCS811Core9beginCoreEv>
 80a20e0:	4605      	mov	r5, r0
	if( returnError != SENSOR_SUCCESS ) return returnError;
 80a20e2:	b9b8      	cbnz	r0, 80a2114 <_ZN6CCS8115beginEv+0x40>
	multiWriteRegister(CSS811_SW_RESET, data, 4);
 80a20e4:	2304      	movs	r3, #4
 80a20e6:	21ff      	movs	r1, #255	; 0xff
 80a20e8:	eb0d 0203 	add.w	r2, sp, r3
 80a20ec:	4620      	mov	r0, r4
 80a20ee:	f7ff ff57 	bl	80a1fa0 <_ZN10CCS811Core18multiWriteRegisterEhPhh>
	volatile uint8_t temp = 0;
 80a20f2:	4a18      	ldr	r2, [pc, #96]	; (80a2154 <_ZN6CCS8115beginEv+0x80>)
 80a20f4:	f88d 5003 	strb.w	r5, [sp, #3]
		temp++;
 80a20f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
	for( uint32_t i = 0; i < 200000; i++ ) //Spin for a good while
 80a20fc:	3a01      	subs	r2, #1
		temp++;
 80a20fe:	f103 0301 	add.w	r3, r3, #1
 80a2102:	b2db      	uxtb	r3, r3
 80a2104:	f88d 3003 	strb.w	r3, [sp, #3]
	for( uint32_t i = 0; i < 200000; i++ ) //Spin for a good while
 80a2108:	d1f6      	bne.n	80a20f8 <_ZN6CCS8115beginEv+0x24>
	if( checkForStatusError() == true ) return SENSOR_INTERNAL_ERROR;
 80a210a:	4620      	mov	r0, r4
 80a210c:	f7ff ff8b 	bl	80a2026 <_ZN6CCS81119checkForStatusErrorEv>
 80a2110:	b110      	cbz	r0, 80a2118 <_ZN6CCS8115beginEv+0x44>
 80a2112:	2003      	movs	r0, #3
}
 80a2114:	b003      	add	sp, #12
 80a2116:	bd30      	pop	{r4, r5, pc}
	if( appValid() == false ) return SENSOR_INTERNAL_ERROR;
 80a2118:	4620      	mov	r0, r4
 80a211a:	f7ff ffa1 	bl	80a2060 <_ZN6CCS8118appValidEv>
 80a211e:	2800      	cmp	r0, #0
 80a2120:	d0f7      	beq.n	80a2112 <_ZN6CCS8115beginEv+0x3e>
	Wire.beginTransmission(I2CAddress);
 80a2122:	f002 fa83 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2126:	7821      	ldrb	r1, [r4, #0]
 80a2128:	f002 f8b4 	bl	80a4294 <_ZN7TwoWire17beginTransmissionEh>
	Wire.write(CSS811_APP_START);
 80a212c:	f002 fa7e 	bl	80a462c <_Z19__fetch_global_Wirev>
  bool unlock();

  inline size_t write(unsigned long n) { return write((uint8_t)n); }
  inline size_t write(long n) { return write((uint8_t)n); }
  inline size_t write(unsigned int n) { return write((uint8_t)n); }
  inline size_t write(int n) { return write((uint8_t)n); }
 80a2130:	6803      	ldr	r3, [r0, #0]
 80a2132:	21f4      	movs	r1, #244	; 0xf4
 80a2134:	689b      	ldr	r3, [r3, #8]
 80a2136:	4798      	blx	r3
	if( Wire.endTransmission() != 0 )
 80a2138:	f002 fa78 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a213c:	f002 f8b5 	bl	80a42aa <_ZN7TwoWire15endTransmissionEv>
 80a2140:	b920      	cbnz	r0, 80a214c <_ZN6CCS8115beginEv+0x78>
	returnError = setDriveMode(1); //Read every second
 80a2142:	2101      	movs	r1, #1
 80a2144:	4620      	mov	r0, r4
 80a2146:	f7ff ffa9 	bl	80a209c <_ZN6CCS81112setDriveModeEh>
	return returnError;
 80a214a:	e7e3      	b.n	80a2114 <_ZN6CCS8115beginEv+0x40>
		return SENSOR_I2C_ERROR;
 80a214c:	2002      	movs	r0, #2
 80a214e:	e7e1      	b.n	80a2114 <_ZN6CCS8115beginEv+0x40>
 80a2150:	8a72e511 	.word	0x8a72e511
 80a2154:	00030d40 	.word	0x00030d40

080a2158 <_ZN6CCS81120setEnvironmentalDataEff>:

//Given a temp and humidity, write this data to the CSS811 for better compensation
//This function expects the humidity and temp to come in as floats
CCS811Core::status CCS811::setEnvironmentalData( float relativeHumidity, float temperature )
{
 80a2158:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a215a:	4604      	mov	r4, r0
 80a215c:	460d      	mov	r5, r1
	//Check for invalid temperatures
	if((temperature < -25)||(temperature > 50)) return SENSOR_GENERIC_ERROR;
 80a215e:	4610      	mov	r0, r2
 80a2160:	4935      	ldr	r1, [pc, #212]	; (80a2238 <_ZN6CCS81120setEnvironmentalDataEff+0xe0>)
{
 80a2162:	4616      	mov	r6, r2
	if((temperature < -25)||(temperature > 50)) return SENSOR_GENERIC_ERROR;
 80a2164:	f004 fc9a 	bl	80a6a9c <__aeabi_fcmplt>
 80a2168:	2800      	cmp	r0, #0
 80a216a:	d163      	bne.n	80a2234 <_ZN6CCS81120setEnvironmentalDataEff+0xdc>
 80a216c:	4630      	mov	r0, r6
 80a216e:	4933      	ldr	r1, [pc, #204]	; (80a223c <_ZN6CCS81120setEnvironmentalDataEff+0xe4>)
 80a2170:	f004 fcb2 	bl	80a6ad8 <__aeabi_fcmpgt>
 80a2174:	2800      	cmp	r0, #0
 80a2176:	d15d      	bne.n	80a2234 <_ZN6CCS81120setEnvironmentalDataEff+0xdc>
	
	//Check for invalid humidity
	if((relativeHumidity < 0)||(relativeHumidity > 100)) return SENSOR_GENERIC_ERROR;
 80a2178:	2100      	movs	r1, #0
 80a217a:	4628      	mov	r0, r5
 80a217c:	f004 fc8e 	bl	80a6a9c <__aeabi_fcmplt>
 80a2180:	2800      	cmp	r0, #0
 80a2182:	d157      	bne.n	80a2234 <_ZN6CCS81120setEnvironmentalDataEff+0xdc>
 80a2184:	4628      	mov	r0, r5
 80a2186:	492e      	ldr	r1, [pc, #184]	; (80a2240 <_ZN6CCS81120setEnvironmentalDataEff+0xe8>)
 80a2188:	f004 fca6 	bl	80a6ad8 <__aeabi_fcmpgt>
 80a218c:	2800      	cmp	r0, #0
 80a218e:	d151      	bne.n	80a2234 <_ZN6CCS81120setEnvironmentalDataEff+0xdc>
	
	uint32_t rH = relativeHumidity * 1000; //42.348 becomes 42348
 80a2190:	492c      	ldr	r1, [pc, #176]	; (80a2244 <_ZN6CCS81120setEnvironmentalDataEff+0xec>)
 80a2192:	4628      	mov	r0, r5
 80a2194:	f004 fae4 	bl	80a6760 <__aeabi_fmul>
 80a2198:	f004 fcce 	bl	80a6b38 <__aeabi_f2uiz>
	uint32_t temp = temperature * 1000; //23.2 becomes 23200
 80a219c:	4929      	ldr	r1, [pc, #164]	; (80a2244 <_ZN6CCS81120setEnvironmentalDataEff+0xec>)
	uint32_t rH = relativeHumidity * 1000; //42.348 becomes 42348
 80a219e:	4605      	mov	r5, r0
	uint32_t temp = temperature * 1000; //23.2 becomes 23200
 80a21a0:	4630      	mov	r0, r6
 80a21a2:	f004 fadd 	bl	80a6760 <__aeabi_fmul>
 80a21a6:	f004 fcc7 	bl	80a6b38 <__aeabi_f2uiz>

	byte envData[4];

	//Split value into 7-bit integer and 9-bit fractional
	envData[0] = ((rH % 1000) / 100) > 7 ? (rH / 1000 + 1) << 1 : (rH / 1000) << 1;
 80a21aa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a21ae:	fbb5 f3f2 	udiv	r3, r5, r2
 80a21b2:	fb02 5513 	mls	r5, r2, r3, r5
	envData[1] = 0; //CCS811 only supports increments of 0.5 so bits 7-0 will always be zero
 80a21b6:	2200      	movs	r2, #0
 80a21b8:	f88d 2005 	strb.w	r2, [sp, #5]
		envData[0] |= 1; //Set 9th bit of fractional to indicate 0.5%
	}

	temp += 25000; //Add the 25C offset
	//Split value into 7-bit integer and 9-bit fractional
	envData[2] = ((temp % 1000) / 100) > 7 ? (temp / 1000 + 1) << 1 : (temp / 1000) << 1;
 80a21bc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
	envData[0] = ((rH % 1000) / 100) > 7 ? (rH / 1000 + 1) << 1 : (rH / 1000) << 1;
 80a21c0:	f5b5 7f48 	cmp.w	r5, #800	; 0x320
 80a21c4:	b2db      	uxtb	r3, r3
 80a21c6:	bf28      	it	cs
 80a21c8:	3301      	addcs	r3, #1
 80a21ca:	005b      	lsls	r3, r3, #1
	if (((rH % 1000) / 100) > 2 && (((rH % 1000) / 100) < 8))
 80a21cc:	f5a5 7596 	sub.w	r5, r5, #300	; 0x12c
	envData[0] = ((rH % 1000) / 100) > 7 ? (rH / 1000 + 1) << 1 : (rH / 1000) << 1;
 80a21d0:	b2db      	uxtb	r3, r3
	if (((rH % 1000) / 100) > 2 && (((rH % 1000) / 100) < 8))
 80a21d2:	f5b5 7ffa 	cmp.w	r5, #500	; 0x1f4
	temp += 25000; //Add the 25C offset
 80a21d6:	f500 40c3 	add.w	r0, r0, #24960	; 0x6180
	envData[0] = ((rH % 1000) / 100) > 7 ? (rH / 1000 + 1) << 1 : (rH / 1000) << 1;
 80a21da:	f88d 3004 	strb.w	r3, [sp, #4]
	temp += 25000; //Add the 25C offset
 80a21de:	f100 0028 	add.w	r0, r0, #40	; 0x28
		envData[0] |= 1; //Set 9th bit of fractional to indicate 0.5%
 80a21e2:	bf3c      	itt	cc
 80a21e4:	f043 0301 	orrcc.w	r3, r3, #1
 80a21e8:	f88d 3004 	strbcc.w	r3, [sp, #4]
	envData[2] = ((temp % 1000) / 100) > 7 ? (temp / 1000 + 1) << 1 : (temp / 1000) << 1;
 80a21ec:	fbb0 f3f2 	udiv	r3, r0, r2
 80a21f0:	fb02 0013 	mls	r0, r2, r3, r0
 80a21f4:	b2db      	uxtb	r3, r3
 80a21f6:	f5b0 7f48 	cmp.w	r0, #800	; 0x320
 80a21fa:	bf28      	it	cs
 80a21fc:	3301      	addcs	r3, #1
	envData[3] = 0;
	if (((temp % 1000) / 100) > 2 && (((temp % 1000) / 100) < 8))
 80a21fe:	f5a0 7096 	sub.w	r0, r0, #300	; 0x12c
	envData[2] = ((temp % 1000) / 100) > 7 ? (temp / 1000 + 1) << 1 : (temp / 1000) << 1;
 80a2202:	005b      	lsls	r3, r3, #1
 80a2204:	b2db      	uxtb	r3, r3
	if (((temp % 1000) / 100) > 2 && (((temp % 1000) / 100) < 8))
 80a2206:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
	envData[2] = ((temp % 1000) / 100) > 7 ? (temp / 1000 + 1) << 1 : (temp / 1000) << 1;
 80a220a:	f88d 3006 	strb.w	r3, [sp, #6]
	{
		envData[2] |= 1;  //Set 9th bit of fractional to indicate 0.5C
 80a220e:	bf38      	it	cc
 80a2210:	f043 0301 	orrcc.w	r3, r3, #1
	envData[3] = 0;
 80a2214:	f04f 0200 	mov.w	r2, #0
		envData[2] |= 1;  //Set 9th bit of fractional to indicate 0.5C
 80a2218:	bf38      	it	cc
 80a221a:	f88d 3006 	strbcc.w	r3, [sp, #6]
	}
	CCS811Core::status returnError = multiWriteRegister(CSS811_ENV_DATA, envData, 4);
 80a221e:	2304      	movs	r3, #4
	envData[3] = 0;
 80a2220:	f88d 2007 	strb.w	r2, [sp, #7]
	CCS811Core::status returnError = multiWriteRegister(CSS811_ENV_DATA, envData, 4);
 80a2224:	2105      	movs	r1, #5
 80a2226:	4620      	mov	r0, r4
 80a2228:	eb0d 0203 	add.w	r2, sp, r3
 80a222c:	f7ff feb8 	bl	80a1fa0 <_ZN10CCS811Core18multiWriteRegisterEhPhh>
	return returnError;
}
 80a2230:	b002      	add	sp, #8
 80a2232:	bd70      	pop	{r4, r5, r6, pc}
	if((temperature < -25)||(temperature > 50)) return SENSOR_GENERIC_ERROR;
 80a2234:	2004      	movs	r0, #4
 80a2236:	e7fb      	b.n	80a2230 <_ZN6CCS81120setEnvironmentalDataEff+0xd8>
 80a2238:	c1c80000 	.word	0xc1c80000
 80a223c:	42480000 	.word	0x42480000
 80a2240:	42c80000 	.word	0x42c80000
 80a2244:	447a0000 	.word	0x447a0000

080a2248 <_ZN6CCS8117readNTCEv>:
}

CCS811Core::status CCS811::readNTC( void )
{
	uint8_t data[4];
	CCS811Core::status returnError = multiReadRegister(CSS811_NTC, data, 4);
 80a2248:	2304      	movs	r3, #4
{
 80a224a:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80a224e:	4604      	mov	r4, r0
	CCS811Core::status returnError = multiReadRegister(CSS811_NTC, data, 4);
 80a2250:	eb0d 0203 	add.w	r2, sp, r3
 80a2254:	2106      	movs	r1, #6
 80a2256:	f7ff fe4a 	bl	80a1eee <_ZN10CCS811Core17multiReadRegisterEhPhh>
 80a225a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 80a225e:	4605      	mov	r5, r0

	vrefCounts = ((uint16_t)data[0] << 8) | data[1];
 80a2260:	ba5b      	rev16	r3, r3
 80a2262:	b29f      	uxth	r7, r3
 80a2264:	8223      	strh	r3, [r4, #16]
	//Serial.print("vrefCounts: ");
	//Serial.println(vrefCounts);
	ntcCounts = ((uint16_t)data[2] << 8) | data[3];
 80a2266:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80a226a:	ba5b      	rev16	r3, r3
 80a226c:	8263      	strh	r3, [r4, #18]
	//Serial.print("ntcCounts: ");
	//Serial.println(ntcCounts);
	//Serial.print("sum: ");
	//Serial.println(ntcCounts + vrefCounts);
	resistance = ((float)ntcCounts * refResistance / (float)vrefCounts);
 80a226e:	b298      	uxth	r0, r3
 80a2270:	f004 fa1e 	bl	80a66b0 <__aeabi_ui2f>
 80a2274:	6861      	ldr	r1, [r4, #4]
 80a2276:	f004 fa73 	bl	80a6760 <__aeabi_fmul>
 80a227a:	4606      	mov	r6, r0
 80a227c:	4638      	mov	r0, r7
 80a227e:	f004 fa17 	bl	80a66b0 <__aeabi_ui2f>
 80a2282:	4601      	mov	r1, r0
 80a2284:	4630      	mov	r0, r6
 80a2286:	f004 fb1f 	bl	80a68c8 <__aeabi_fdiv>
 80a228a:	60a0      	str	r0, [r4, #8]

	
	//Code from Milan Malesevic and Zoran Stupic, 2011,
	//Modified by Max Mayfield,
	temperature = log((long)resistance);
 80a228c:	f004 fc2e 	bl	80a6aec <__aeabi_f2iz>
  template<typename _Tp>
    inline _GLIBCXX_CONSTEXPR
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }
 80a2290:	f003 fda6 	bl	80a5de0 <__aeabi_i2d>
 80a2294:	f002 f9fe 	bl	80a4694 <log>
 80a2298:	f004 f904 	bl	80a64a4 <__aeabi_d2f>
	temperature = 1 / (0.001129148 + (0.000234125 * temperature) + (0.0000000876741 * temperature * temperature * temperature));
 80a229c:	f003 fdb2 	bl	80a5e04 <__aeabi_f2d>
 80a22a0:	a31d      	add	r3, pc, #116	; (adr r3, 80a2318 <_ZN6CCS8117readNTCEv+0xd0>)
 80a22a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a22a6:	4606      	mov	r6, r0
 80a22a8:	460f      	mov	r7, r1
 80a22aa:	f003 fe03 	bl	80a5eb4 <__aeabi_dmul>
 80a22ae:	4632      	mov	r2, r6
 80a22b0:	463b      	mov	r3, r7
 80a22b2:	f003 fdff 	bl	80a5eb4 <__aeabi_dmul>
 80a22b6:	4632      	mov	r2, r6
 80a22b8:	463b      	mov	r3, r7
 80a22ba:	f003 fdfb 	bl	80a5eb4 <__aeabi_dmul>
 80a22be:	a318      	add	r3, pc, #96	; (adr r3, 80a2320 <_ZN6CCS8117readNTCEv+0xd8>)
 80a22c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a22c4:	4680      	mov	r8, r0
 80a22c6:	4689      	mov	r9, r1
 80a22c8:	4630      	mov	r0, r6
 80a22ca:	4639      	mov	r1, r7
 80a22cc:	f003 fdf2 	bl	80a5eb4 <__aeabi_dmul>
 80a22d0:	a315      	add	r3, pc, #84	; (adr r3, 80a2328 <_ZN6CCS8117readNTCEv+0xe0>)
 80a22d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a22d6:	f003 fc37 	bl	80a5b48 <__adddf3>
 80a22da:	4602      	mov	r2, r0
 80a22dc:	460b      	mov	r3, r1
 80a22de:	4640      	mov	r0, r8
 80a22e0:	4649      	mov	r1, r9
 80a22e2:	f003 fc31 	bl	80a5b48 <__adddf3>
 80a22e6:	4602      	mov	r2, r0
 80a22e8:	460b      	mov	r3, r1
 80a22ea:	2000      	movs	r0, #0
 80a22ec:	4912      	ldr	r1, [pc, #72]	; (80a2338 <_ZN6CCS8117readNTCEv+0xf0>)
 80a22ee:	f003 ff0b 	bl	80a6108 <__aeabi_ddiv>
 80a22f2:	f004 f8d7 	bl	80a64a4 <__aeabi_d2f>
	temperature = temperature - 273.15;  // Convert Kelvin to Celsius
 80a22f6:	f003 fd85 	bl	80a5e04 <__aeabi_f2d>
 80a22fa:	a30d      	add	r3, pc, #52	; (adr r3, 80a2330 <_ZN6CCS8117readNTCEv+0xe8>)
 80a22fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2300:	f003 fc20 	bl	80a5b44 <__aeabi_dsub>
 80a2304:	f004 f8ce 	bl	80a64a4 <__aeabi_d2f>
 80a2308:	6160      	str	r0, [r4, #20]

	return returnError;
}
 80a230a:	4628      	mov	r0, r5
 80a230c:	b003      	add	sp, #12
 80a230e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a2312:	bf00      	nop
 80a2314:	f3af 8000 	nop.w
 80a2318:	14170d19 	.word	0x14170d19
 80a231c:	3e7788eb 	.word	0x3e7788eb
 80a2320:	6fb4c3c2 	.word	0x6fb4c3c2
 80a2324:	3f2eafee 	.word	0x3f2eafee
 80a2328:	6edeb890 	.word	0x6edeb890
 80a232c:	3f527ffd 	.word	0x3f527ffd
 80a2330:	66666666 	.word	0x66666666
 80a2334:	40711266 	.word	0x40711266
 80a2338:	3ff00000 	.word	0x3ff00000

080a233c <_ZN6CCS8117getTVOCEv>:

uint16_t CCS811::getTVOC( void )
{
	return tVOC;
}
 80a233c:	8980      	ldrh	r0, [r0, #12]
 80a233e:	4770      	bx	lr

080a2340 <_ZN6CCS8116getCO2Ev>:

uint16_t CCS811::getCO2( void )
{
	return CO2;
}
 80a2340:	89c0      	ldrh	r0, [r0, #14]
 80a2342:	4770      	bx	lr

080a2344 <_ZN6CCS81114getTemperatureEv>:
}

float CCS811::getTemperature( void )
{
	return temperature;
 80a2344:	6940      	ldr	r0, [r0, #20]
 80a2346:	4770      	bx	lr

080a2348 <_ZN7TwoWire5writeEi.isra.0>:
 80a2348:	6803      	ldr	r3, [r0, #0]
 80a234a:	b2c9      	uxtb	r1, r1
 80a234c:	689b      	ldr	r3, [r3, #8]
 80a234e:	4718      	bx	r3

080a2350 <_ZN7WeatherC1Ev>:
 */

 #include "SparkFun_Photon_Weather_Shield_Library.h"

 //Initialize
 Weather::Weather(){}
 80a2350:	4770      	bx	lr

080a2352 <_ZN7Weather7checkIDEv>:
	//Reset user resister
	writeReg(SOFT_RESET);
}

uint8_t Weather::checkID()
{
 80a2352:	b508      	push	{r3, lr}
	uint8_t ID_1;

 	// Check device ID
	Wire.beginTransmission(ADDRESS);
 80a2354:	f002 f96a 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2358:	2140      	movs	r1, #64	; 0x40
 80a235a:	f001 ff9f 	bl	80a429c <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(0xFC);
 80a235e:	f002 f965 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2362:	21fc      	movs	r1, #252	; 0xfc
 80a2364:	f7ff fff0 	bl	80a2348 <_ZN7TwoWire5writeEi.isra.0>
	Wire.write(0xC9);
 80a2368:	f002 f960 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a236c:	21c9      	movs	r1, #201	; 0xc9
 80a236e:	f7ff ffeb 	bl	80a2348 <_ZN7TwoWire5writeEi.isra.0>
	Wire.endTransmission();
 80a2372:	f002 f95b 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2376:	f001 ff98 	bl	80a42aa <_ZN7TwoWire15endTransmissionEv>

    Wire.requestFrom(ADDRESS,1);
 80a237a:	f002 f957 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a237e:	2201      	movs	r2, #1
 80a2380:	2140      	movs	r1, #64	; 0x40
 80a2382:	f001 ff84 	bl	80a428e <_ZN7TwoWire11requestFromEhj>

    ID_1 = Wire.read();
 80a2386:	f002 f951 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a238a:	6803      	ldr	r3, [r0, #0]
 80a238c:	695b      	ldr	r3, [r3, #20]
 80a238e:	4798      	blx	r3

    return(ID_1);
}
 80a2390:	b2c0      	uxtb	r0, r0
 80a2392:	bd08      	pop	{r3, pc}

080a2394 <_ZN7Weather14makeMeasurmentEh>:

uint16_t Weather::makeMeasurment(uint8_t command)
{
 80a2394:	b538      	push	{r3, r4, r5, lr}
	// It can be either temperature or relative humidity
	// TODO: implement checksum checking

	uint16_t nBytes = 3;
	// if we are only reading old temperature, read olny msb and lsb
	if (command == 0xE0) nBytes = 2;
 80a2396:	29e0      	cmp	r1, #224	; 0xe0
 80a2398:	bf14      	ite	ne
 80a239a:	2503      	movne	r5, #3
 80a239c:	2502      	moveq	r5, #2
{
 80a239e:	460c      	mov	r4, r1

	Wire.beginTransmission(ADDRESS);
 80a23a0:	f002 f944 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a23a4:	2140      	movs	r1, #64	; 0x40
 80a23a6:	f001 ff79 	bl	80a429c <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(command);
 80a23aa:	f002 f93f 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a23ae:	6803      	ldr	r3, [r0, #0]
 80a23b0:	4621      	mov	r1, r4
 80a23b2:	689b      	ldr	r3, [r3, #8]
 80a23b4:	4798      	blx	r3
	Wire.endTransmission();
 80a23b6:	f002 f939 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a23ba:	f001 ff76 	bl	80a42aa <_ZN7TwoWire15endTransmissionEv>
	// When not using clock stretching (*_NOHOLD commands) delay here
	// is needed to wait for the measurement.
	// According to datasheet the max. conversion time is ~22ms
	 delay(100);
 80a23be:	2064      	movs	r0, #100	; 0x64
 80a23c0:	f001 f960 	bl	80a3684 <delay>

	Wire.requestFrom(ADDRESS,nBytes);
 80a23c4:	f002 f932 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a23c8:	462a      	mov	r2, r5
 80a23ca:	2140      	movs	r1, #64	; 0x40
 80a23cc:	f001 ff5f 	bl	80a428e <_ZN7TwoWire11requestFromEhj>
 80a23d0:	2465      	movs	r4, #101	; 0x65
	//Wait for data
	int counter = 0;
	while (Wire.available() < nBytes){
 80a23d2:	f002 f92b 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a23d6:	6803      	ldr	r3, [r0, #0]
 80a23d8:	691b      	ldr	r3, [r3, #16]
 80a23da:	4798      	blx	r3
 80a23dc:	42a8      	cmp	r0, r5
 80a23de:	da06      	bge.n	80a23ee <_ZN7Weather14makeMeasurmentEh+0x5a>
	  delay(1);
 80a23e0:	2001      	movs	r0, #1
 80a23e2:	f001 f94f 	bl	80a3684 <delay>
	  counter ++;
	  if (counter >100){
 80a23e6:	3c01      	subs	r4, #1
 80a23e8:	d1f3      	bne.n	80a23d2 <_ZN7Weather14makeMeasurmentEh+0x3e>
	    // Timeout: Sensor did not return any data
	    return 100;
 80a23ea:	2064      	movs	r0, #100	; 0x64
 80a23ec:	e00f      	b.n	80a240e <_ZN7Weather14makeMeasurmentEh+0x7a>
	  }
	}

	unsigned int msb = Wire.read();
 80a23ee:	f002 f91d 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a23f2:	6803      	ldr	r3, [r0, #0]
 80a23f4:	695b      	ldr	r3, [r3, #20]
 80a23f6:	4798      	blx	r3
 80a23f8:	4604      	mov	r4, r0
	unsigned int lsb = Wire.read();
 80a23fa:	f002 f917 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a23fe:	6803      	ldr	r3, [r0, #0]
 80a2400:	695b      	ldr	r3, [r3, #20]
 80a2402:	4798      	blx	r3
	// Clear the last to bits of LSB to 00.
	// According to datasheet LSB of RH is always xxxxxx10
	lsb &= 0xFC;
 80a2404:	f000 00fc 	and.w	r0, r0, #252	; 0xfc
	unsigned int mesurment = msb << 8 | lsb;
 80a2408:	ea40 2004 	orr.w	r0, r0, r4, lsl #8

	return mesurment;
 80a240c:	b280      	uxth	r0, r0
}
 80a240e:	bd38      	pop	{r3, r4, r5, pc}

080a2410 <_ZN7Weather5getRHEv>:
{
 80a2410:	b508      	push	{r3, lr}
	uint16_t RH_Code = makeMeasurment(HUMD_MEASURE_NOHOLD);
 80a2412:	21f5      	movs	r1, #245	; 0xf5
 80a2414:	f7ff ffbe 	bl	80a2394 <_ZN7Weather14makeMeasurmentEh>
	float result = (125.0*RH_Code/65536)-6;
 80a2418:	f003 fce2 	bl	80a5de0 <__aeabi_i2d>
 80a241c:	2200      	movs	r2, #0
 80a241e:	4b07      	ldr	r3, [pc, #28]	; (80a243c <_ZN7Weather5getRHEv+0x2c>)
 80a2420:	f003 fd48 	bl	80a5eb4 <__aeabi_dmul>
 80a2424:	2200      	movs	r2, #0
 80a2426:	4b06      	ldr	r3, [pc, #24]	; (80a2440 <_ZN7Weather5getRHEv+0x30>)
 80a2428:	f003 fd44 	bl	80a5eb4 <__aeabi_dmul>
 80a242c:	2200      	movs	r2, #0
 80a242e:	4b05      	ldr	r3, [pc, #20]	; (80a2444 <_ZN7Weather5getRHEv+0x34>)
 80a2430:	f003 fb88 	bl	80a5b44 <__aeabi_dsub>
 80a2434:	f004 f836 	bl	80a64a4 <__aeabi_d2f>
}
 80a2438:	bd08      	pop	{r3, pc}
 80a243a:	bf00      	nop
 80a243c:	405f4000 	.word	0x405f4000
 80a2440:	3ef00000 	.word	0x3ef00000
 80a2444:	40180000 	.word	0x40180000

080a2448 <_ZN7Weather7getTempEv>:
{
 80a2448:	b508      	push	{r3, lr}
	uint16_t temp_Code = makeMeasurment(TEMP_MEASURE_NOHOLD);
 80a244a:	21f3      	movs	r1, #243	; 0xf3
 80a244c:	f7ff ffa2 	bl	80a2394 <_ZN7Weather14makeMeasurmentEh>
	float result = (175.25*temp_Code/65536)-46.85;
 80a2450:	f003 fcc6 	bl	80a5de0 <__aeabi_i2d>
 80a2454:	a308      	add	r3, pc, #32	; (adr r3, 80a2478 <_ZN7Weather7getTempEv+0x30>)
 80a2456:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a245a:	f003 fd2b 	bl	80a5eb4 <__aeabi_dmul>
 80a245e:	2200      	movs	r2, #0
 80a2460:	4b09      	ldr	r3, [pc, #36]	; (80a2488 <_ZN7Weather7getTempEv+0x40>)
 80a2462:	f003 fd27 	bl	80a5eb4 <__aeabi_dmul>
 80a2466:	a306      	add	r3, pc, #24	; (adr r3, 80a2480 <_ZN7Weather7getTempEv+0x38>)
 80a2468:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a246c:	f003 fb6a 	bl	80a5b44 <__aeabi_dsub>
 80a2470:	f004 f818 	bl	80a64a4 <__aeabi_d2f>
}
 80a2474:	bd08      	pop	{r3, pc}
 80a2476:	bf00      	nop
 80a2478:	00000000 	.word	0x00000000
 80a247c:	4065e800 	.word	0x4065e800
 80a2480:	cccccccd 	.word	0xcccccccd
 80a2484:	40476ccc 	.word	0x40476ccc
 80a2488:	3ef00000 	.word	0x3ef00000
 80a248c:	00000000 	.word	0x00000000

080a2490 <_ZN7Weather8getTempFEv>:
{
 80a2490:	b508      	push	{r3, lr}
  return((getTemp() * 1.8) + 32.0); // Convert celsius to fahrenheit
 80a2492:	f7ff ffd9 	bl	80a2448 <_ZN7Weather7getTempEv>
 80a2496:	f003 fcb5 	bl	80a5e04 <__aeabi_f2d>
 80a249a:	a307      	add	r3, pc, #28	; (adr r3, 80a24b8 <_ZN7Weather8getTempFEv+0x28>)
 80a249c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a24a0:	f003 fd08 	bl	80a5eb4 <__aeabi_dmul>
 80a24a4:	2200      	movs	r2, #0
 80a24a6:	4b06      	ldr	r3, [pc, #24]	; (80a24c0 <_ZN7Weather8getTempFEv+0x30>)
 80a24a8:	f003 fb4e 	bl	80a5b48 <__adddf3>
 80a24ac:	f003 fffa 	bl	80a64a4 <__aeabi_d2f>
}
 80a24b0:	bd08      	pop	{r3, pc}
 80a24b2:	bf00      	nop
 80a24b4:	f3af 8000 	nop.w
 80a24b8:	cccccccd 	.word	0xcccccccd
 80a24bc:	3ffccccc 	.word	0x3ffccccc
 80a24c0:	40400000 	.word	0x40400000

080a24c4 <_ZN7Weather8IIC_ReadEh>:
}


// These are the two I2C functions in this sketch.
byte Weather::IIC_Read(byte regAddr)
{
 80a24c4:	b510      	push	{r4, lr}
 80a24c6:	460c      	mov	r4, r1
  // This function reads one byte over IIC
  Wire.beginTransmission(MPL3115A2_ADDRESS);
 80a24c8:	f002 f8b0 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a24cc:	2160      	movs	r1, #96	; 0x60
 80a24ce:	f001 fee5 	bl	80a429c <_ZN7TwoWire17beginTransmissionEi>
  Wire.write(regAddr);  // Address of CTRL_REG1
 80a24d2:	f002 f8ab 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a24d6:	6803      	ldr	r3, [r0, #0]
 80a24d8:	4621      	mov	r1, r4
 80a24da:	689b      	ldr	r3, [r3, #8]
 80a24dc:	4798      	blx	r3
  Wire.endTransmission(false); // Send data to I2C dev with option for a repeated start. THIS IS NECESSARY and not supported before Arduino V1.0.1!
 80a24de:	f002 f8a5 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a24e2:	2100      	movs	r1, #0
 80a24e4:	f001 fedd 	bl	80a42a2 <_ZN7TwoWire15endTransmissionEh>
  Wire.requestFrom(MPL3115A2_ADDRESS, 1); // Request the data...
 80a24e8:	f002 f8a0 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a24ec:	2201      	movs	r2, #1
 80a24ee:	2160      	movs	r1, #96	; 0x60
 80a24f0:	f001 fecd 	bl	80a428e <_ZN7TwoWire11requestFromEhj>
  return Wire.read();
 80a24f4:	f002 f89a 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a24f8:	6803      	ldr	r3, [r0, #0]
 80a24fa:	695b      	ldr	r3, [r3, #20]
 80a24fc:	4798      	blx	r3
}
 80a24fe:	b2c0      	uxtb	r0, r0
 80a2500:	bd10      	pop	{r4, pc}
	...

080a2504 <_ZN7Weather5beginEv>:
{
 80a2504:	b538      	push	{r3, r4, r5, lr}
 80a2506:	4605      	mov	r5, r0
  Wire.begin();
 80a2508:	f002 f890 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a250c:	f001 fe90 	bl	80a4230 <_ZN7TwoWire5beginEv>
  uint8_t ID_Barro = IIC_Read(WHO_AM_I );
 80a2510:	210c      	movs	r1, #12
 80a2512:	4628      	mov	r0, r5
 80a2514:	f7ff ffd6 	bl	80a24c4 <_ZN7Weather8IIC_ReadEh>
 80a2518:	4604      	mov	r4, r0
  uint8_t ID_Temp_Hum = checkID();
 80a251a:	4628      	mov	r0, r5
 80a251c:	f7ff ff19 	bl	80a2352 <_ZN7Weather7checkIDEv>
  if(ID_Temp_Hum == 0x15)//Ping CheckID register
 80a2520:	2815      	cmp	r0, #21
 80a2522:	d018      	beq.n	80a2556 <_ZN7Weather5beginEv+0x52>
  else if(ID_Temp_Hum == 0x32)
 80a2524:	2832      	cmp	r0, #50	; 0x32
 80a2526:	d124      	bne.n	80a2572 <_ZN7Weather5beginEv+0x6e>
  if(x == 1 && y == 1)
 80a2528:	2cc4      	cmp	r4, #196	; 0xc4
 80a252a:	d003      	beq.n	80a2534 <_ZN7Weather5beginEv+0x30>
    Serial.println("MPL3115A2 NOT Found");
 80a252c:	f001 fd0a 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a2530:	4915      	ldr	r1, [pc, #84]	; (80a2588 <_ZN7Weather5beginEv+0x84>)
 80a2532:	e002      	b.n	80a253a <_ZN7Weather5beginEv+0x36>
    Serial.println("MPL3115A2 Found");
 80a2534:	f001 fd06 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a2538:	4914      	ldr	r1, [pc, #80]	; (80a258c <_ZN7Weather5beginEv+0x88>)
    Serial.println("MPL3115A2 NOT Found");
 80a253a:	f000 ff9c 	bl	80a3476 <_ZN5Print7printlnEPKc>
    Serial.println("HTU21D Found");
 80a253e:	f001 fd01 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a2542:	4913      	ldr	r1, [pc, #76]	; (80a2590 <_ZN7Weather5beginEv+0x8c>)
 80a2544:	e011      	b.n	80a256a <_ZN7Weather5beginEv+0x66>
    Serial.println("MPL3115A2 NOT Found");
 80a2546:	f001 fcfd 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a254a:	490f      	ldr	r1, [pc, #60]	; (80a2588 <_ZN7Weather5beginEv+0x84>)
 80a254c:	e008      	b.n	80a2560 <_ZN7Weather5beginEv+0x5c>
  	Serial.println("No Devices Detected");
 80a254e:	f001 fcf9 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a2552:	4910      	ldr	r1, [pc, #64]	; (80a2594 <_ZN7Weather5beginEv+0x90>)
 80a2554:	e009      	b.n	80a256a <_ZN7Weather5beginEv+0x66>
  if(x == 1 && y == 1)
 80a2556:	2cc4      	cmp	r4, #196	; 0xc4
 80a2558:	d1f5      	bne.n	80a2546 <_ZN7Weather5beginEv+0x42>
    Serial.println("MPL3115A2 Found");
 80a255a:	f001 fcf3 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a255e:	490b      	ldr	r1, [pc, #44]	; (80a258c <_ZN7Weather5beginEv+0x88>)
    Serial.println("MPL3115A2 NOT Found");
 80a2560:	f000 ff89 	bl	80a3476 <_ZN5Print7printlnEPKc>
    Serial.println("Si7021 Found");
 80a2564:	f001 fcee 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a2568:	490b      	ldr	r1, [pc, #44]	; (80a2598 <_ZN7Weather5beginEv+0x94>)
}
 80a256a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  	Serial.println("No Devices Detected");
 80a256e:	f000 bf82 	b.w	80a3476 <_ZN5Print7printlnEPKc>
  if(x == 1 && y == 1)
 80a2572:	2cc4      	cmp	r4, #196	; 0xc4
 80a2574:	d1eb      	bne.n	80a254e <_ZN7Weather5beginEv+0x4a>
    Serial.println("MPL3115A2 Found");
 80a2576:	f001 fce5 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a257a:	4904      	ldr	r1, [pc, #16]	; (80a258c <_ZN7Weather5beginEv+0x88>)
 80a257c:	f000 ff7b 	bl	80a3476 <_ZN5Print7printlnEPKc>
    Serial.println("No Temp/Humidity Device Detected");
 80a2580:	f001 fce0 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a2584:	4905      	ldr	r1, [pc, #20]	; (80a259c <_ZN7Weather5beginEv+0x98>)
 80a2586:	e7f0      	b.n	80a256a <_ZN7Weather5beginEv+0x66>
 80a2588:	080a7290 	.word	0x080a7290
 80a258c:	080a7266 	.word	0x080a7266
 80a2590:	080a7283 	.word	0x080a7283
 80a2594:	080a72c5 	.word	0x080a72c5
 80a2598:	080a7276 	.word	0x080a7276
 80a259c:	080a72a4 	.word	0x080a72a4

080a25a0 <_ZN7Weather9IIC_WriteEhh>:

void Weather::IIC_Write(byte regAddr, byte value)
{
 80a25a0:	b538      	push	{r3, r4, r5, lr}
 80a25a2:	4614      	mov	r4, r2
 80a25a4:	460d      	mov	r5, r1
  // This function writes one byte over IIC
  Wire.beginTransmission(MPL3115A2_ADDRESS);
 80a25a6:	f002 f841 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a25aa:	2160      	movs	r1, #96	; 0x60
 80a25ac:	f001 fe76 	bl	80a429c <_ZN7TwoWire17beginTransmissionEi>
  Wire.write(regAddr);
 80a25b0:	f002 f83c 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a25b4:	6803      	ldr	r3, [r0, #0]
 80a25b6:	4629      	mov	r1, r5
 80a25b8:	689b      	ldr	r3, [r3, #8]
 80a25ba:	4798      	blx	r3
  Wire.write(value);
 80a25bc:	f002 f836 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a25c0:	6803      	ldr	r3, [r0, #0]
 80a25c2:	4621      	mov	r1, r4
 80a25c4:	689b      	ldr	r3, [r3, #8]
 80a25c6:	4798      	blx	r3
  Wire.endTransmission(true);
 80a25c8:	f002 f830 	bl	80a462c <_Z19__fetch_global_Wirev>
}
 80a25cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  Wire.endTransmission(true);
 80a25d0:	2101      	movs	r1, #1
 80a25d2:	f001 be66 	b.w	80a42a2 <_ZN7TwoWire15endTransmissionEh>

080a25d6 <_ZN7Weather16setModeBarometerEv>:
{
 80a25d6:	b510      	push	{r4, lr}
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a25d8:	2126      	movs	r1, #38	; 0x26
{
 80a25da:	4604      	mov	r4, r0
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a25dc:	f7ff ff72 	bl	80a24c4 <_ZN7Weather8IIC_ReadEh>
  IIC_Write(CTRL_REG1, tempSetting);
 80a25e0:	2126      	movs	r1, #38	; 0x26
 80a25e2:	f000 027f 	and.w	r2, r0, #127	; 0x7f
 80a25e6:	4620      	mov	r0, r4
}
 80a25e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  IIC_Write(CTRL_REG1, tempSetting);
 80a25ec:	f7ff bfd8 	b.w	80a25a0 <_ZN7Weather9IIC_WriteEhh>

080a25f0 <_ZN7Weather17setOversampleRateEh>:
  if(sampleRate > 7) sampleRate = 7; //OS cannot be larger than 0b.0111
 80a25f0:	2907      	cmp	r1, #7
 80a25f2:	bf28      	it	cs
 80a25f4:	2107      	movcs	r1, #7
{
 80a25f6:	b538      	push	{r3, r4, r5, lr}
 80a25f8:	460d      	mov	r5, r1
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a25fa:	2126      	movs	r1, #38	; 0x26
{
 80a25fc:	4604      	mov	r4, r0
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a25fe:	f7ff ff61 	bl	80a24c4 <_ZN7Weather8IIC_ReadEh>
  tempSetting &= 0b11000111; //Clear out old OS bits
 80a2602:	f000 02c7 	and.w	r2, r0, #199	; 0xc7
  tempSetting |= sampleRate; //Mask in new OS bits
 80a2606:	ea42 02c5 	orr.w	r2, r2, r5, lsl #3
  IIC_Write(CTRL_REG1, tempSetting);
 80a260a:	4620      	mov	r0, r4
}
 80a260c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  IIC_Write(CTRL_REG1, tempSetting);
 80a2610:	2126      	movs	r1, #38	; 0x26
 80a2612:	b2d2      	uxtb	r2, r2
 80a2614:	f7ff bfc4 	b.w	80a25a0 <_ZN7Weather9IIC_WriteEhh>

080a2618 <_ZN7Weather16enableEventFlagsEv>:
  IIC_Write(PT_DATA_CFG, 0x07); // Enable all three pressure and temp event flags
 80a2618:	2207      	movs	r2, #7
 80a261a:	2113      	movs	r1, #19
 80a261c:	f7ff bfc0 	b.w	80a25a0 <_ZN7Weather9IIC_WriteEhh>

080a2620 <_ZN7Weather13toggleOneShotEv>:
{
 80a2620:	b510      	push	{r4, lr}
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a2622:	2126      	movs	r1, #38	; 0x26
{
 80a2624:	4604      	mov	r4, r0
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a2626:	f7ff ff4d 	bl	80a24c4 <_ZN7Weather8IIC_ReadEh>
  IIC_Write(CTRL_REG1, tempSetting);
 80a262a:	2126      	movs	r1, #38	; 0x26
 80a262c:	f000 02fd 	and.w	r2, r0, #253	; 0xfd
 80a2630:	4620      	mov	r0, r4
 80a2632:	f7ff ffb5 	bl	80a25a0 <_ZN7Weather9IIC_WriteEhh>
  tempSetting = IIC_Read(CTRL_REG1); //Read current settings to be safe
 80a2636:	2126      	movs	r1, #38	; 0x26
 80a2638:	4620      	mov	r0, r4
 80a263a:	f7ff ff43 	bl	80a24c4 <_ZN7Weather8IIC_ReadEh>
  tempSetting |= (1<<1); //Set OST bit
 80a263e:	f040 0202 	orr.w	r2, r0, #2
  IIC_Write(CTRL_REG1, tempSetting);
 80a2642:	2126      	movs	r1, #38	; 0x26
 80a2644:	4620      	mov	r0, r4
}
 80a2646:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  IIC_Write(CTRL_REG1, tempSetting);
 80a264a:	b2d2      	uxtb	r2, r2
 80a264c:	f7ff bfa8 	b.w	80a25a0 <_ZN7Weather9IIC_WriteEhh>

080a2650 <_ZN7Weather12readPressureEv>:
{
 80a2650:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a2654:	4680      	mov	r8, r0
	if(IIC_Read(STATUS) & (1<<2) == 0) toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a2656:	2100      	movs	r1, #0
 80a2658:	f7ff ff34 	bl	80a24c4 <_ZN7Weather8IIC_ReadEh>
	while(IIC_Read(STATUS) & (1<<2) == 0)
 80a265c:	2100      	movs	r1, #0
 80a265e:	4640      	mov	r0, r8
 80a2660:	f7ff ff30 	bl	80a24c4 <_ZN7Weather8IIC_ReadEh>
	Wire.beginTransmission(MPL3115A2_ADDRESS);
 80a2664:	f001 ffe2 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2668:	2160      	movs	r1, #96	; 0x60
 80a266a:	f001 fe17 	bl	80a429c <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(OUT_P_MSB);  // Address of data to get
 80a266e:	f001 ffdd 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2672:	2101      	movs	r1, #1
 80a2674:	f7ff fe68 	bl	80a2348 <_ZN7TwoWire5writeEi.isra.0>
	Wire.endTransmission(false); // Send data to I2C dev with option for a repeated start. THIS IS NECESSARY and not supported before Arduino V1.0.1!
 80a2678:	f001 ffd8 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a267c:	2100      	movs	r1, #0
 80a267e:	f001 fe10 	bl	80a42a2 <_ZN7TwoWire15endTransmissionEh>
	if (Wire.requestFrom(MPL3115A2_ADDRESS, 3) != 3) { // Request three bytes
 80a2682:	f001 ffd3 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2686:	2203      	movs	r2, #3
 80a2688:	2160      	movs	r1, #96	; 0x60
 80a268a:	f001 fe00 	bl	80a428e <_ZN7TwoWire11requestFromEhj>
 80a268e:	2803      	cmp	r0, #3
 80a2690:	d12e      	bne.n	80a26f0 <_ZN7Weather12readPressureEv+0xa0>
	msb = Wire.read();
 80a2692:	f001 ffcb 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2696:	6803      	ldr	r3, [r0, #0]
 80a2698:	695b      	ldr	r3, [r3, #20]
 80a269a:	4798      	blx	r3
 80a269c:	4604      	mov	r4, r0
	csb = Wire.read();
 80a269e:	f001 ffc5 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a26a2:	6803      	ldr	r3, [r0, #0]
	long pressure_whole = (long)msb<<16 | (long)csb<<8 | (long)lsb;
 80a26a4:	0424      	lsls	r4, r4, #16
	csb = Wire.read();
 80a26a6:	695b      	ldr	r3, [r3, #20]
 80a26a8:	4798      	blx	r3
 80a26aa:	4606      	mov	r6, r0
	lsb = Wire.read();
 80a26ac:	f001 ffbe 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a26b0:	6803      	ldr	r3, [r0, #0]
	long pressure_whole = (long)msb<<16 | (long)csb<<8 | (long)lsb;
 80a26b2:	0236      	lsls	r6, r6, #8
	lsb = Wire.read();
 80a26b4:	695b      	ldr	r3, [r3, #20]
 80a26b6:	4798      	blx	r3
 80a26b8:	4607      	mov	r7, r0
	long pressure_whole = (long)msb<<16 | (long)csb<<8 | (long)lsb;
 80a26ba:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
	toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a26be:	4640      	mov	r0, r8
	long pressure_whole = (long)msb<<16 | (long)csb<<8 | (long)lsb;
 80a26c0:	b2b6      	uxth	r6, r6
	toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a26c2:	f7ff ffad 	bl	80a2620 <_ZN7Weather13toggleOneShotEv>
	long pressure_whole = (long)msb<<16 | (long)csb<<8 | (long)lsb;
 80a26c6:	4334      	orrs	r4, r6
 80a26c8:	b2f8      	uxtb	r0, r7
 80a26ca:	4304      	orrs	r4, r0
	float pressure_decimal = (float)lsb/4.0; //Turn it into fraction
 80a26cc:	f3c0 1001 	ubfx	r0, r0, #4, #2
 80a26d0:	f003 ffee 	bl	80a66b0 <__aeabi_ui2f>
 80a26d4:	f04f 517a 	mov.w	r1, #1048576000	; 0x3e800000
 80a26d8:	f004 f842 	bl	80a6760 <__aeabi_fmul>
 80a26dc:	4605      	mov	r5, r0
	float pressure = (float)pressure_whole + pressure_decimal;
 80a26de:	09a0      	lsrs	r0, r4, #6
 80a26e0:	f003 ffea 	bl	80a66b8 <__aeabi_i2f>
 80a26e4:	4601      	mov	r1, r0
 80a26e6:	4628      	mov	r0, r5
 80a26e8:	f003 ff32 	bl	80a6550 <__addsf3>
}
 80a26ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -999;
 80a26f0:	4800      	ldr	r0, [pc, #0]	; (80a26f4 <_ZN7Weather12readPressureEv+0xa4>)
 80a26f2:	e7fb      	b.n	80a26ec <_ZN7Weather12readPressureEv+0x9c>
 80a26f4:	c479c000 	.word	0xc479c000

080a26f8 <_ZN7Weather12readBaroTempEv>:
{
 80a26f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if(IIC_Read(STATUS) & (1<<1) == 0) toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a26fa:	2100      	movs	r1, #0
{
 80a26fc:	4606      	mov	r6, r0
	if(IIC_Read(STATUS) & (1<<1) == 0) toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a26fe:	f240 2459 	movw	r4, #601	; 0x259
 80a2702:	f7ff fedf 	bl	80a24c4 <_ZN7Weather8IIC_ReadEh>
	while( (IIC_Read(STATUS) & (1<<1)) == 0)
 80a2706:	2100      	movs	r1, #0
 80a2708:	4630      	mov	r0, r6
 80a270a:	f7ff fedb 	bl	80a24c4 <_ZN7Weather8IIC_ReadEh>
 80a270e:	0782      	lsls	r2, r0, #30
 80a2710:	d407      	bmi.n	80a2722 <_ZN7Weather12readBaroTempEv+0x2a>
		if(++counter > 600) return(-999); //Error out after max of 512ms for a read
 80a2712:	3c01      	subs	r4, #1
 80a2714:	d101      	bne.n	80a271a <_ZN7Weather12readBaroTempEv+0x22>
 80a2716:	4829      	ldr	r0, [pc, #164]	; (80a27bc <_ZN7Weather12readBaroTempEv+0xc4>)
}
 80a2718:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		delay(1);
 80a271a:	2001      	movs	r0, #1
 80a271c:	f000 ffb2 	bl	80a3684 <delay>
	while( (IIC_Read(STATUS) & (1<<1)) == 0)
 80a2720:	e7f1      	b.n	80a2706 <_ZN7Weather12readBaroTempEv+0xe>
	Wire.beginTransmission(MPL3115A2_ADDRESS);
 80a2722:	f001 ff83 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2726:	2160      	movs	r1, #96	; 0x60
 80a2728:	f001 fdb8 	bl	80a429c <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(OUT_T_MSB);  // Address of data to get
 80a272c:	f001 ff7e 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2730:	2104      	movs	r1, #4
 80a2732:	f7ff fe09 	bl	80a2348 <_ZN7TwoWire5writeEi.isra.0>
	Wire.endTransmission(false); // Send data to I2C dev with option for a repeated start. THIS IS NECESSARY and not supported before Arduino V1.0.1!
 80a2736:	f001 ff79 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a273a:	2100      	movs	r1, #0
 80a273c:	f001 fdb1 	bl	80a42a2 <_ZN7TwoWire15endTransmissionEh>
	if (Wire.requestFrom(MPL3115A2_ADDRESS, 2) != 2) { // Request two bytes
 80a2740:	f001 ff74 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2744:	2202      	movs	r2, #2
 80a2746:	2160      	movs	r1, #96	; 0x60
 80a2748:	f001 fda1 	bl	80a428e <_ZN7TwoWire11requestFromEhj>
 80a274c:	2802      	cmp	r0, #2
 80a274e:	d1e2      	bne.n	80a2716 <_ZN7Weather12readBaroTempEv+0x1e>
	msb = Wire.read();
 80a2750:	f001 ff6c 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2754:	6803      	ldr	r3, [r0, #0]
 80a2756:	695b      	ldr	r3, [r3, #20]
 80a2758:	4798      	blx	r3
 80a275a:	b2c7      	uxtb	r7, r0
 80a275c:	4605      	mov	r5, r0
	lsb = Wire.read();
 80a275e:	f001 ff65 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2762:	6803      	ldr	r3, [r0, #0]
 80a2764:	695b      	ldr	r3, [r3, #20]
 80a2766:	4798      	blx	r3
 80a2768:	b2c4      	uxtb	r4, r0
	toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a276a:	4630      	mov	r0, r6
 80a276c:	f7ff ff58 	bl	80a2620 <_ZN7Weather13toggleOneShotEv>
	if(msb > 0x7F)
 80a2770:	062b      	lsls	r3, r5, #24
        foo = ~((msb << 8) + lsb) + 1;  //2’s complement
 80a2772:	bf41      	itttt	mi
 80a2774:	eb04 2407 	addmi.w	r4, r4, r7, lsl #8
 80a2778:	4264      	negmi	r4, r4
        msb = foo >> 8;
 80a277a:	f3c4 2707 	ubfxmi	r7, r4, #8, #8
        lsb = foo & 0x00F0;
 80a277e:	f004 04f0 	andmi.w	r4, r4, #240	; 0xf0
	float templsb = (lsb>>4)/16.0; //temp, fraction of a degree
 80a2782:	ea4f 1014 	mov.w	r0, r4, lsr #4
        negSign = true;
 80a2786:	bf4c      	ite	mi
 80a2788:	2601      	movmi	r6, #1
    bool negSign = false;
 80a278a:	2600      	movpl	r6, #0
	float templsb = (lsb>>4)/16.0; //temp, fraction of a degree
 80a278c:	f003 fb28 	bl	80a5de0 <__aeabi_i2d>
 80a2790:	2200      	movs	r2, #0
 80a2792:	4b0b      	ldr	r3, [pc, #44]	; (80a27c0 <_ZN7Weather12readBaroTempEv+0xc8>)
 80a2794:	f003 fb8e 	bl	80a5eb4 <__aeabi_dmul>
 80a2798:	f003 fe84 	bl	80a64a4 <__aeabi_d2f>
 80a279c:	4605      	mov	r5, r0
	float temperature = (float)(msb + templsb);
 80a279e:	4638      	mov	r0, r7
 80a27a0:	f003 ff8a 	bl	80a66b8 <__aeabi_i2f>
 80a27a4:	4601      	mov	r1, r0
 80a27a6:	4628      	mov	r0, r5
 80a27a8:	f003 fed2 	bl	80a6550 <__addsf3>
	if (negSign) temperature = 0 - temperature;
 80a27ac:	2e00      	cmp	r6, #0
 80a27ae:	d0b3      	beq.n	80a2718 <_ZN7Weather12readBaroTempEv+0x20>
 80a27b0:	4601      	mov	r1, r0
 80a27b2:	2000      	movs	r0, #0
 80a27b4:	f003 feca 	bl	80a654c <__aeabi_fsub>
 80a27b8:	e7ae      	b.n	80a2718 <_ZN7Weather12readBaroTempEv+0x20>
 80a27ba:	bf00      	nop
 80a27bc:	c479c000 	.word	0xc479c000
 80a27c0:	3fb00000 	.word	0x3fb00000

080a27c4 <_ZN7Weather13readBaroTempFEv>:
{
 80a27c4:	b508      	push	{r3, lr}
  return((readBaroTemp() * 9.0)/ 5.0 + 32.0); // Convert celsius to fahrenheit
 80a27c6:	f7ff ff97 	bl	80a26f8 <_ZN7Weather12readBaroTempEv>
 80a27ca:	f003 fb1b 	bl	80a5e04 <__aeabi_f2d>
 80a27ce:	2200      	movs	r2, #0
 80a27d0:	4b06      	ldr	r3, [pc, #24]	; (80a27ec <_ZN7Weather13readBaroTempFEv+0x28>)
 80a27d2:	f003 fb6f 	bl	80a5eb4 <__aeabi_dmul>
 80a27d6:	2200      	movs	r2, #0
 80a27d8:	4b05      	ldr	r3, [pc, #20]	; (80a27f0 <_ZN7Weather13readBaroTempFEv+0x2c>)
 80a27da:	f003 fc95 	bl	80a6108 <__aeabi_ddiv>
 80a27de:	2200      	movs	r2, #0
 80a27e0:	4b04      	ldr	r3, [pc, #16]	; (80a27f4 <_ZN7Weather13readBaroTempFEv+0x30>)
 80a27e2:	f003 f9b1 	bl	80a5b48 <__adddf3>
 80a27e6:	f003 fe5d 	bl	80a64a4 <__aeabi_d2f>
}
 80a27ea:	bd08      	pop	{r3, pc}
 80a27ec:	40220000 	.word	0x40220000
 80a27f0:	40140000 	.word	0x40140000
 80a27f4:	40400000 	.word	0x40400000

080a27f8 <_ZN7TwoWire5writeEi.isra.0>:
 80a27f8:	6803      	ldr	r3, [r0, #0]
 80a27fa:	b2c9      	uxtb	r1, r1
 80a27fc:	689b      	ldr	r3, [r3, #8]
 80a27fe:	4718      	bx	r3

080a2800 <_ZN8APDS9301C1Ev>:

APDS9301::APDS9301()
{
  // Don't do squat here. Normal constructor functions are deferred to
  //  .begin().
}
 80a2800:	4770      	bx	lr

080a2802 <_ZN8APDS930111getRegisterEh>:
  return luxVal;
  return 0;
}

uint8_t APDS9301::getRegister(uint8_t regAddress)
{
 80a2802:	b538      	push	{r3, r4, r5, lr}
 80a2804:	4604      	mov	r4, r0
 80a2806:	460d      	mov	r5, r1
  Wire.beginTransmission(address);
 80a2808:	f001 ff10 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a280c:	7821      	ldrb	r1, [r4, #0]
 80a280e:	f001 fd41 	bl	80a4294 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write(regAddress);
 80a2812:	f001 ff0b 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2816:	6803      	ldr	r3, [r0, #0]
 80a2818:	4629      	mov	r1, r5
 80a281a:	689b      	ldr	r3, [r3, #8]
 80a281c:	4798      	blx	r3
  Wire.endTransmission(false);
 80a281e:	f001 ff05 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2822:	2100      	movs	r1, #0
 80a2824:	f001 fd3d 	bl	80a42a2 <_ZN7TwoWire15endTransmissionEh>
  Wire.requestFrom(address, (uint8_t)1);
 80a2828:	f001 ff00 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a282c:	2201      	movs	r2, #1
 80a282e:	7821      	ldrb	r1, [r4, #0]
 80a2830:	f001 fd2d 	bl	80a428e <_ZN7TwoWire11requestFromEhj>
  return Wire.read();
 80a2834:	f001 fefa 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2838:	6803      	ldr	r3, [r0, #0]
 80a283a:	695b      	ldr	r3, [r3, #20]
 80a283c:	4798      	blx	r3
}
 80a283e:	b2c0      	uxtb	r0, r0
 80a2840:	bd38      	pop	{r3, r4, r5, pc}

080a2842 <_ZN8APDS93017getGainEv>:
  uint8_t regVal = getRegister(TIMING_REG);
 80a2842:	2181      	movs	r1, #129	; 0x81
{
 80a2844:	b508      	push	{r3, lr}
  uint8_t regVal = getRegister(TIMING_REG);
 80a2846:	f7ff ffdc 	bl	80a2802 <_ZN8APDS930111getRegisterEh>
}
 80a284a:	f3c0 1000 	ubfx	r0, r0, #4, #1
 80a284e:	bd08      	pop	{r3, pc}

080a2850 <_ZN8APDS930118getIntegrationTimeEv>:
  uint8_t regVal = getRegister(TIMING_REG);
 80a2850:	2181      	movs	r1, #129	; 0x81
{
 80a2852:	b508      	push	{r3, lr}
  uint8_t regVal = getRegister(TIMING_REG);
 80a2854:	f7ff ffd5 	bl	80a2802 <_ZN8APDS930111getRegisterEh>
  if (regVal == 0x00)       return INT_TIME_13_7_MS;
 80a2858:	f010 0003 	ands.w	r0, r0, #3
 80a285c:	d002      	beq.n	80a2864 <_ZN8APDS930118getIntegrationTimeEv+0x14>
  else                      return INT_TIME_402_MS;
 80a285e:	2801      	cmp	r0, #1
 80a2860:	bf18      	it	ne
 80a2862:	2002      	movne	r0, #2
}
 80a2864:	bd08      	pop	{r3, pc}

080a2866 <_ZN8APDS930115getTwoRegistersEh>:

uint16_t APDS9301::getTwoRegisters(uint8_t regAddress)
{
 80a2866:	b538      	push	{r3, r4, r5, lr}
 80a2868:	4604      	mov	r4, r0
 80a286a:	460d      	mov	r5, r1
  Wire.beginTransmission(address);
 80a286c:	f001 fede 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2870:	7821      	ldrb	r1, [r4, #0]
 80a2872:	f001 fd0f 	bl	80a4294 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write(0x20 | regAddress);
 80a2876:	f001 fed9 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a287a:	f045 0120 	orr.w	r1, r5, #32
 80a287e:	f7ff ffbb 	bl	80a27f8 <_ZN7TwoWire5writeEi.isra.0>
  Wire.endTransmission(false);
 80a2882:	f001 fed3 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2886:	2100      	movs	r1, #0
 80a2888:	f001 fd0b 	bl	80a42a2 <_ZN7TwoWire15endTransmissionEh>
  Wire.requestFrom(address, (uint8_t)2);
 80a288c:	f001 fece 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2890:	7821      	ldrb	r1, [r4, #0]
 80a2892:	2202      	movs	r2, #2
 80a2894:	f001 fcfb 	bl	80a428e <_ZN7TwoWire11requestFromEhj>
  uint16_t regVal = Wire.read();
 80a2898:	f001 fec8 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a289c:	6803      	ldr	r3, [r0, #0]
 80a289e:	695b      	ldr	r3, [r3, #20]
 80a28a0:	4798      	blx	r3
 80a28a2:	4604      	mov	r4, r0
  return regVal | (Wire.read()<<8);
 80a28a4:	f001 fec2 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a28a8:	6803      	ldr	r3, [r0, #0]
 80a28aa:	695b      	ldr	r3, [r3, #20]
 80a28ac:	4798      	blx	r3
 80a28ae:	ea44 2000 	orr.w	r0, r4, r0, lsl #8
}
 80a28b2:	b280      	uxth	r0, r0
 80a28b4:	bd38      	pop	{r3, r4, r5, pc}

080a28b6 <_ZN8APDS930112readCH0LevelEv>:
{
 80a28b6:	b508      	push	{r3, lr}
  return getTwoRegisters(DATA0LOW_REG);
 80a28b8:	218c      	movs	r1, #140	; 0x8c
 80a28ba:	f7ff ffd4 	bl	80a2866 <_ZN8APDS930115getTwoRegistersEh>
}
 80a28be:	bd08      	pop	{r3, pc}

080a28c0 <_ZN8APDS930112readCH1LevelEv>:
{
 80a28c0:	b508      	push	{r3, lr}
  return getTwoRegisters(DATA1LOW_REG);
 80a28c2:	218e      	movs	r1, #142	; 0x8e
 80a28c4:	f7ff ffcf 	bl	80a2866 <_ZN8APDS930115getTwoRegistersEh>
}
 80a28c8:	bd08      	pop	{r3, pc}
 80a28ca:	0000      	movs	r0, r0
 80a28cc:	0000      	movs	r0, r0
	...

080a28d0 <_ZN8APDS930112readLuxLevelEv>:
{
 80a28d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a28d4:	4606      	mov	r6, r0
  unsigned int ch1Int = readCH1Level();
 80a28d6:	f7ff fff3 	bl	80a28c0 <_ZN8APDS930112readCH1LevelEv>
 80a28da:	4605      	mov	r5, r0
  unsigned int ch0Int = readCH0Level();
 80a28dc:	4630      	mov	r0, r6
 80a28de:	f7ff ffea 	bl	80a28b6 <_ZN8APDS930112readCH0LevelEv>
 80a28e2:	4604      	mov	r4, r0
  float ch0 = (float)readCH0Level();
 80a28e4:	4630      	mov	r0, r6
 80a28e6:	f7ff ffe6 	bl	80a28b6 <_ZN8APDS930112readCH0LevelEv>
 80a28ea:	4680      	mov	r8, r0
  float ch1 = (float)readCH1Level();
 80a28ec:	4630      	mov	r0, r6
 80a28ee:	f7ff ffe7 	bl	80a28c0 <_ZN8APDS930112readCH1LevelEv>
 80a28f2:	4607      	mov	r7, r0
  switch (getIntegrationTime())
 80a28f4:	4630      	mov	r0, r6
 80a28f6:	f7ff ffab 	bl	80a2850 <_ZN8APDS930118getIntegrationTimeEv>
 80a28fa:	2801      	cmp	r0, #1
 80a28fc:	d00f      	beq.n	80a291e <_ZN8APDS930112readLuxLevelEv+0x4e>
 80a28fe:	2802      	cmp	r0, #2
 80a2900:	d010      	beq.n	80a2924 <_ZN8APDS930112readLuxLevelEv+0x54>
 80a2902:	b990      	cbnz	r0, 80a292a <_ZN8APDS930112readLuxLevelEv+0x5a>
    if ((ch1Int >= 5047) || (ch0Int >= 5047)) 
 80a2904:	f241 33b6 	movw	r3, #5046	; 0x13b6
    if ((ch1Int >= 65535) || (ch0Int >= 65535))
 80a2908:	429d      	cmp	r5, r3
 80a290a:	d801      	bhi.n	80a2910 <_ZN8APDS930112readLuxLevelEv+0x40>
    if ((ch1Int >= 5047) || (ch0Int >= 5047)) 
 80a290c:	429c      	cmp	r4, r3
 80a290e:	d90c      	bls.n	80a292a <_ZN8APDS930112readLuxLevelEv+0x5a>
      return 1.0/0.0;
 80a2910:	2100      	movs	r1, #0
 80a2912:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80a2916:	f003 ffd7 	bl	80a68c8 <__aeabi_fdiv>
}
 80a291a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((ch1Int >= 37177) || (ch0Int >= 37177)) 
 80a291e:	f249 1338 	movw	r3, #37176	; 0x9138
 80a2922:	e7f1      	b.n	80a2908 <_ZN8APDS930112readLuxLevelEv+0x38>
    if ((ch1Int >= 65535) || (ch0Int >= 65535))
 80a2924:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80a2928:	e7ee      	b.n	80a2908 <_ZN8APDS930112readLuxLevelEv+0x38>
  float ch0 = (float)readCH0Level();
 80a292a:	4640      	mov	r0, r8
 80a292c:	f003 fec0 	bl	80a66b0 <__aeabi_ui2f>
 80a2930:	4604      	mov	r4, r0
  float ch1 = (float)readCH1Level();
 80a2932:	4638      	mov	r0, r7
 80a2934:	f003 febc 	bl	80a66b0 <__aeabi_ui2f>
  float ratio = ch1/ch0;
 80a2938:	4621      	mov	r1, r4
  float ch1 = (float)readCH1Level();
 80a293a:	4605      	mov	r5, r0
  float ratio = ch1/ch0;
 80a293c:	f003 ffc4 	bl	80a68c8 <__aeabi_fdiv>
 80a2940:	4607      	mov	r7, r0
  switch (getIntegrationTime())
 80a2942:	4630      	mov	r0, r6
 80a2944:	f7ff ff84 	bl	80a2850 <_ZN8APDS930118getIntegrationTimeEv>
 80a2948:	2800      	cmp	r0, #0
 80a294a:	d047      	beq.n	80a29dc <_ZN8APDS930112readLuxLevelEv+0x10c>
 80a294c:	2801      	cmp	r0, #1
 80a294e:	d05c      	beq.n	80a2a0a <_ZN8APDS930112readLuxLevelEv+0x13a>
  if (getGain() == LOW_GAIN) 
 80a2950:	4630      	mov	r0, r6
 80a2952:	f7ff ff76 	bl	80a2842 <_ZN8APDS93017getGainEv>
 80a2956:	b958      	cbnz	r0, 80a2970 <_ZN8APDS930112readLuxLevelEv+0xa0>
    ch0 *= 16;
 80a2958:	f04f 4183 	mov.w	r1, #1098907648	; 0x41800000
 80a295c:	4620      	mov	r0, r4
 80a295e:	f003 feff 	bl	80a6760 <__aeabi_fmul>
    ch1 *= 16;
 80a2962:	f04f 4183 	mov.w	r1, #1098907648	; 0x41800000
    ch0 *= 16;
 80a2966:	4604      	mov	r4, r0
    ch1 *= 16;
 80a2968:	4628      	mov	r0, r5
 80a296a:	f003 fef9 	bl	80a6760 <__aeabi_fmul>
 80a296e:	4605      	mov	r5, r0
  if (ratio <= 0.5)
 80a2970:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80a2974:	4638      	mov	r0, r7
 80a2976:	f004 f89b 	bl	80a6ab0 <__aeabi_fcmple>
 80a297a:	2800      	cmp	r0, #0
 80a297c:	d057      	beq.n	80a2a2e <_ZN8APDS930112readLuxLevelEv+0x15e>
    luxVal = (0.0304 * ch0) - ((0.062 * ch0) * (pow((ch1/ch0), 1.4)));
 80a297e:	4620      	mov	r0, r4
 80a2980:	f003 fa40 	bl	80a5e04 <__aeabi_f2d>
 80a2984:	4606      	mov	r6, r0
 80a2986:	460f      	mov	r7, r1
 80a2988:	4628      	mov	r0, r5
 80a298a:	4621      	mov	r1, r4
 80a298c:	f003 ff9c 	bl	80a68c8 <__aeabi_fdiv>
    inline _GLIBCXX_CONSTEXPR
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
 80a2990:	f003 fa38 	bl	80a5e04 <__aeabi_f2d>
 80a2994:	a352      	add	r3, pc, #328	; (adr r3, 80a2ae0 <_ZN8APDS930112readLuxLevelEv+0x210>)
 80a2996:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a299a:	f001 feb5 	bl	80a4708 <pow>
 80a299e:	a352      	add	r3, pc, #328	; (adr r3, 80a2ae8 <_ZN8APDS930112readLuxLevelEv+0x218>)
 80a29a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a29a4:	4680      	mov	r8, r0
 80a29a6:	4689      	mov	r9, r1
 80a29a8:	4630      	mov	r0, r6
 80a29aa:	4639      	mov	r1, r7
 80a29ac:	f003 fa82 	bl	80a5eb4 <__aeabi_dmul>
 80a29b0:	a34f      	add	r3, pc, #316	; (adr r3, 80a2af0 <_ZN8APDS930112readLuxLevelEv+0x220>)
 80a29b2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a29b6:	4604      	mov	r4, r0
 80a29b8:	460d      	mov	r5, r1
 80a29ba:	4630      	mov	r0, r6
 80a29bc:	4639      	mov	r1, r7
 80a29be:	f003 fa79 	bl	80a5eb4 <__aeabi_dmul>
 80a29c2:	4642      	mov	r2, r8
 80a29c4:	464b      	mov	r3, r9
 80a29c6:	f003 fa75 	bl	80a5eb4 <__aeabi_dmul>
 80a29ca:	4602      	mov	r2, r0
 80a29cc:	460b      	mov	r3, r1
 80a29ce:	4620      	mov	r0, r4
 80a29d0:	4629      	mov	r1, r5
    luxVal = (0.00146 * ch0) - (0.00112*ch1);
 80a29d2:	f003 f8b7 	bl	80a5b44 <__aeabi_dsub>
 80a29d6:	f003 fd65 	bl	80a64a4 <__aeabi_d2f>
 80a29da:	e79e      	b.n	80a291a <_ZN8APDS930112readLuxLevelEv+0x4a>
    ch0 *= 1/0.034;
 80a29dc:	4620      	mov	r0, r4
 80a29de:	f003 fa11 	bl	80a5e04 <__aeabi_f2d>
 80a29e2:	a345      	add	r3, pc, #276	; (adr r3, 80a2af8 <_ZN8APDS930112readLuxLevelEv+0x228>)
 80a29e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a29e8:	f003 fa64 	bl	80a5eb4 <__aeabi_dmul>
 80a29ec:	f003 fd5a 	bl	80a64a4 <__aeabi_d2f>
 80a29f0:	4604      	mov	r4, r0
    ch1 *= 1/0.034;
 80a29f2:	4628      	mov	r0, r5
 80a29f4:	f003 fa06 	bl	80a5e04 <__aeabi_f2d>
 80a29f8:	a33f      	add	r3, pc, #252	; (adr r3, 80a2af8 <_ZN8APDS930112readLuxLevelEv+0x228>)
 80a29fa:	e9d3 2300 	ldrd	r2, r3, [r3]
    ch1 *= 1/0.252;
 80a29fe:	f003 fa59 	bl	80a5eb4 <__aeabi_dmul>
 80a2a02:	f003 fd4f 	bl	80a64a4 <__aeabi_d2f>
 80a2a06:	4605      	mov	r5, r0
    break;
 80a2a08:	e7a2      	b.n	80a2950 <_ZN8APDS930112readLuxLevelEv+0x80>
    ch0 *= 1/0.252;
 80a2a0a:	4620      	mov	r0, r4
 80a2a0c:	f003 f9fa 	bl	80a5e04 <__aeabi_f2d>
 80a2a10:	a33b      	add	r3, pc, #236	; (adr r3, 80a2b00 <_ZN8APDS930112readLuxLevelEv+0x230>)
 80a2a12:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2a16:	f003 fa4d 	bl	80a5eb4 <__aeabi_dmul>
 80a2a1a:	f003 fd43 	bl	80a64a4 <__aeabi_d2f>
 80a2a1e:	4604      	mov	r4, r0
    ch1 *= 1/0.252;
 80a2a20:	4628      	mov	r0, r5
 80a2a22:	f003 f9ef 	bl	80a5e04 <__aeabi_f2d>
 80a2a26:	a336      	add	r3, pc, #216	; (adr r3, 80a2b00 <_ZN8APDS930112readLuxLevelEv+0x230>)
 80a2a28:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2a2c:	e7e7      	b.n	80a29fe <_ZN8APDS930112readLuxLevelEv+0x12e>
  else if (ratio <= 0.61)
 80a2a2e:	4638      	mov	r0, r7
 80a2a30:	f003 f9e8 	bl	80a5e04 <__aeabi_f2d>
 80a2a34:	a334      	add	r3, pc, #208	; (adr r3, 80a2b08 <_ZN8APDS930112readLuxLevelEv+0x238>)
 80a2a36:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2a3a:	4606      	mov	r6, r0
 80a2a3c:	460f      	mov	r7, r1
 80a2a3e:	f003 fcb5 	bl	80a63ac <__aeabi_dcmple>
 80a2a42:	b1b0      	cbz	r0, 80a2a72 <_ZN8APDS930112readLuxLevelEv+0x1a2>
    luxVal = (0.0224 * ch0) - (0.031 * ch1);
 80a2a44:	4620      	mov	r0, r4
 80a2a46:	f003 f9dd 	bl	80a5e04 <__aeabi_f2d>
 80a2a4a:	a331      	add	r3, pc, #196	; (adr r3, 80a2b10 <_ZN8APDS930112readLuxLevelEv+0x240>)
 80a2a4c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2a50:	f003 fa30 	bl	80a5eb4 <__aeabi_dmul>
 80a2a54:	4606      	mov	r6, r0
 80a2a56:	4628      	mov	r0, r5
 80a2a58:	460f      	mov	r7, r1
 80a2a5a:	f003 f9d3 	bl	80a5e04 <__aeabi_f2d>
 80a2a5e:	a32e      	add	r3, pc, #184	; (adr r3, 80a2b18 <_ZN8APDS930112readLuxLevelEv+0x248>)
 80a2a60:	e9d3 2300 	ldrd	r2, r3, [r3]
    luxVal = (0.00146 * ch0) - (0.00112*ch1);
 80a2a64:	f003 fa26 	bl	80a5eb4 <__aeabi_dmul>
 80a2a68:	4602      	mov	r2, r0
 80a2a6a:	460b      	mov	r3, r1
 80a2a6c:	4630      	mov	r0, r6
 80a2a6e:	4639      	mov	r1, r7
 80a2a70:	e7af      	b.n	80a29d2 <_ZN8APDS930112readLuxLevelEv+0x102>
  else if (ratio <= 0.8)
 80a2a72:	4630      	mov	r0, r6
 80a2a74:	a32a      	add	r3, pc, #168	; (adr r3, 80a2b20 <_ZN8APDS930112readLuxLevelEv+0x250>)
 80a2a76:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2a7a:	4639      	mov	r1, r7
 80a2a7c:	f003 fc96 	bl	80a63ac <__aeabi_dcmple>
 80a2a80:	b180      	cbz	r0, 80a2aa4 <_ZN8APDS930112readLuxLevelEv+0x1d4>
    luxVal = (0.0128 * ch0) - (0.0153 * ch1);
 80a2a82:	4620      	mov	r0, r4
 80a2a84:	f003 f9be 	bl	80a5e04 <__aeabi_f2d>
 80a2a88:	a327      	add	r3, pc, #156	; (adr r3, 80a2b28 <_ZN8APDS930112readLuxLevelEv+0x258>)
 80a2a8a:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2a8e:	f003 fa11 	bl	80a5eb4 <__aeabi_dmul>
 80a2a92:	4606      	mov	r6, r0
 80a2a94:	4628      	mov	r0, r5
 80a2a96:	460f      	mov	r7, r1
 80a2a98:	f003 f9b4 	bl	80a5e04 <__aeabi_f2d>
 80a2a9c:	a324      	add	r3, pc, #144	; (adr r3, 80a2b30 <_ZN8APDS930112readLuxLevelEv+0x260>)
 80a2a9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2aa2:	e7df      	b.n	80a2a64 <_ZN8APDS930112readLuxLevelEv+0x194>
  else if (ratio <= 1.3)
 80a2aa4:	4630      	mov	r0, r6
 80a2aa6:	a324      	add	r3, pc, #144	; (adr r3, 80a2b38 <_ZN8APDS930112readLuxLevelEv+0x268>)
 80a2aa8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2aac:	4639      	mov	r1, r7
 80a2aae:	f003 fc7d 	bl	80a63ac <__aeabi_dcmple>
 80a2ab2:	b180      	cbz	r0, 80a2ad6 <_ZN8APDS930112readLuxLevelEv+0x206>
    luxVal = (0.00146 * ch0) - (0.00112*ch1);
 80a2ab4:	4620      	mov	r0, r4
 80a2ab6:	f003 f9a5 	bl	80a5e04 <__aeabi_f2d>
 80a2aba:	a321      	add	r3, pc, #132	; (adr r3, 80a2b40 <_ZN8APDS930112readLuxLevelEv+0x270>)
 80a2abc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2ac0:	f003 f9f8 	bl	80a5eb4 <__aeabi_dmul>
 80a2ac4:	4606      	mov	r6, r0
 80a2ac6:	4628      	mov	r0, r5
 80a2ac8:	460f      	mov	r7, r1
 80a2aca:	f003 f99b 	bl	80a5e04 <__aeabi_f2d>
 80a2ace:	a31e      	add	r3, pc, #120	; (adr r3, 80a2b48 <_ZN8APDS930112readLuxLevelEv+0x278>)
 80a2ad0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a2ad4:	e7c6      	b.n	80a2a64 <_ZN8APDS930112readLuxLevelEv+0x194>
  float luxVal = 0.0;
 80a2ad6:	2000      	movs	r0, #0
 80a2ad8:	e71f      	b.n	80a291a <_ZN8APDS930112readLuxLevelEv+0x4a>
 80a2ada:	bf00      	nop
 80a2adc:	f3af 8000 	nop.w
 80a2ae0:	66666666 	.word	0x66666666
 80a2ae4:	3ff66666 	.word	0x3ff66666
 80a2ae8:	77318fc5 	.word	0x77318fc5
 80a2aec:	3f9f212d 	.word	0x3f9f212d
 80a2af0:	c8b43958 	.word	0xc8b43958
 80a2af4:	3fafbe76 	.word	0x3fafbe76
 80a2af8:	69696969 	.word	0x69696969
 80a2afc:	403d6969 	.word	0x403d6969
 80a2b00:	efbefbf0 	.word	0xefbefbf0
 80a2b04:	400fbefb 	.word	0x400fbefb
 80a2b08:	b851eb85 	.word	0xb851eb85
 80a2b0c:	3fe3851e 	.word	0x3fe3851e
 80a2b10:	8db8bac7 	.word	0x8db8bac7
 80a2b14:	3f96f006 	.word	0x3f96f006
 80a2b18:	c8b43958 	.word	0xc8b43958
 80a2b1c:	3f9fbe76 	.word	0x3f9fbe76
 80a2b20:	9999999a 	.word	0x9999999a
 80a2b24:	3fe99999 	.word	0x3fe99999
 80a2b28:	eb1c432d 	.word	0xeb1c432d
 80a2b2c:	3f8a36e2 	.word	0x3f8a36e2
 80a2b30:	3d07c84b 	.word	0x3d07c84b
 80a2b34:	3f8f559b 	.word	0x3f8f559b
 80a2b38:	cccccccd 	.word	0xcccccccd
 80a2b3c:	3ff4cccc 	.word	0x3ff4cccc
 80a2b40:	102363b2 	.word	0x102363b2
 80a2b44:	3f57ebaf 	.word	0x3f57ebaf
 80a2b48:	d7c6fbd2 	.word	0xd7c6fbd2
 80a2b4c:	3f52599e 	.word	0x3f52599e

080a2b50 <_ZN8APDS930111setRegisterEhh>:

APDS9301::status APDS9301::setRegister(uint8_t regAddress, uint8_t newVal)
{
 80a2b50:	b570      	push	{r4, r5, r6, lr}
 80a2b52:	4606      	mov	r6, r0
 80a2b54:	4614      	mov	r4, r2
 80a2b56:	460d      	mov	r5, r1
  Wire.beginTransmission(address);
 80a2b58:	f001 fd68 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2b5c:	7831      	ldrb	r1, [r6, #0]
 80a2b5e:	f001 fb99 	bl	80a4294 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write(regAddress);
 80a2b62:	f001 fd63 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2b66:	6803      	ldr	r3, [r0, #0]
 80a2b68:	4629      	mov	r1, r5
 80a2b6a:	689b      	ldr	r3, [r3, #8]
 80a2b6c:	4798      	blx	r3
  Wire.write(newVal);
 80a2b6e:	f001 fd5d 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2b72:	6803      	ldr	r3, [r0, #0]
 80a2b74:	4621      	mov	r1, r4
 80a2b76:	689b      	ldr	r3, [r3, #8]
 80a2b78:	4798      	blx	r3
  if (Wire.endTransmission() == 0) return SUCCESS;
 80a2b7a:	f001 fd57 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a2b7e:	f001 fb94 	bl	80a42aa <_ZN7TwoWire15endTransmissionEv>
  else return I2C_FAILURE;

}
 80a2b82:	3800      	subs	r0, #0
 80a2b84:	bf18      	it	ne
 80a2b86:	2001      	movne	r0, #1
 80a2b88:	bd70      	pop	{r4, r5, r6, pc}

080a2b8a <_ZN8APDS930111powerEnableENS_9powEnableE>:
  if (powEn == POW_OFF) return setRegister(CONTROL_REG, 0);
 80a2b8a:	460a      	mov	r2, r1
 80a2b8c:	b911      	cbnz	r1, 80a2b94 <_ZN8APDS930111powerEnableENS_9powEnableE+0xa>
  else                  return setRegister(CONTROL_REG, 3);
 80a2b8e:	2180      	movs	r1, #128	; 0x80
 80a2b90:	f7ff bfde 	b.w	80a2b50 <_ZN8APDS930111setRegisterEhh>
 80a2b94:	2203      	movs	r2, #3
 80a2b96:	e7fa      	b.n	80a2b8e <_ZN8APDS930111powerEnableENS_9powEnableE+0x4>

080a2b98 <_ZN8APDS93015beginEh>:
{
 80a2b98:	b508      	push	{r3, lr}
  this->address = address;
 80a2b9a:	7001      	strb	r1, [r0, #0]
  powerEnable(POW_ON);
 80a2b9c:	2101      	movs	r1, #1
 80a2b9e:	f7ff fff4 	bl	80a2b8a <_ZN8APDS930111powerEnableENS_9powEnableE>
}
 80a2ba2:	2000      	movs	r0, #0
 80a2ba4:	bd08      	pop	{r3, pc}

080a2ba6 <_ZN8APDS93017setGainENS_4gainE>:
{
 80a2ba6:	b538      	push	{r3, r4, r5, lr}
 80a2ba8:	460d      	mov	r5, r1
  uint8_t regVal = getRegister(TIMING_REG);
 80a2baa:	2181      	movs	r1, #129	; 0x81
{
 80a2bac:	4604      	mov	r4, r0
  uint8_t regVal = getRegister(TIMING_REG);
 80a2bae:	f7ff fe28 	bl	80a2802 <_ZN8APDS930111getRegisterEh>
  if (gainLevel == LOW_GAIN) regVal &= ~0x10;
 80a2bb2:	b93d      	cbnz	r5, 80a2bc4 <_ZN8APDS93017setGainENS_4gainE+0x1e>
 80a2bb4:	f000 02ef 	and.w	r2, r0, #239	; 0xef
  return setRegister(TIMING_REG, regVal);
 80a2bb8:	4620      	mov	r0, r4
}
 80a2bba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return setRegister(TIMING_REG, regVal);
 80a2bbe:	2181      	movs	r1, #129	; 0x81
 80a2bc0:	f7ff bfc6 	b.w	80a2b50 <_ZN8APDS930111setRegisterEhh>
  else                       regVal |= 0x10;
 80a2bc4:	f040 0210 	orr.w	r2, r0, #16
 80a2bc8:	b2d2      	uxtb	r2, r2
 80a2bca:	e7f5      	b.n	80a2bb8 <_ZN8APDS93017setGainENS_4gainE+0x12>

080a2bcc <_ZN8APDS930118setIntegrationTimeENS_7intTimeE>:
{
 80a2bcc:	b538      	push	{r3, r4, r5, lr}
 80a2bce:	460c      	mov	r4, r1
  uint8_t regVal = getRegister(TIMING_REG);
 80a2bd0:	2181      	movs	r1, #129	; 0x81
{
 80a2bd2:	4605      	mov	r5, r0
  uint8_t regVal = getRegister(TIMING_REG);
 80a2bd4:	f7ff fe15 	bl	80a2802 <_ZN8APDS930111getRegisterEh>
  regVal &= ~0x03;
 80a2bd8:	f000 02fc 	and.w	r2, r0, #252	; 0xfc
  if (integrationTime == INT_TIME_13_7_MS)      regVal |= 0x00;
 80a2bdc:	b11c      	cbz	r4, 80a2be6 <_ZN8APDS930118setIntegrationTimeENS_7intTimeE+0x1a>
  else if (integrationTime == INT_TIME_101_MS)  regVal |= 0x01;
 80a2bde:	2c01      	cmp	r4, #1
 80a2be0:	d107      	bne.n	80a2bf2 <_ZN8APDS930118setIntegrationTimeENS_7intTimeE+0x26>
 80a2be2:	f042 0201 	orr.w	r2, r2, #1
  return setRegister(TIMING_REG, regVal);
 80a2be6:	4628      	mov	r0, r5
}
 80a2be8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return setRegister(TIMING_REG, regVal);
 80a2bec:	2181      	movs	r1, #129	; 0x81
 80a2bee:	f7ff bfaf 	b.w	80a2b50 <_ZN8APDS930111setRegisterEhh>
  else if (integrationTime == INT_TIME_402_MS)  regVal |= 0x02;
 80a2bf2:	2c02      	cmp	r4, #2
 80a2bf4:	bf08      	it	eq
 80a2bf6:	f042 0202 	orreq.w	r2, r2, #2
 80a2bfa:	e7f4      	b.n	80a2be6 <_ZN8APDS930118setIntegrationTimeENS_7intTimeE+0x1a>

080a2bfc <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
 80a2bfc:	b508      	push	{r3, lr}
 80a2bfe:	4b02      	ldr	r3, [pc, #8]	; (80a2c08 <HAL_Pin_Map+0xc>)
 80a2c00:	681b      	ldr	r3, [r3, #0]
 80a2c02:	681b      	ldr	r3, [r3, #0]
 80a2c04:	9301      	str	r3, [sp, #4]
 80a2c06:	bd08      	pop	{r3, pc}
 80a2c08:	080601b0 	.word	0x080601b0

080a2c0c <HAL_Validate_Pin_Function>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
 80a2c0c:	b508      	push	{r3, lr}
 80a2c0e:	4b02      	ldr	r3, [pc, #8]	; (80a2c18 <HAL_Validate_Pin_Function+0xc>)
 80a2c10:	681b      	ldr	r3, [r3, #0]
 80a2c12:	685b      	ldr	r3, [r3, #4]
 80a2c14:	9301      	str	r3, [sp, #4]
 80a2c16:	bd08      	pop	{r3, pc}
 80a2c18:	080601b0 	.word	0x080601b0

080a2c1c <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a2c1c:	b508      	push	{r3, lr}
 80a2c1e:	4b02      	ldr	r3, [pc, #8]	; (80a2c28 <HAL_Pin_Mode+0xc>)
 80a2c20:	681b      	ldr	r3, [r3, #0]
 80a2c22:	689b      	ldr	r3, [r3, #8]
 80a2c24:	9301      	str	r3, [sp, #4]
 80a2c26:	bd08      	pop	{r3, pc}
 80a2c28:	080601b0 	.word	0x080601b0

080a2c2c <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a2c2c:	b508      	push	{r3, lr}
 80a2c2e:	4b02      	ldr	r3, [pc, #8]	; (80a2c38 <HAL_Get_Pin_Mode+0xc>)
 80a2c30:	681b      	ldr	r3, [r3, #0]
 80a2c32:	68db      	ldr	r3, [r3, #12]
 80a2c34:	9301      	str	r3, [sp, #4]
 80a2c36:	bd08      	pop	{r3, pc}
 80a2c38:	080601b0 	.word	0x080601b0

080a2c3c <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a2c3c:	b508      	push	{r3, lr}
 80a2c3e:	4b02      	ldr	r3, [pc, #8]	; (80a2c48 <HAL_GPIO_Write+0xc>)
 80a2c40:	681b      	ldr	r3, [r3, #0]
 80a2c42:	691b      	ldr	r3, [r3, #16]
 80a2c44:	9301      	str	r3, [sp, #4]
 80a2c46:	bd08      	pop	{r3, pc}
 80a2c48:	080601b0 	.word	0x080601b0

080a2c4c <HAL_GPIO_Read>:
DYNALIB_FN(5, hal_gpio, HAL_GPIO_Read, int32_t(pin_t))
 80a2c4c:	b508      	push	{r3, lr}
 80a2c4e:	4b02      	ldr	r3, [pc, #8]	; (80a2c58 <HAL_GPIO_Read+0xc>)
 80a2c50:	681b      	ldr	r3, [r3, #0]
 80a2c52:	695b      	ldr	r3, [r3, #20]
 80a2c54:	9301      	str	r3, [sp, #4]
 80a2c56:	bd08      	pop	{r3, pc}
 80a2c58:	080601b0 	.word	0x080601b0

080a2c5c <HAL_Interrupts_Attach>:
DYNALIB_FN(6, hal_gpio, HAL_Interrupts_Attach, int(uint16_t, HAL_InterruptHandler, void*, InterruptMode, HAL_InterruptExtraConfiguration*))
 80a2c5c:	b508      	push	{r3, lr}
 80a2c5e:	4b02      	ldr	r3, [pc, #8]	; (80a2c68 <HAL_Interrupts_Attach+0xc>)
 80a2c60:	681b      	ldr	r3, [r3, #0]
 80a2c62:	699b      	ldr	r3, [r3, #24]
 80a2c64:	9301      	str	r3, [sp, #4]
 80a2c66:	bd08      	pop	{r3, pc}
 80a2c68:	080601b0 	.word	0x080601b0

080a2c6c <HAL_Interrupts_Detach>:
DYNALIB_FN(7, hal_gpio, HAL_Interrupts_Detach, int(uint16_t))
 80a2c6c:	b508      	push	{r3, lr}
 80a2c6e:	4b02      	ldr	r3, [pc, #8]	; (80a2c78 <HAL_Interrupts_Detach+0xc>)
 80a2c70:	681b      	ldr	r3, [r3, #0]
 80a2c72:	69db      	ldr	r3, [r3, #28]
 80a2c74:	9301      	str	r3, [sp, #4]
 80a2c76:	bd08      	pop	{r3, pc}
 80a2c78:	080601b0 	.word	0x080601b0

080a2c7c <HAL_Interrupts_Enable_All>:
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
 80a2c7c:	b508      	push	{r3, lr}
 80a2c7e:	4b02      	ldr	r3, [pc, #8]	; (80a2c88 <HAL_Interrupts_Enable_All+0xc>)
 80a2c80:	681b      	ldr	r3, [r3, #0]
 80a2c82:	6a1b      	ldr	r3, [r3, #32]
 80a2c84:	9301      	str	r3, [sp, #4]
 80a2c86:	bd08      	pop	{r3, pc}
 80a2c88:	080601b0 	.word	0x080601b0

080a2c8c <HAL_Interrupts_Disable_All>:
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))
 80a2c8c:	b508      	push	{r3, lr}
 80a2c8e:	4b02      	ldr	r3, [pc, #8]	; (80a2c98 <HAL_Interrupts_Disable_All+0xc>)
 80a2c90:	681b      	ldr	r3, [r3, #0]
 80a2c92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a2c94:	9301      	str	r3, [sp, #4]
 80a2c96:	bd08      	pop	{r3, pc}
 80a2c98:	080601b0 	.word	0x080601b0

080a2c9c <HAL_DAC_Write>:

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
 80a2c9c:	b508      	push	{r3, lr}
 80a2c9e:	4b02      	ldr	r3, [pc, #8]	; (80a2ca8 <HAL_DAC_Write+0xc>)
 80a2ca0:	681b      	ldr	r3, [r3, #0]
 80a2ca2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a2ca4:	9301      	str	r3, [sp, #4]
 80a2ca6:	bd08      	pop	{r3, pc}
 80a2ca8:	080601b0 	.word	0x080601b0

080a2cac <hal_adc_read>:
DYNALIB_FN(11, hal_gpio, hal_adc_set_sample_time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, hal_adc_read, int32_t(uint16_t))
 80a2cac:	b508      	push	{r3, lr}
 80a2cae:	4b02      	ldr	r3, [pc, #8]	; (80a2cb8 <hal_adc_read+0xc>)
 80a2cb0:	681b      	ldr	r3, [r3, #0]
 80a2cb2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2cb4:	9301      	str	r3, [sp, #4]
 80a2cb6:	bd08      	pop	{r3, pc}
 80a2cb8:	080601b0 	.word	0x080601b0

080a2cbc <hal_pwm_write_ext>:
DYNALIB_FN(25, hal_gpio, HAL_DAC_Get_Resolution, uint8_t(pin_t))
DYNALIB_FN(26, hal_gpio, HAL_DAC_Set_Resolution, void(pin_t, uint8_t))
DYNALIB_FN(27, hal_gpio, HAL_DAC_Enable_Buffer, void(pin_t pin, uint8_t state))
DYNALIB_FN(28, hal_gpio, hal_pwm_get_resolution, uint8_t(uint16_t))
DYNALIB_FN(29, hal_gpio, hal_pwm_set_resolution, void(uint16_t, uint8_t))
DYNALIB_FN(30, hal_gpio, hal_pwm_write_ext, void(uint16_t, uint32_t))
 80a2cbc:	b508      	push	{r3, lr}
 80a2cbe:	4b02      	ldr	r3, [pc, #8]	; (80a2cc8 <hal_pwm_write_ext+0xc>)
 80a2cc0:	681b      	ldr	r3, [r3, #0]
 80a2cc2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80a2cc4:	9301      	str	r3, [sp, #4]
 80a2cc6:	bd08      	pop	{r3, pc}
 80a2cc8:	080601b0 	.word	0x080601b0

080a2ccc <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a2ccc:	b508      	push	{r3, lr}
 80a2cce:	4b02      	ldr	r3, [pc, #8]	; (80a2cd8 <HAL_RNG_GetRandomNumber+0xc>)
 80a2cd0:	681b      	ldr	r3, [r3, #0]
 80a2cd2:	685b      	ldr	r3, [r3, #4]
 80a2cd4:	9301      	str	r3, [sp, #4]
 80a2cd6:	bd08      	pop	{r3, pc}
 80a2cd8:	0806019c 	.word	0x0806019c

080a2cdc <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
 80a2cdc:	b508      	push	{r3, lr}
 80a2cde:	4b02      	ldr	r3, [pc, #8]	; (80a2ce8 <HAL_Delay_Microseconds+0xc>)
 80a2ce0:	681b      	ldr	r3, [r3, #0]
 80a2ce2:	68db      	ldr	r3, [r3, #12]
 80a2ce4:	9301      	str	r3, [sp, #4]
 80a2ce6:	bd08      	pop	{r3, pc}
 80a2ce8:	0806019c 	.word	0x0806019c

080a2cec <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a2cec:	b508      	push	{r3, lr}
 80a2cee:	4b02      	ldr	r3, [pc, #8]	; (80a2cf8 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a2cf0:	681b      	ldr	r3, [r3, #0]
 80a2cf2:	695b      	ldr	r3, [r3, #20]
 80a2cf4:	9301      	str	r3, [sp, #4]
 80a2cf6:	bd08      	pop	{r3, pc}
 80a2cf8:	0806019c 	.word	0x0806019c

080a2cfc <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
 80a2cfc:	b508      	push	{r3, lr}
 80a2cfe:	4b02      	ldr	r3, [pc, #8]	; (80a2d08 <os_mutex_recursive_create+0xc>)
 80a2d00:	681b      	ldr	r3, [r3, #0]
 80a2d02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a2d04:	9301      	str	r3, [sp, #4]
 80a2d06:	bd08      	pop	{r3, pc}
 80a2d08:	080601d0 	.word	0x080601d0

080a2d0c <os_mutex_recursive_destroy>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
 80a2d0c:	b508      	push	{r3, lr}
 80a2d0e:	4b02      	ldr	r3, [pc, #8]	; (80a2d18 <os_mutex_recursive_destroy+0xc>)
 80a2d10:	681b      	ldr	r3, [r3, #0]
 80a2d12:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a2d14:	9301      	str	r3, [sp, #4]
 80a2d16:	bd08      	pop	{r3, pc}
 80a2d18:	080601d0 	.word	0x080601d0

080a2d1c <hal_usart_init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, hal_usart_init, void(hal_usart_interface_t, hal_usart_ring_buffer_t*, hal_usart_ring_buffer_t*))
 80a2d1c:	b508      	push	{r3, lr}
 80a2d1e:	4b02      	ldr	r3, [pc, #8]	; (80a2d28 <hal_usart_init+0xc>)
 80a2d20:	681b      	ldr	r3, [r3, #0]
 80a2d22:	699b      	ldr	r3, [r3, #24]
 80a2d24:	9301      	str	r3, [sp, #4]
 80a2d26:	bd08      	pop	{r3, pc}
 80a2d28:	080601c4 	.word	0x080601c4

080a2d2c <hal_usart_write>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, hal_usart_begin, void(hal_usart_interface_t, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, hal_usart_end, void(hal_usart_interface_t))
DYNALIB_FN(BASE_IDX + 3, hal_usart, hal_usart_write, uint32_t(hal_usart_interface_t, uint8_t))
 80a2d2c:	b508      	push	{r3, lr}
 80a2d2e:	4b02      	ldr	r3, [pc, #8]	; (80a2d38 <hal_usart_write+0xc>)
 80a2d30:	681b      	ldr	r3, [r3, #0]
 80a2d32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a2d34:	9301      	str	r3, [sp, #4]
 80a2d36:	bd08      	pop	{r3, pc}
 80a2d38:	080601c4 	.word	0x080601c4

080a2d3c <hal_usart_available>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, hal_usart_available, int32_t(hal_usart_interface_t))
 80a2d3c:	b508      	push	{r3, lr}
 80a2d3e:	4b02      	ldr	r3, [pc, #8]	; (80a2d48 <hal_usart_available+0xc>)
 80a2d40:	681b      	ldr	r3, [r3, #0]
 80a2d42:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a2d44:	9301      	str	r3, [sp, #4]
 80a2d46:	bd08      	pop	{r3, pc}
 80a2d48:	080601c4 	.word	0x080601c4

080a2d4c <hal_usart_read>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, hal_usart_read, int32_t(hal_usart_interface_t))
 80a2d4c:	b508      	push	{r3, lr}
 80a2d4e:	4b02      	ldr	r3, [pc, #8]	; (80a2d58 <hal_usart_read+0xc>)
 80a2d50:	681b      	ldr	r3, [r3, #0]
 80a2d52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a2d54:	9301      	str	r3, [sp, #4]
 80a2d56:	bd08      	pop	{r3, pc}
 80a2d58:	080601c4 	.word	0x080601c4

080a2d5c <hal_usart_peek>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, hal_usart_peek, int32_t(hal_usart_interface_t))
 80a2d5c:	b508      	push	{r3, lr}
 80a2d5e:	4b02      	ldr	r3, [pc, #8]	; (80a2d68 <hal_usart_peek+0xc>)
 80a2d60:	681b      	ldr	r3, [r3, #0]
 80a2d62:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2d64:	9301      	str	r3, [sp, #4]
 80a2d66:	bd08      	pop	{r3, pc}
 80a2d68:	080601c4 	.word	0x080601c4

080a2d6c <hal_usart_flush>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, hal_usart_flush, void(hal_usart_interface_t))
 80a2d6c:	b508      	push	{r3, lr}
 80a2d6e:	4b02      	ldr	r3, [pc, #8]	; (80a2d78 <hal_usart_flush+0xc>)
 80a2d70:	681b      	ldr	r3, [r3, #0]
 80a2d72:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a2d74:	9301      	str	r3, [sp, #4]
 80a2d76:	bd08      	pop	{r3, pc}
 80a2d78:	080601c4 	.word	0x080601c4

080a2d7c <hal_usart_is_enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, hal_usart_is_enabled, bool(hal_usart_interface_t))
 80a2d7c:	b508      	push	{r3, lr}
 80a2d7e:	4b02      	ldr	r3, [pc, #8]	; (80a2d88 <hal_usart_is_enabled+0xc>)
 80a2d80:	681b      	ldr	r3, [r3, #0]
 80a2d82:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a2d84:	9301      	str	r3, [sp, #4]
 80a2d86:	bd08      	pop	{r3, pc}
 80a2d88:	080601c4 	.word	0x080601c4

080a2d8c <hal_usart_available_data_for_write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, hal_usart_half_duplex, void(hal_usart_interface_t, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, hal_usart_available_data_for_write, int32_t(hal_usart_interface_t))
 80a2d8c:	b508      	push	{r3, lr}
 80a2d8e:	4b02      	ldr	r3, [pc, #8]	; (80a2d98 <hal_usart_available_data_for_write+0xc>)
 80a2d90:	681b      	ldr	r3, [r3, #0]
 80a2d92:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a2d94:	9301      	str	r3, [sp, #4]
 80a2d96:	bd08      	pop	{r3, pc}
 80a2d98:	080601c4 	.word	0x080601c4

080a2d9c <hal_usart_begin_config>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart, hal_usart_begin_config, void(hal_usart_interface_t serial, uint32_t baud, uint32_t config, void *ptr))
 80a2d9c:	b508      	push	{r3, lr}
 80a2d9e:	4b02      	ldr	r3, [pc, #8]	; (80a2da8 <hal_usart_begin_config+0xc>)
 80a2da0:	681b      	ldr	r3, [r3, #0]
 80a2da2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a2da4:	9301      	str	r3, [sp, #4]
 80a2da6:	bd08      	pop	{r3, pc}
 80a2da8:	080601c4 	.word	0x080601c4

080a2dac <hal_i2c_begin>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal_i2c, hal_i2c_set_speed, void(hal_i2c_interface_t, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 1, hal_i2c, hal_i2c_enable_dma_mode, void(hal_i2c_interface_t, bool, void*))
DYNALIB_FN(BASE_IDX + 2, hal_i2c, hal_i2c_stretch_clock, void(hal_i2c_interface_t, bool, void*))
DYNALIB_FN(BASE_IDX + 3, hal_i2c, hal_i2c_begin, void(hal_i2c_interface_t, hal_i2c_mode_t, uint8_t, void*))
 80a2dac:	b508      	push	{r3, lr}
 80a2dae:	4b02      	ldr	r3, [pc, #8]	; (80a2db8 <hal_i2c_begin+0xc>)
 80a2db0:	681b      	ldr	r3, [r3, #0]
 80a2db2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a2db4:	9301      	str	r3, [sp, #4]
 80a2db6:	bd08      	pop	{r3, pc}
 80a2db8:	080601ac 	.word	0x080601ac

080a2dbc <hal_i2c_begin_transmission>:
DYNALIB_FN(BASE_IDX + 4, hal_i2c, hal_i2c_end, void(hal_i2c_interface_t, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, hal_i2c_request, uint32_t(hal_i2c_interface_t, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, hal_i2c_begin_transmission, void(hal_i2c_interface_t, uint8_t, const hal_i2c_transmission_config_t*))
 80a2dbc:	b508      	push	{r3, lr}
 80a2dbe:	4b02      	ldr	r3, [pc, #8]	; (80a2dc8 <hal_i2c_begin_transmission+0xc>)
 80a2dc0:	681b      	ldr	r3, [r3, #0]
 80a2dc2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a2dc4:	9301      	str	r3, [sp, #4]
 80a2dc6:	bd08      	pop	{r3, pc}
 80a2dc8:	080601ac 	.word	0x080601ac

080a2dcc <hal_i2c_end_transmission>:
DYNALIB_FN(BASE_IDX + 7, hal_i2c, hal_i2c_end_transmission, uint8_t(hal_i2c_interface_t, uint8_t, void*))
 80a2dcc:	b508      	push	{r3, lr}
 80a2dce:	4b02      	ldr	r3, [pc, #8]	; (80a2dd8 <hal_i2c_end_transmission+0xc>)
 80a2dd0:	681b      	ldr	r3, [r3, #0]
 80a2dd2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80a2dd4:	9301      	str	r3, [sp, #4]
 80a2dd6:	bd08      	pop	{r3, pc}
 80a2dd8:	080601ac 	.word	0x080601ac

080a2ddc <hal_i2c_write>:
DYNALIB_FN(BASE_IDX + 8, hal_i2c, hal_i2c_write, uint32_t(hal_i2c_interface_t, uint8_t, void*))
 80a2ddc:	b508      	push	{r3, lr}
 80a2dde:	4b02      	ldr	r3, [pc, #8]	; (80a2de8 <hal_i2c_write+0xc>)
 80a2de0:	681b      	ldr	r3, [r3, #0]
 80a2de2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a2de4:	9301      	str	r3, [sp, #4]
 80a2de6:	bd08      	pop	{r3, pc}
 80a2de8:	080601ac 	.word	0x080601ac

080a2dec <hal_i2c_available>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, hal_i2c_available, int32_t(hal_i2c_interface_t, void*))
 80a2dec:	b508      	push	{r3, lr}
 80a2dee:	4b02      	ldr	r3, [pc, #8]	; (80a2df8 <hal_i2c_available+0xc>)
 80a2df0:	681b      	ldr	r3, [r3, #0]
 80a2df2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a2df4:	9301      	str	r3, [sp, #4]
 80a2df6:	bd08      	pop	{r3, pc}
 80a2df8:	080601ac 	.word	0x080601ac

080a2dfc <hal_i2c_read>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, hal_i2c_read, int32_t(hal_i2c_interface_t, void*))
 80a2dfc:	b508      	push	{r3, lr}
 80a2dfe:	4b02      	ldr	r3, [pc, #8]	; (80a2e08 <hal_i2c_read+0xc>)
 80a2e00:	681b      	ldr	r3, [r3, #0]
 80a2e02:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a2e04:	9301      	str	r3, [sp, #4]
 80a2e06:	bd08      	pop	{r3, pc}
 80a2e08:	080601ac 	.word	0x080601ac

080a2e0c <hal_i2c_peek>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, hal_i2c_peek, int32_t(hal_i2c_interface_t, void*))
 80a2e0c:	b508      	push	{r3, lr}
 80a2e0e:	4b02      	ldr	r3, [pc, #8]	; (80a2e18 <hal_i2c_peek+0xc>)
 80a2e10:	681b      	ldr	r3, [r3, #0]
 80a2e12:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a2e14:	9301      	str	r3, [sp, #4]
 80a2e16:	bd08      	pop	{r3, pc}
 80a2e18:	080601ac 	.word	0x080601ac

080a2e1c <hal_i2c_flush>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, hal_i2c_flush, void(hal_i2c_interface_t, void*))
 80a2e1c:	b508      	push	{r3, lr}
 80a2e1e:	4b02      	ldr	r3, [pc, #8]	; (80a2e28 <hal_i2c_flush+0xc>)
 80a2e20:	681b      	ldr	r3, [r3, #0]
 80a2e22:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a2e24:	9301      	str	r3, [sp, #4]
 80a2e26:	bd08      	pop	{r3, pc}
 80a2e28:	080601ac 	.word	0x080601ac

080a2e2c <hal_i2c_is_enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, hal_i2c_is_enabled, bool(hal_i2c_interface_t, void*))
 80a2e2c:	b508      	push	{r3, lr}
 80a2e2e:	4b02      	ldr	r3, [pc, #8]	; (80a2e38 <hal_i2c_is_enabled+0xc>)
 80a2e30:	681b      	ldr	r3, [r3, #0]
 80a2e32:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a2e34:	9301      	str	r3, [sp, #4]
 80a2e36:	bd08      	pop	{r3, pc}
 80a2e38:	080601ac 	.word	0x080601ac

080a2e3c <hal_i2c_init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, hal_i2c_set_callback_on_received, void(hal_i2c_interface_t, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, hal_i2c_set_callback_on_requested, void(hal_i2c_interface_t, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, hal_i2c_init, int(hal_i2c_interface_t, const hal_i2c_config_t*))
 80a2e3c:	b508      	push	{r3, lr}
 80a2e3e:	4b03      	ldr	r3, [pc, #12]	; (80a2e4c <hal_i2c_init+0x10>)
 80a2e40:	681b      	ldr	r3, [r3, #0]
 80a2e42:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a2e46:	9301      	str	r3, [sp, #4]
 80a2e48:	bd08      	pop	{r3, pc}
 80a2e4a:	0000      	.short	0x0000
 80a2e4c:	080601ac 	.word	0x080601ac

080a2e50 <hal_i2c_request_ex>:
DYNALIB_FN(BASE_IDX + 17, hal_i2c, hal_i2c_reset, uint8_t(hal_i2c_interface_t, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 18, hal_i2c, hal_i2c_lock, int32_t(hal_i2c_interface_t, void*))
DYNALIB_FN(BASE_IDX + 19, hal_i2c, hal_i2c_unlock, int32_t(hal_i2c_interface_t, void*))
DYNALIB_FN(BASE_IDX + 20, hal_i2c, hal_i2c_request_ex, int32_t(hal_i2c_interface_t, const hal_i2c_transmission_config_t*, void*))
 80a2e50:	b508      	push	{r3, lr}
 80a2e52:	4b03      	ldr	r3, [pc, #12]	; (80a2e60 <hal_i2c_request_ex+0x10>)
 80a2e54:	681b      	ldr	r3, [r3, #0]
 80a2e56:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a2e5a:	9301      	str	r3, [sp, #4]
 80a2e5c:	bd08      	pop	{r3, pc}
 80a2e5e:	0000      	.short	0x0000
 80a2e60:	080601ac 	.word	0x080601ac

080a2e64 <hal_spi_init>:
DYNALIB_FN(2, hal_spi, hal_spi_set_bit_order, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(3, hal_spi, hal_spi_set_data_mode, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(4, hal_spi, hal_spi_set_clock_divider, void(hal_spi_interface_t, uint8_t))
DYNALIB_FN(5, hal_spi, hal_spi_transfer, uint16_t(hal_spi_interface_t, uint16_t))
DYNALIB_FN(6, hal_spi, hal_spi_is_enabled_deprecated, bool(void))
DYNALIB_FN(7, hal_spi, hal_spi_init, void(hal_spi_interface_t))
 80a2e64:	b508      	push	{r3, lr}
 80a2e66:	4b02      	ldr	r3, [pc, #8]	; (80a2e70 <hal_spi_init+0xc>)
 80a2e68:	681b      	ldr	r3, [r3, #0]
 80a2e6a:	69db      	ldr	r3, [r3, #28]
 80a2e6c:	9301      	str	r3, [sp, #4]
 80a2e6e:	bd08      	pop	{r3, pc}
 80a2e70:	080601b4 	.word	0x080601b4

080a2e74 <hal_spi_is_enabled>:
DYNALIB_FN(8, hal_spi, hal_spi_is_enabled, bool(hal_spi_interface_t))
 80a2e74:	b508      	push	{r3, lr}
 80a2e76:	4b02      	ldr	r3, [pc, #8]	; (80a2e80 <hal_spi_is_enabled+0xc>)
 80a2e78:	681b      	ldr	r3, [r3, #0]
 80a2e7a:	6a1b      	ldr	r3, [r3, #32]
 80a2e7c:	9301      	str	r3, [sp, #4]
 80a2e7e:	bd08      	pop	{r3, pc}
 80a2e80:	080601b4 	.word	0x080601b4

080a2e84 <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a2e84:	b508      	push	{r3, lr}
 80a2e86:	4b02      	ldr	r3, [pc, #8]	; (80a2e90 <HAL_USB_USART_Init+0xc>)
 80a2e88:	681b      	ldr	r3, [r3, #0]
 80a2e8a:	681b      	ldr	r3, [r3, #0]
 80a2e8c:	9301      	str	r3, [sp, #4]
 80a2e8e:	bd08      	pop	{r3, pc}
 80a2e90:	080601d8 	.word	0x080601d8

080a2e94 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a2e94:	b508      	push	{r3, lr}
 80a2e96:	4b02      	ldr	r3, [pc, #8]	; (80a2ea0 <HAL_USB_USART_Available_Data+0xc>)
 80a2e98:	681b      	ldr	r3, [r3, #0]
 80a2e9a:	691b      	ldr	r3, [r3, #16]
 80a2e9c:	9301      	str	r3, [sp, #4]
 80a2e9e:	bd08      	pop	{r3, pc}
 80a2ea0:	080601d8 	.word	0x080601d8

080a2ea4 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a2ea4:	b508      	push	{r3, lr}
 80a2ea6:	4b02      	ldr	r3, [pc, #8]	; (80a2eb0 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a2ea8:	681b      	ldr	r3, [r3, #0]
 80a2eaa:	695b      	ldr	r3, [r3, #20]
 80a2eac:	9301      	str	r3, [sp, #4]
 80a2eae:	bd08      	pop	{r3, pc}
 80a2eb0:	080601d8 	.word	0x080601d8

080a2eb4 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a2eb4:	b508      	push	{r3, lr}
 80a2eb6:	4b02      	ldr	r3, [pc, #8]	; (80a2ec0 <HAL_USB_USART_Receive_Data+0xc>)
 80a2eb8:	681b      	ldr	r3, [r3, #0]
 80a2eba:	699b      	ldr	r3, [r3, #24]
 80a2ebc:	9301      	str	r3, [sp, #4]
 80a2ebe:	bd08      	pop	{r3, pc}
 80a2ec0:	080601d8 	.word	0x080601d8

080a2ec4 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a2ec4:	b508      	push	{r3, lr}
 80a2ec6:	4b02      	ldr	r3, [pc, #8]	; (80a2ed0 <HAL_USB_USART_Send_Data+0xc>)
 80a2ec8:	681b      	ldr	r3, [r3, #0]
 80a2eca:	69db      	ldr	r3, [r3, #28]
 80a2ecc:	9301      	str	r3, [sp, #4]
 80a2ece:	bd08      	pop	{r3, pc}
 80a2ed0:	080601d8 	.word	0x080601d8

080a2ed4 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a2ed4:	b508      	push	{r3, lr}
 80a2ed6:	4b02      	ldr	r3, [pc, #8]	; (80a2ee0 <HAL_USB_USART_Flush_Data+0xc>)
 80a2ed8:	681b      	ldr	r3, [r3, #0]
 80a2eda:	6a1b      	ldr	r3, [r3, #32]
 80a2edc:	9301      	str	r3, [sp, #4]
 80a2ede:	bd08      	pop	{r3, pc}
 80a2ee0:	080601d8 	.word	0x080601d8

080a2ee4 <inet_gethostbyname>:
DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, int(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a2ee4:	b508      	push	{r3, lr}
 80a2ee6:	4b02      	ldr	r3, [pc, #8]	; (80a2ef0 <inet_gethostbyname+0xc>)
 80a2ee8:	681b      	ldr	r3, [r3, #0]
 80a2eea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a2eec:	9301      	str	r3, [sp, #4]
 80a2eee:	bd08      	pop	{r3, pc}
 80a2ef0:	080601c0 	.word	0x080601c0

080a2ef4 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a2ef4:	b508      	push	{r3, lr}
 80a2ef6:	4b02      	ldr	r3, [pc, #8]	; (80a2f00 <set_system_mode+0xc>)
 80a2ef8:	681b      	ldr	r3, [r3, #0]
 80a2efa:	685b      	ldr	r3, [r3, #4]
 80a2efc:	9301      	str	r3, [sp, #4]
 80a2efe:	bd08      	pop	{r3, pc}
 80a2f00:	080601a4 	.word	0x080601a4

080a2f04 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a2f04:	b508      	push	{r3, lr}
 80a2f06:	4b02      	ldr	r3, [pc, #8]	; (80a2f10 <system_delay_ms+0xc>)
 80a2f08:	681b      	ldr	r3, [r3, #0]
 80a2f0a:	695b      	ldr	r3, [r3, #20]
 80a2f0c:	9301      	str	r3, [sp, #4]
 80a2f0e:	bd08      	pop	{r3, pc}
 80a2f10:	080601a4 	.word	0x080601a4

080a2f14 <application_thread_current>:
DYNALIB_FN(15, system, system_get_flag, int(system_flag_t, uint8_t*, void*))
DYNALIB_FN(16, system, Spark_Prepare_For_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))
DYNALIB_FN(17, system, Spark_Save_Firmware_Chunk, int(FileTransfer::Descriptor&, const uint8_t*, void*))
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
 80a2f14:	b508      	push	{r3, lr}
 80a2f16:	4b02      	ldr	r3, [pc, #8]	; (80a2f20 <application_thread_current+0xc>)
 80a2f18:	681b      	ldr	r3, [r3, #0]
 80a2f1a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a2f1c:	9301      	str	r3, [sp, #4]
 80a2f1e:	bd08      	pop	{r3, pc}
 80a2f20:	080601a4 	.word	0x080601a4

080a2f24 <application_thread_invoke>:
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
 80a2f24:	b508      	push	{r3, lr}
 80a2f26:	4b02      	ldr	r3, [pc, #8]	; (80a2f30 <application_thread_invoke+0xc>)
 80a2f28:	681b      	ldr	r3, [r3, #0]
 80a2f2a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a2f2c:	9301      	str	r3, [sp, #4]
 80a2f2e:	bd08      	pop	{r3, pc}
 80a2f30:	080601a4 	.word	0x080601a4

080a2f34 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a2f34:	b508      	push	{r3, lr}
 80a2f36:	4b03      	ldr	r3, [pc, #12]	; (80a2f44 <system_ctrl_set_app_request_handler+0x10>)
 80a2f38:	681b      	ldr	r3, [r3, #0]
 80a2f3a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a2f3e:	9301      	str	r3, [sp, #4]
 80a2f40:	bd08      	pop	{r3, pc}
 80a2f42:	0000      	.short	0x0000
 80a2f44:	080601a4 	.word	0x080601a4

080a2f48 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a2f48:	b508      	push	{r3, lr}
 80a2f4a:	4b03      	ldr	r3, [pc, #12]	; (80a2f58 <system_ctrl_set_result+0x10>)
 80a2f4c:	681b      	ldr	r3, [r3, #0]
 80a2f4e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a2f52:	9301      	str	r3, [sp, #4]
 80a2f54:	bd08      	pop	{r3, pc}
 80a2f56:	0000      	.short	0x0000
 80a2f58:	080601a4 	.word	0x080601a4

080a2f5c <system_reset>:
#else
#define BASE_IDX1 (BASE_IDX + 17)
#endif // HAL_PLATFORM_POWER_MANAGEMENT

DYNALIB_FN(BASE_IDX1 + 0, system, system_sleep_ext, int(const hal_sleep_config_t*, hal_wakeup_source_base_t**, void*))
DYNALIB_FN(BASE_IDX1 + 1, system, system_reset, int(unsigned, unsigned, unsigned, unsigned, void*))
 80a2f5c:	b508      	push	{r3, lr}
 80a2f5e:	4b03      	ldr	r3, [pc, #12]	; (80a2f6c <system_reset+0x10>)
 80a2f60:	681b      	ldr	r3, [r3, #0]
 80a2f62:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80a2f66:	9301      	str	r3, [sp, #4]
 80a2f68:	bd08      	pop	{r3, pc}
 80a2f6a:	0000      	.short	0x0000
 80a2f6c:	080601a4 	.word	0x080601a4

080a2f70 <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
 80a2f70:	b508      	push	{r3, lr}
 80a2f72:	4b02      	ldr	r3, [pc, #8]	; (80a2f7c <network_connect+0xc>)
 80a2f74:	681b      	ldr	r3, [r3, #0]
 80a2f76:	685b      	ldr	r3, [r3, #4]
 80a2f78:	9301      	str	r3, [sp, #4]
 80a2f7a:	bd08      	pop	{r3, pc}
 80a2f7c:	080601c8 	.word	0x080601c8

080a2f80 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
 80a2f80:	b508      	push	{r3, lr}
 80a2f82:	4b02      	ldr	r3, [pc, #8]	; (80a2f8c <network_connecting+0xc>)
 80a2f84:	681b      	ldr	r3, [r3, #0]
 80a2f86:	689b      	ldr	r3, [r3, #8]
 80a2f88:	9301      	str	r3, [sp, #4]
 80a2f8a:	bd08      	pop	{r3, pc}
 80a2f8c:	080601c8 	.word	0x080601c8

080a2f90 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
 80a2f90:	b508      	push	{r3, lr}
 80a2f92:	4b02      	ldr	r3, [pc, #8]	; (80a2f9c <network_disconnect+0xc>)
 80a2f94:	681b      	ldr	r3, [r3, #0]
 80a2f96:	68db      	ldr	r3, [r3, #12]
 80a2f98:	9301      	str	r3, [sp, #4]
 80a2f9a:	bd08      	pop	{r3, pc}
 80a2f9c:	080601c8 	.word	0x080601c8

080a2fa0 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a2fa0:	b508      	push	{r3, lr}
 80a2fa2:	4b02      	ldr	r3, [pc, #8]	; (80a2fac <network_ready+0xc>)
 80a2fa4:	681b      	ldr	r3, [r3, #0]
 80a2fa6:	691b      	ldr	r3, [r3, #16]
 80a2fa8:	9301      	str	r3, [sp, #4]
 80a2faa:	bd08      	pop	{r3, pc}
 80a2fac:	080601c8 	.word	0x080601c8

080a2fb0 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
 80a2fb0:	b508      	push	{r3, lr}
 80a2fb2:	4b02      	ldr	r3, [pc, #8]	; (80a2fbc <network_on+0xc>)
 80a2fb4:	681b      	ldr	r3, [r3, #0]
 80a2fb6:	695b      	ldr	r3, [r3, #20]
 80a2fb8:	9301      	str	r3, [sp, #4]
 80a2fba:	bd08      	pop	{r3, pc}
 80a2fbc:	080601c8 	.word	0x080601c8

080a2fc0 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
 80a2fc0:	b508      	push	{r3, lr}
 80a2fc2:	4b02      	ldr	r3, [pc, #8]	; (80a2fcc <network_off+0xc>)
 80a2fc4:	681b      	ldr	r3, [r3, #0]
 80a2fc6:	699b      	ldr	r3, [r3, #24]
 80a2fc8:	9301      	str	r3, [sp, #4]
 80a2fca:	bd08      	pop	{r3, pc}
 80a2fcc:	080601c8 	.word	0x080601c8

080a2fd0 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
 80a2fd0:	b508      	push	{r3, lr}
 80a2fd2:	4b02      	ldr	r3, [pc, #8]	; (80a2fdc <network_listen+0xc>)
 80a2fd4:	681b      	ldr	r3, [r3, #0]
 80a2fd6:	69db      	ldr	r3, [r3, #28]
 80a2fd8:	9301      	str	r3, [sp, #4]
 80a2fda:	bd08      	pop	{r3, pc}
 80a2fdc:	080601c8 	.word	0x080601c8

080a2fe0 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
 80a2fe0:	b508      	push	{r3, lr}
 80a2fe2:	4b02      	ldr	r3, [pc, #8]	; (80a2fec <network_listening+0xc>)
 80a2fe4:	681b      	ldr	r3, [r3, #0]
 80a2fe6:	6a1b      	ldr	r3, [r3, #32]
 80a2fe8:	9301      	str	r3, [sp, #4]
 80a2fea:	bd08      	pop	{r3, pc}
 80a2fec:	080601c8 	.word	0x080601c8

080a2ff0 <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
 80a2ff0:	b508      	push	{r3, lr}
 80a2ff2:	4b02      	ldr	r3, [pc, #8]	; (80a2ffc <network_set_listen_timeout+0xc>)
 80a2ff4:	681b      	ldr	r3, [r3, #0]
 80a2ff6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a2ff8:	9301      	str	r3, [sp, #4]
 80a2ffa:	bd08      	pop	{r3, pc}
 80a2ffc:	080601c8 	.word	0x080601c8

080a3000 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
 80a3000:	b508      	push	{r3, lr}
 80a3002:	4b02      	ldr	r3, [pc, #8]	; (80a300c <network_get_listen_timeout+0xc>)
 80a3004:	681b      	ldr	r3, [r3, #0]
 80a3006:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a3008:	9301      	str	r3, [sp, #4]
 80a300a:	bd08      	pop	{r3, pc}
 80a300c:	080601c8 	.word	0x080601c8

080a3010 <network_is_on>:
DYNALIB_FN(14, system_net, network_set_hostname, int(network_handle_t, uint32_t, const char*, void*))
DYNALIB_FN(15, system_net, network_get_hostname, int(network_handle_t, uint32_t, char*, size_t, void*))
DYNALIB_FN(16, system_net, network_is_on, bool(network_handle_t, void*))
 80a3010:	b508      	push	{r3, lr}
 80a3012:	4b02      	ldr	r3, [pc, #8]	; (80a301c <network_is_on+0xc>)
 80a3014:	681b      	ldr	r3, [r3, #0]
 80a3016:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a3018:	9301      	str	r3, [sp, #4]
 80a301a:	bd08      	pop	{r3, pc}
 80a301c:	080601c8 	.word	0x080601c8

080a3020 <network_is_off>:
DYNALIB_FN(17, system_net, network_is_off, bool(network_handle_t, void*))
 80a3020:	b508      	push	{r3, lr}
 80a3022:	4b02      	ldr	r3, [pc, #8]	; (80a302c <network_is_off+0xc>)
 80a3024:	681b      	ldr	r3, [r3, #0]
 80a3026:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a3028:	9301      	str	r3, [sp, #4]
 80a302a:	bd08      	pop	{r3, pc}
 80a302c:	080601c8 	.word	0x080601c8

080a3030 <spark_variable>:
#endif


DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
 80a3030:	b508      	push	{r3, lr}
 80a3032:	4b02      	ldr	r3, [pc, #8]	; (80a303c <spark_variable+0xc>)
 80a3034:	681b      	ldr	r3, [r3, #0]
 80a3036:	681b      	ldr	r3, [r3, #0]
 80a3038:	9301      	str	r3, [sp, #4]
 80a303a:	bd08      	pop	{r3, pc}
 80a303c:	080601cc 	.word	0x080601cc

080a3040 <spark_function>:
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
 80a3040:	b508      	push	{r3, lr}
 80a3042:	4b02      	ldr	r3, [pc, #8]	; (80a304c <spark_function+0xc>)
 80a3044:	681b      	ldr	r3, [r3, #0]
 80a3046:	685b      	ldr	r3, [r3, #4]
 80a3048:	9301      	str	r3, [sp, #4]
 80a304a:	bd08      	pop	{r3, pc}
 80a304c:	080601cc 	.word	0x080601cc

080a3050 <spark_process>:
DYNALIB_FN(2, system_cloud, spark_process, void(void))
 80a3050:	b508      	push	{r3, lr}
 80a3052:	4b02      	ldr	r3, [pc, #8]	; (80a305c <spark_process+0xc>)
 80a3054:	681b      	ldr	r3, [r3, #0]
 80a3056:	689b      	ldr	r3, [r3, #8]
 80a3058:	9301      	str	r3, [sp, #4]
 80a305a:	bd08      	pop	{r3, pc}
 80a305c:	080601cc 	.word	0x080601cc

080a3060 <spark_cloud_flag_connected>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
 80a3060:	b508      	push	{r3, lr}
 80a3062:	4b02      	ldr	r3, [pc, #8]	; (80a306c <spark_cloud_flag_connected+0xc>)
 80a3064:	681b      	ldr	r3, [r3, #0]
 80a3066:	695b      	ldr	r3, [r3, #20]
 80a3068:	9301      	str	r3, [sp, #4]
 80a306a:	bd08      	pop	{r3, pc}
 80a306c:	080601cc 	.word	0x080601cc

080a3070 <spark_send_event>:
DYNALIB_FN(6, system_cloud, system_cloud_protocol_instance, ProtocolFacade*(void))
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
 80a3070:	b508      	push	{r3, lr}
 80a3072:	4b02      	ldr	r3, [pc, #8]	; (80a307c <spark_send_event+0xc>)
 80a3074:	681b      	ldr	r3, [r3, #0]
 80a3076:	6a1b      	ldr	r3, [r3, #32]
 80a3078:	9301      	str	r3, [sp, #4]
 80a307a:	bd08      	pop	{r3, pc}
 80a307c:	080601cc 	.word	0x080601cc

080a3080 <spark_sync_time>:
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
 80a3080:	b508      	push	{r3, lr}
 80a3082:	4b02      	ldr	r3, [pc, #8]	; (80a308c <spark_sync_time+0xc>)
 80a3084:	681b      	ldr	r3, [r3, #0]
 80a3086:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3088:	9301      	str	r3, [sp, #4]
 80a308a:	bd08      	pop	{r3, pc}
 80a308c:	080601cc 	.word	0x080601cc

080a3090 <spark_sync_time_pending>:
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
 80a3090:	b508      	push	{r3, lr}
 80a3092:	4b02      	ldr	r3, [pc, #8]	; (80a309c <spark_sync_time_pending+0xc>)
 80a3094:	681b      	ldr	r3, [r3, #0]
 80a3096:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3098:	9301      	str	r3, [sp, #4]
 80a309a:	bd08      	pop	{r3, pc}
 80a309c:	080601cc 	.word	0x080601cc

080a30a0 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time32_t*, time_t*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, const void*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a30a0:	b508      	push	{r3, lr}
 80a30a2:	4b02      	ldr	r3, [pc, #8]	; (80a30ac <spark_set_random_seed_from_cloud_handler+0xc>)
 80a30a4:	681b      	ldr	r3, [r3, #0]
 80a30a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a30a8:	9301      	str	r3, [sp, #4]
 80a30aa:	bd08      	pop	{r3, pc}
 80a30ac:	080601cc 	.word	0x080601cc

080a30b0 <malloc>:
#include "hal_platform.h"
#endif // defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a30b0:	b508      	push	{r3, lr}
 80a30b2:	4b02      	ldr	r3, [pc, #8]	; (80a30bc <malloc+0xc>)
 80a30b4:	681b      	ldr	r3, [r3, #0]
 80a30b6:	681b      	ldr	r3, [r3, #0]
 80a30b8:	9301      	str	r3, [sp, #4]
 80a30ba:	bd08      	pop	{r3, pc}
 80a30bc:	080601a0 	.word	0x080601a0

080a30c0 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a30c0:	b508      	push	{r3, lr}
 80a30c2:	4b02      	ldr	r3, [pc, #8]	; (80a30cc <free+0xc>)
 80a30c4:	681b      	ldr	r3, [r3, #0]
 80a30c6:	685b      	ldr	r3, [r3, #4]
 80a30c8:	9301      	str	r3, [sp, #4]
 80a30ca:	bd08      	pop	{r3, pc}
 80a30cc:	080601a0 	.word	0x080601a0

080a30d0 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a30d0:	b508      	push	{r3, lr}
 80a30d2:	4b02      	ldr	r3, [pc, #8]	; (80a30dc <realloc+0xc>)
 80a30d4:	681b      	ldr	r3, [r3, #0]
 80a30d6:	689b      	ldr	r3, [r3, #8]
 80a30d8:	9301      	str	r3, [sp, #4]
 80a30da:	bd08      	pop	{r3, pc}
 80a30dc:	080601a0 	.word	0x080601a0

080a30e0 <sprintf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
 80a30e0:	b508      	push	{r3, lr}
 80a30e2:	4b02      	ldr	r3, [pc, #8]	; (80a30ec <sprintf+0xc>)
 80a30e4:	681b      	ldr	r3, [r3, #0]
 80a30e6:	68db      	ldr	r3, [r3, #12]
 80a30e8:	9301      	str	r3, [sp, #4]
 80a30ea:	bd08      	pop	{r3, pc}
 80a30ec:	080601a0 	.word	0x080601a0

080a30f0 <vsnprintf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a30f0:	b508      	push	{r3, lr}
 80a30f2:	4b02      	ldr	r3, [pc, #8]	; (80a30fc <vsnprintf+0xc>)
 80a30f4:	681b      	ldr	r3, [r3, #0]
 80a30f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a30f8:	9301      	str	r3, [sp, #4]
 80a30fa:	bd08      	pop	{r3, pc}
 80a30fc:	080601a0 	.word	0x080601a0

080a3100 <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
 80a3100:	b508      	push	{r3, lr}
 80a3102:	4b02      	ldr	r3, [pc, #8]	; (80a310c <abort+0xc>)
 80a3104:	681b      	ldr	r3, [r3, #0]
 80a3106:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3108:	9301      	str	r3, [sp, #4]
 80a310a:	bd08      	pop	{r3, pc}
 80a310c:	080601a0 	.word	0x080601a0

080a3110 <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
 80a3110:	b508      	push	{r3, lr}
 80a3112:	4b02      	ldr	r3, [pc, #8]	; (80a311c <_malloc_r+0xc>)
 80a3114:	681b      	ldr	r3, [r3, #0]
 80a3116:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3118:	9301      	str	r3, [sp, #4]
 80a311a:	bd08      	pop	{r3, pc}
 80a311c:	080601a0 	.word	0x080601a0

080a3120 <__errno>:
DYNALIB_FN(13, rt, _free_r, void(struct _reent*, void*))
DYNALIB_FN(14, rt, _realloc_r, void*(struct _reent*, void*, size_t))
DYNALIB_FN(15, rt, __errno, int*())
 80a3120:	b508      	push	{r3, lr}
 80a3122:	4b02      	ldr	r3, [pc, #8]	; (80a312c <__errno+0xc>)
 80a3124:	681b      	ldr	r3, [r3, #0]
 80a3126:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a3128:	9301      	str	r3, [sp, #4]
 80a312a:	bd08      	pop	{r3, pc}
 80a312c:	080601a0 	.word	0x080601a0

080a3130 <__assert_func>:
// on Gen 2 platforms without breaking inter-module dependencies.
// RT is currently being imported into system-part1 from system-part2,
// which is the reverse direction.

#if defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))
DYNALIB_FN(16, rt, __assert_func, void(const char*, int, const char*, const char*))
 80a3130:	b508      	push	{r3, lr}
 80a3132:	4b02      	ldr	r3, [pc, #8]	; (80a313c <__assert_func+0xc>)
 80a3134:	681b      	ldr	r3, [r3, #0]
 80a3136:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a3138:	9301      	str	r3, [sp, #4]
 80a313a:	bd08      	pop	{r3, pc}
 80a313c:	080601a0 	.word	0x080601a0

080a3140 <newlib_impure_ptr_callback>:
DYNALIB_FN(17, rt, newlib_impure_ptr_callback, void(void (*)(struct _reent*, size_t, uint32_t, void*), void*))
 80a3140:	b508      	push	{r3, lr}
 80a3142:	4b02      	ldr	r3, [pc, #8]	; (80a314c <newlib_impure_ptr_callback+0xc>)
 80a3144:	681b      	ldr	r3, [r3, #0]
 80a3146:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a3148:	9301      	str	r3, [sp, #4]
 80a314a:	bd08      	pop	{r3, pc}
 80a314c:	080601a0 	.word	0x080601a0

080a3150 <_ZN8SPIClassC1E19hal_spi_interface_t>:
    }
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(hal_spi_interface_t spi)
 80a3150:	b570      	push	{r4, r5, r6, lr}
    /**
     * Creates a shared mutex.
     */
    RecursiveMutex(os_mutex_recursive_t handle) : handle_(handle) {}

    RecursiveMutex() : handle_(nullptr)
 80a3152:	2600      	movs	r6, #0
 80a3154:	4604      	mov	r4, r0
 80a3156:	460d      	mov	r5, r1
 80a3158:	f840 6f08 	str.w	r6, [r0, #8]!
    {
        os_mutex_recursive_create(&handle_);
 80a315c:	f7ff fdce 	bl	80a2cfc <os_mutex_recursive_create>
{
    _spi = spi;
    hal_spi_init(_spi);
 80a3160:	4628      	mov	r0, r5
    _spi = spi;
 80a3162:	7025      	strb	r5, [r4, #0]
    hal_spi_init(_spi);
 80a3164:	f7ff fe7e 	bl	80a2e64 <hal_spi_init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
}
 80a3168:	4620      	mov	r0, r4
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
 80a316a:	6066      	str	r6, [r4, #4]
}
 80a316c:	bd70      	pop	{r4, r5, r6, pc}

080a316e <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv>:
    operator SleepResult() {
        return toSleepResult();
    }

private:
    void freeWakeupSourceMemory() {
 80a316e:	b510      	push	{r4, lr}
 80a3170:	4604      	mov	r4, r0
        if (wakeupSource_) {
 80a3172:	6800      	ldr	r0, [r0, #0]
 80a3174:	b118      	cbz	r0, 80a317e <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv+0x10>
            free(wakeupSource_);
 80a3176:	f7ff ffa3 	bl	80a30c0 <free>
            wakeupSource_ = nullptr;
 80a317a:	2300      	movs	r3, #0
 80a317c:	6023      	str	r3, [r4, #0]
        }
    }
 80a317e:	bd10      	pop	{r4, pc}

080a3180 <_ZN11SystemClassD1Ev>:
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
 80a3180:	b510      	push	{r4, lr}
 80a3182:	4604      	mov	r4, r0
        freeWakeupSourceMemory();
 80a3184:	f7ff fff3 	bl	80a316e <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv>
class SystemClass {
 80a3188:	4620      	mov	r0, r4
 80a318a:	bd10      	pop	{r4, pc}

080a318c <_ZN11SystemClass5resetEmN8particle5FlagsI19SystemResetFlagTypemEE>:
{
    reset(0, flags);
}

void SystemClass::reset(uint32_t data, SystemResetFlags flags)
{
 80a318c:	b507      	push	{r0, r1, r2, lr}
 80a318e:	460b      	mov	r3, r1
    system_reset(SYSTEM_RESET_MODE_NORMAL, RESET_REASON_USER, data, flags.value(), nullptr);
 80a3190:	2100      	movs	r1, #0
{
 80a3192:	4602      	mov	r2, r0
    system_reset(SYSTEM_RESET_MODE_NORMAL, RESET_REASON_USER, data, flags.value(), nullptr);
 80a3194:	9100      	str	r1, [sp, #0]
 80a3196:	2001      	movs	r0, #1
 80a3198:	218c      	movs	r1, #140	; 0x8c
 80a319a:	f7ff fedf 	bl	80a2f5c <system_reset>
}
 80a319e:	b003      	add	sp, #12
 80a31a0:	f85d fb04 	ldr.w	pc, [sp], #4

080a31a4 <_ZN11SystemClass5resetEN8particle5FlagsI19SystemResetFlagTypemEE>:
{
 80a31a4:	4601      	mov	r1, r0
    reset(0, flags);
 80a31a6:	2000      	movs	r0, #0
 80a31a8:	f7ff bff0 	b.w	80a318c <_ZN11SystemClass5resetEmN8particle5FlagsI19SystemResetFlagTypemEE>

080a31ac <_ZN11SystemClass5resetEv>:
    reset(SystemResetFlags());
 80a31ac:	2000      	movs	r0, #0
 80a31ae:	f7ff bff9 	b.w	80a31a4 <_ZN11SystemClass5resetEN8particle5FlagsI19SystemResetFlagTypemEE>
	...

080a31b4 <_GLOBAL__sub_I_System>:
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
 80a31b4:	2202      	movs	r2, #2
              error_(SYSTEM_ERROR_NONE) {
 80a31b6:	2000      	movs	r0, #0
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
 80a31b8:	b510      	push	{r4, lr}
 80a31ba:	4b08      	ldr	r3, [pc, #32]	; (80a31dc <_GLOBAL__sub_I_System+0x28>)
 80a31bc:	4c08      	ldr	r4, [pc, #32]	; (80a31e0 <_GLOBAL__sub_I_System+0x2c>)
 80a31be:	601a      	str	r2, [r3, #0]
    SleepResult() {}
 80a31c0:	4b08      	ldr	r3, [pc, #32]	; (80a31e4 <_GLOBAL__sub_I_System+0x30>)
              error_(SYSTEM_ERROR_NONE) {
 80a31c2:	e9c4 0000 	strd	r0, r0, [r4]
    SleepResult() {}
 80a31c6:	60a3      	str	r3, [r4, #8]
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a31c8:	f7ff fe94 	bl	80a2ef4 <set_system_mode>
SystemClass System;
 80a31cc:	4620      	mov	r0, r4
 80a31ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
SystemClass System;
 80a31d2:	4a05      	ldr	r2, [pc, #20]	; (80a31e8 <_GLOBAL__sub_I_System+0x34>)
 80a31d4:	4905      	ldr	r1, [pc, #20]	; (80a31ec <_GLOBAL__sub_I_System+0x38>)
 80a31d6:	f001 ba51 	b.w	80a467c <__aeabi_atexit>
 80a31da:	bf00      	nop
 80a31dc:	2000055c 	.word	0x2000055c
 80a31e0:	20000550 	.word	0x20000550
 80a31e4:	ffff0000 	.word	0xffff0000
 80a31e8:	20000088 	.word	0x20000088
 80a31ec:	080a3181 	.word	0x080a3181

080a31f0 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a31f0:	b510      	push	{r4, lr}
 80a31f2:	4604      	mov	r4, r0
{
	free(buffer);
 80a31f4:	6800      	ldr	r0, [r0, #0]
 80a31f6:	f7ff ff63 	bl	80a30c0 <free>
}
 80a31fa:	4620      	mov	r0, r4
 80a31fc:	bd10      	pop	{r4, pc}

080a31fe <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a31fe:	b510      	push	{r4, lr}
 80a3200:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a3202:	6800      	ldr	r0, [r0, #0]
 80a3204:	b108      	cbz	r0, 80a320a <_ZN6String10invalidateEv+0xc>
 80a3206:	f7ff ff5b 	bl	80a30c0 <free>
	buffer = NULL;
 80a320a:	2300      	movs	r3, #0
	capacity = len = 0;
 80a320c:	e9c4 3301 	strd	r3, r3, [r4, #4]
	buffer = NULL;
 80a3210:	6023      	str	r3, [r4, #0]
}
 80a3212:	bd10      	pop	{r4, pc}

080a3214 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a3214:	b538      	push	{r3, r4, r5, lr}
 80a3216:	4604      	mov	r4, r0
 80a3218:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a321a:	6800      	ldr	r0, [r0, #0]
 80a321c:	3101      	adds	r1, #1
 80a321e:	f7ff ff57 	bl	80a30d0 <realloc>
	if (newbuffer) {
 80a3222:	b110      	cbz	r0, 80a322a <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a3224:	e9c4 0500 	strd	r0, r5, [r4]
		return 1;
 80a3228:	2001      	movs	r0, #1
	}
	return 0;
}
 80a322a:	bd38      	pop	{r3, r4, r5, pc}

080a322c <_ZN6String7reserveEj>:
{
 80a322c:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a322e:	6803      	ldr	r3, [r0, #0]
{
 80a3230:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a3232:	b123      	cbz	r3, 80a323e <_ZN6String7reserveEj+0x12>
 80a3234:	6843      	ldr	r3, [r0, #4]
 80a3236:	428b      	cmp	r3, r1
 80a3238:	d301      	bcc.n	80a323e <_ZN6String7reserveEj+0x12>
 80a323a:	2001      	movs	r0, #1
}
 80a323c:	bd10      	pop	{r4, pc}
	if (changeBuffer(size)) {
 80a323e:	4620      	mov	r0, r4
 80a3240:	f7ff ffe8 	bl	80a3214 <_ZN6String12changeBufferEj>
 80a3244:	2800      	cmp	r0, #0
 80a3246:	d0f9      	beq.n	80a323c <_ZN6String7reserveEj+0x10>
		if (len == 0) buffer[0] = 0;
 80a3248:	68a3      	ldr	r3, [r4, #8]
 80a324a:	2b00      	cmp	r3, #0
 80a324c:	d1f5      	bne.n	80a323a <_ZN6String7reserveEj+0xe>
 80a324e:	6822      	ldr	r2, [r4, #0]
 80a3250:	7013      	strb	r3, [r2, #0]
 80a3252:	e7f2      	b.n	80a323a <_ZN6String7reserveEj+0xe>

080a3254 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a3254:	b570      	push	{r4, r5, r6, lr}
 80a3256:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a3258:	4611      	mov	r1, r2
{
 80a325a:	4604      	mov	r4, r0
 80a325c:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a325e:	f7ff ffe5 	bl	80a322c <_ZN6String7reserveEj>
 80a3262:	b920      	cbnz	r0, 80a326e <_ZN6String4copyEPKcj+0x1a>
		invalidate();
 80a3264:	4620      	mov	r0, r4
 80a3266:	f7ff ffca 	bl	80a31fe <_ZN6String10invalidateEv>
	}
	len = length;
	memcpy(buffer, cstr, length);
	buffer[len] = 0;
	return *this;
}
 80a326a:	4620      	mov	r0, r4
 80a326c:	bd70      	pop	{r4, r5, r6, pc}
	memcpy(buffer, cstr, length);
 80a326e:	462a      	mov	r2, r5
 80a3270:	4631      	mov	r1, r6
 80a3272:	6820      	ldr	r0, [r4, #0]
	len = length;
 80a3274:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a3276:	f003 fc95 	bl	80a6ba4 <memcpy>
	buffer[len] = 0;
 80a327a:	2100      	movs	r1, #0
 80a327c:	6822      	ldr	r2, [r4, #0]
 80a327e:	68a3      	ldr	r3, [r4, #8]
 80a3280:	54d1      	strb	r1, [r2, r3]
	return *this;
 80a3282:	e7f2      	b.n	80a326a <_ZN6String4copyEPKcj+0x16>

080a3284 <_ZN6StringC1EPK19__FlashStringHelper>:
String::String(const __FlashStringHelper *pstr)
 80a3284:	b538      	push	{r3, r4, r5, lr}
	buffer = NULL;
 80a3286:	2300      	movs	r3, #0
String::String(const __FlashStringHelper *pstr)
 80a3288:	4604      	mov	r4, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a328a:	460d      	mov	r5, r1
	capacity = 0;
 80a328c:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
 80a3290:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a3292:	7303      	strb	r3, [r0, #12]
	if (cstr) copy(cstr, strlen(cstr));
 80a3294:	b139      	cbz	r1, 80a32a6 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
	if (cstr) copy(cstr, strlen(cstr));
 80a3296:	4608      	mov	r0, r1
 80a3298:	f003 fced 	bl	80a6c76 <strlen>
 80a329c:	4629      	mov	r1, r5
 80a329e:	4602      	mov	r2, r0
 80a32a0:	4620      	mov	r0, r4
 80a32a2:	f7ff ffd7 	bl	80a3254 <_ZN6String4copyEPKcj>
}
 80a32a6:	4620      	mov	r0, r4
 80a32a8:	bd38      	pop	{r3, r4, r5, pc}

080a32aa <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a32aa:	4288      	cmp	r0, r1
{
 80a32ac:	b510      	push	{r4, lr}
 80a32ae:	460b      	mov	r3, r1
 80a32b0:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a32b2:	d004      	beq.n	80a32be <_ZN6StringaSERKS_+0x14>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a32b4:	6809      	ldr	r1, [r1, #0]
 80a32b6:	b121      	cbz	r1, 80a32c2 <_ZN6StringaSERKS_+0x18>
 80a32b8:	689a      	ldr	r2, [r3, #8]
 80a32ba:	f7ff ffcb 	bl	80a3254 <_ZN6String4copyEPKcj>
	else invalidate();

	return *this;
}
 80a32be:	4620      	mov	r0, r4
 80a32c0:	bd10      	pop	{r4, pc}
	else invalidate();
 80a32c2:	f7ff ff9c 	bl	80a31fe <_ZN6String10invalidateEv>
 80a32c6:	e7fa      	b.n	80a32be <_ZN6StringaSERKS_+0x14>

080a32c8 <_ZN6StringC1ERKS_>:
	buffer = NULL;
 80a32c8:	2300      	movs	r3, #0
String::String(const String &value)
 80a32ca:	b510      	push	{r4, lr}
 80a32cc:	4604      	mov	r4, r0
	capacity = 0;
 80a32ce:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
 80a32d2:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a32d4:	7303      	strb	r3, [r0, #12]
	*this = value;
 80a32d6:	f7ff ffe8 	bl	80a32aa <_ZN6StringaSERKS_>
}
 80a32da:	4620      	mov	r0, r4
 80a32dc:	bd10      	pop	{r4, pc}

080a32de <_ZNK6String6equalsEPKc>:
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a32de:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a32e0:	6882      	ldr	r2, [r0, #8]
 80a32e2:	b93a      	cbnz	r2, 80a32f4 <_ZNK6String6equalsEPKc+0x16>
 80a32e4:	b121      	cbz	r1, 80a32f0 <_ZNK6String6equalsEPKc+0x12>
 80a32e6:	7808      	ldrb	r0, [r1, #0]
	if (cstr == NULL) return buffer[0] == 0;
	return strcmp(buffer, cstr) == 0;
 80a32e8:	fab0 f080 	clz	r0, r0
 80a32ec:	0940      	lsrs	r0, r0, #5
 80a32ee:	e000      	b.n	80a32f2 <_ZNK6String6equalsEPKc+0x14>
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a32f0:	2001      	movs	r0, #1
}
 80a32f2:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
 80a32f4:	6800      	ldr	r0, [r0, #0]
 80a32f6:	b909      	cbnz	r1, 80a32fc <_ZNK6String6equalsEPKc+0x1e>
 80a32f8:	7800      	ldrb	r0, [r0, #0]
 80a32fa:	e7f5      	b.n	80a32e8 <_ZNK6String6equalsEPKc+0xa>
	return strcmp(buffer, cstr) == 0;
 80a32fc:	f003 fc96 	bl	80a6c2c <strcmp>
 80a3300:	e7f2      	b.n	80a32e8 <_ZNK6String6equalsEPKc+0xa>

080a3302 <_ZNK6String10startsWithERKS_j>:
	if (len < s2.len) return 0;
	return startsWith(s2, 0);
}

unsigned char String::startsWith( const String &s2, unsigned int offset ) const
{
 80a3302:	4613      	mov	r3, r2
 80a3304:	b510      	push	{r4, lr}
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
 80a3306:	688a      	ldr	r2, [r1, #8]
 80a3308:	6884      	ldr	r4, [r0, #8]
 80a330a:	1aa4      	subs	r4, r4, r2
 80a330c:	429c      	cmp	r4, r3
 80a330e:	d30a      	bcc.n	80a3326 <_ZNK6String10startsWithERKS_j+0x24>
 80a3310:	6800      	ldr	r0, [r0, #0]
 80a3312:	b138      	cbz	r0, 80a3324 <_ZNK6String10startsWithERKS_j+0x22>
 80a3314:	6809      	ldr	r1, [r1, #0]
 80a3316:	b141      	cbz	r1, 80a332a <_ZNK6String10startsWithERKS_j+0x28>
	return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;
 80a3318:	4418      	add	r0, r3
 80a331a:	f003 fcb4 	bl	80a6c86 <strncmp>
 80a331e:	fab0 f080 	clz	r0, r0
 80a3322:	0940      	lsrs	r0, r0, #5
}
 80a3324:	bd10      	pop	{r4, pc}
	if (offset > len - s2.len || !buffer || !s2.buffer) return 0;
 80a3326:	2000      	movs	r0, #0
 80a3328:	e7fc      	b.n	80a3324 <_ZNK6String10startsWithERKS_j+0x22>
 80a332a:	4608      	mov	r0, r1
 80a332c:	e7fa      	b.n	80a3324 <_ZNK6String10startsWithERKS_j+0x22>

080a332e <_ZNK6String10startsWithERKS_>:
	if (len < s2.len) return 0;
 80a332e:	6882      	ldr	r2, [r0, #8]
 80a3330:	688b      	ldr	r3, [r1, #8]
 80a3332:	429a      	cmp	r2, r3
 80a3334:	d302      	bcc.n	80a333c <_ZNK6String10startsWithERKS_+0xe>
	return startsWith(s2, 0);
 80a3336:	2200      	movs	r2, #0
 80a3338:	f7ff bfe3 	b.w	80a3302 <_ZNK6String10startsWithERKS_j>
}
 80a333c:	2000      	movs	r0, #0
 80a333e:	4770      	bx	lr

080a3340 <_ZNK6StringixEj>:
	return buffer[index];
}

char String::operator[]( unsigned int index ) const
{
	if (index >= len || !buffer) return 0;
 80a3340:	6883      	ldr	r3, [r0, #8]
 80a3342:	428b      	cmp	r3, r1
 80a3344:	d903      	bls.n	80a334e <_ZNK6StringixEj+0xe>
 80a3346:	6800      	ldr	r0, [r0, #0]
 80a3348:	b110      	cbz	r0, 80a3350 <_ZNK6StringixEj+0x10>
	return buffer[index];
 80a334a:	5c40      	ldrb	r0, [r0, r1]
 80a334c:	4770      	bx	lr
	if (index >= len || !buffer) return 0;
 80a334e:	2000      	movs	r0, #0
}
 80a3350:	4770      	bx	lr

080a3352 <_ZNK6String6charAtEj>:
	return operator[](loc);
 80a3352:	f7ff bff5 	b.w	80a3340 <_ZNK6StringixEj>
	...

080a3358 <_ZNK6String9substringEjj>:
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a3358:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a335a:	461d      	mov	r5, r3
	if (left > right) {
 80a335c:	429a      	cmp	r2, r3
 80a335e:	bf88      	it	hi
 80a3360:	4613      	movhi	r3, r2
{
 80a3362:	460f      	mov	r7, r1
 80a3364:	4614      	mov	r4, r2
	if (left > right) {
 80a3366:	bf88      	it	hi
 80a3368:	462c      	movhi	r4, r5
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
 80a336a:	490b      	ldr	r1, [pc, #44]	; (80a3398 <_ZNK6String9substringEjj+0x40>)
	if (left > right) {
 80a336c:	bf88      	it	hi
 80a336e:	461d      	movhi	r5, r3
{
 80a3370:	4606      	mov	r6, r0
	String out;
 80a3372:	f7ff ff87 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
	if (left > len) return out;
 80a3376:	68bb      	ldr	r3, [r7, #8]
 80a3378:	42a3      	cmp	r3, r4
 80a337a:	d30a      	bcc.n	80a3392 <_ZNK6String9substringEjj+0x3a>
	if (right > len) right = len;
	out.copy(&buffer[left], right - left);
 80a337c:	6839      	ldr	r1, [r7, #0]
 80a337e:	42ab      	cmp	r3, r5
 80a3380:	bf94      	ite	ls
 80a3382:	ebc4 0203 	rsbls	r2, r4, r3
 80a3386:	ebc4 0205 	rsbhi	r2, r4, r5
 80a338a:	4630      	mov	r0, r6
 80a338c:	4421      	add	r1, r4
 80a338e:	f7ff ff61 	bl	80a3254 <_ZN6String4copyEPKcj>
	return out;
}
 80a3392:	4630      	mov	r0, r6
 80a3394:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a3396:	bf00      	nop
 80a3398:	080a6e7e 	.word	0x080a6e7e

080a339c <_ZNK6String9substringEj>:
{
 80a339c:	b510      	push	{r4, lr}
 80a339e:	4604      	mov	r4, r0
	return substring(left, len);
 80a33a0:	688b      	ldr	r3, [r1, #8]
 80a33a2:	f7ff ffd9 	bl	80a3358 <_ZNK6String9substringEjj>
}
 80a33a6:	4620      	mov	r0, r4
 80a33a8:	bd10      	pop	{r4, pc}

080a33aa <_ZNK6String5toIntEv>:
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
 80a33aa:	6800      	ldr	r0, [r0, #0]
 80a33ac:	b108      	cbz	r0, 80a33b2 <_ZNK6String5toIntEv+0x8>
 80a33ae:	f003 bbe7 	b.w	80a6b80 <atol>
	return 0;
}
 80a33b2:	4770      	bx	lr

080a33b4 <_ZN6String6formatEPKcz>:
    StringPrintableHelper help(*this);
    printable.printTo(help);
}

String String::format(const char* fmt, ...)
{
 80a33b4:	b40e      	push	{r1, r2, r3}
 80a33b6:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
 80a33b8:	ad09      	add	r5, sp, #36	; 0x24
 80a33ba:	f855 7b04 	ldr.w	r7, [r5], #4
 80a33be:	4604      	mov	r4, r0
    va_list marker;
    va_start(marker, fmt);
    const int bufsize = 5;
    char test[bufsize];
    size_t n = vsnprintf(test, bufsize, fmt, marker);
 80a33c0:	462b      	mov	r3, r5
 80a33c2:	463a      	mov	r2, r7
 80a33c4:	2105      	movs	r1, #5
 80a33c6:	a802      	add	r0, sp, #8
    va_start(marker, fmt);
 80a33c8:	9501      	str	r5, [sp, #4]
    size_t n = vsnprintf(test, bufsize, fmt, marker);
 80a33ca:	f7ff fe91 	bl	80a30f0 <vsnprintf>
 80a33ce:	4606      	mov	r6, r0
    va_end(marker);

    String result;
 80a33d0:	490b      	ldr	r1, [pc, #44]	; (80a3400 <_ZN6String6formatEPKcz+0x4c>)
 80a33d2:	4620      	mov	r0, r4
 80a33d4:	f7ff ff56 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
    result.reserve(n);  // internally adds +1 for null terminator
 80a33d8:	4631      	mov	r1, r6
 80a33da:	4620      	mov	r0, r4
 80a33dc:	f7ff ff26 	bl	80a322c <_ZN6String7reserveEj>
    if (result.buffer) {
 80a33e0:	6820      	ldr	r0, [r4, #0]
 80a33e2:	b130      	cbz	r0, 80a33f2 <_ZN6String6formatEPKcz+0x3e>
        va_start(marker, fmt);
        n = vsnprintf(result.buffer, n+1, fmt, marker);
 80a33e4:	462b      	mov	r3, r5
 80a33e6:	463a      	mov	r2, r7
 80a33e8:	1c71      	adds	r1, r6, #1
        va_start(marker, fmt);
 80a33ea:	9501      	str	r5, [sp, #4]
        n = vsnprintf(result.buffer, n+1, fmt, marker);
 80a33ec:	f7ff fe80 	bl	80a30f0 <vsnprintf>
        va_end(marker);
        result.len = n;
 80a33f0:	60a0      	str	r0, [r4, #8]
    }
    return result;
}
 80a33f2:	4620      	mov	r0, r4
 80a33f4:	b004      	add	sp, #16
 80a33f6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80a33fa:	b003      	add	sp, #12
 80a33fc:	4770      	bx	lr
 80a33fe:	bf00      	nop
 80a3400:	080a6e7e 	.word	0x080a6e7e

080a3404 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a3404:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3406:	4606      	mov	r6, r0
 80a3408:	460d      	mov	r5, r1
  size_t n = 0;
 80a340a:	2400      	movs	r4, #0
 80a340c:	188f      	adds	r7, r1, r2
  while (size--) {
 80a340e:	42bd      	cmp	r5, r7
 80a3410:	d00c      	beq.n	80a342c <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a3412:	6833      	ldr	r3, [r6, #0]
 80a3414:	4630      	mov	r0, r6
 80a3416:	689b      	ldr	r3, [r3, #8]
 80a3418:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a341c:	4798      	blx	r3
     if (chunk>=0)
 80a341e:	1e03      	subs	r3, r0, #0
 80a3420:	db01      	blt.n	80a3426 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a3422:	441c      	add	r4, r3
  while (size--) {
 80a3424:	e7f3      	b.n	80a340e <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a3426:	2c00      	cmp	r4, #0
 80a3428:	bf08      	it	eq
 80a342a:	461c      	moveq	r4, r3
             n = chunk;
         break;
     }
  }
  return n;
}
 80a342c:	4620      	mov	r0, r4
 80a342e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3430 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a3430:	b570      	push	{r4, r5, r6, lr}
 80a3432:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a3434:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a3436:	4608      	mov	r0, r1
      if (str == NULL) return 0;
 80a3438:	b149      	cbz	r1, 80a344e <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a343a:	f003 fc1c 	bl	80a6c76 <strlen>
 80a343e:	682b      	ldr	r3, [r5, #0]
 80a3440:	4602      	mov	r2, r0
 80a3442:	4621      	mov	r1, r4
 80a3444:	4628      	mov	r0, r5
    }
 80a3446:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      return write((const uint8_t *)str, strlen(str));
 80a344a:	68db      	ldr	r3, [r3, #12]
 80a344c:	4718      	bx	r3
    }
 80a344e:	bd70      	pop	{r4, r5, r6, pc}

080a3450 <_ZN5Print5printEPKc>:

size_t Print::print(const char str[])
{
 80a3450:	b508      	push	{r3, lr}
  return write(str);
 80a3452:	f7ff ffed 	bl	80a3430 <_ZN5Print5writeEPKc>
}
 80a3456:	bd08      	pop	{r3, pc}

080a3458 <_ZN5Print5printEc>:

size_t Print::print(char c)
{
  return write(c);
 80a3458:	6803      	ldr	r3, [r0, #0]
 80a345a:	689b      	ldr	r3, [r3, #8]
 80a345c:	4718      	bx	r3

080a345e <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a345e:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a3460:	210d      	movs	r1, #13
{
 80a3462:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a3464:	f7ff fff8 	bl	80a3458 <_ZN5Print5printEc>
  n += print('\n');
 80a3468:	210a      	movs	r1, #10
  size_t n = print('\r');
 80a346a:	4604      	mov	r4, r0
  n += print('\n');
 80a346c:	4628      	mov	r0, r5
 80a346e:	f7ff fff3 	bl	80a3458 <_ZN5Print5printEc>
  return n;
}
 80a3472:	4420      	add	r0, r4
 80a3474:	bd38      	pop	{r3, r4, r5, pc}

080a3476 <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a3476:	b538      	push	{r3, r4, r5, lr}
 80a3478:	4605      	mov	r5, r0
  return write(str);
 80a347a:	f7ff ffd9 	bl	80a3430 <_ZN5Print5writeEPKc>
 80a347e:	4604      	mov	r4, r0
  size_t n = print(c);
  n += println();
 80a3480:	4628      	mov	r0, r5
 80a3482:	f7ff ffec 	bl	80a345e <_ZN5Print7printlnEv>
  return n;
}
 80a3486:	4420      	add	r0, r4
 80a3488:	bd38      	pop	{r3, r4, r5, pc}

080a348a <_ZN5Print11printNumberEmh>:

size_t Print::printNumber(unsigned long n, uint8_t base) {
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a348a:	2300      	movs	r3, #0

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a348c:	2a01      	cmp	r2, #1
 80a348e:	bf98      	it	ls
 80a3490:	220a      	movls	r2, #10
size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a3492:	b530      	push	{r4, r5, lr}
 80a3494:	b08b      	sub	sp, #44	; 0x2c
 80a3496:	460c      	mov	r4, r1
  *str = '\0';
 80a3498:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
  if (base < 2) base = 10;
 80a349c:	a909      	add	r1, sp, #36	; 0x24

  do {
   decltype(n) m = n;
   n /= base;
 80a349e:	4625      	mov	r5, r4
 80a34a0:	fbb4 f4f2 	udiv	r4, r4, r2
   char c = m - base * n;
 80a34a4:	fb04 5312 	mls	r3, r4, r2, r5
 80a34a8:	b2db      	uxtb	r3, r3
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a34aa:	2b09      	cmp	r3, #9
 80a34ac:	bf94      	ite	ls
 80a34ae:	3330      	addls	r3, #48	; 0x30
 80a34b0:	3337      	addhi	r3, #55	; 0x37
 80a34b2:	b2db      	uxtb	r3, r3
  } while(n);
 80a34b4:	42aa      	cmp	r2, r5
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a34b6:	f801 3d01 	strb.w	r3, [r1, #-1]!
  } while(n);
 80a34ba:	d9f0      	bls.n	80a349e <_ZN5Print11printNumberEmh+0x14>

  return write(str);
 80a34bc:	f7ff ffb8 	bl	80a3430 <_ZN5Print5writeEPKc>
}
 80a34c0:	b00b      	add	sp, #44	; 0x2c
 80a34c2:	bd30      	pop	{r4, r5, pc}

080a34c4 <_ZN5Print10printFloatEdh>:

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
 80a34c4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a34c8:	4605      	mov	r5, r0
  size_t n = 0;

  if (isnan(number)) return print("nan");
 80a34ca:	4619      	mov	r1, r3
 80a34cc:	4610      	mov	r0, r2
{
 80a34ce:	4692      	mov	sl, r2
 80a34d0:	461f      	mov	r7, r3
 80a34d2:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
  if (isnan(number)) return print("nan");
 80a34d6:	f002 ff87 	bl	80a63e8 <__aeabi_dcmpun>
 80a34da:	b140      	cbz	r0, 80a34ee <_ZN5Print10printFloatEdh+0x2a>
  return write(str);
 80a34dc:	4951      	ldr	r1, [pc, #324]	; (80a3624 <_ZN5Print10printFloatEdh+0x160>)
 80a34de:	4628      	mov	r0, r5
 80a34e0:	f7ff ffa6 	bl	80a3430 <_ZN5Print5writeEPKc>
 80a34e4:	4604      	mov	r4, r0
    n += print(toPrint);
    remainder -= toPrint;
  }

  return n;
}
 80a34e6:	4620      	mov	r0, r4
 80a34e8:	b003      	add	sp, #12
 80a34ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  && !_GLIBCXX_NO_OBSOLETE_ISINF_ISNAN_DYNAMIC
  using ::isinf;
#else
  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }
 80a34ee:	f027 4400 	bic.w	r4, r7, #2147483648	; 0x80000000
  if (isinf(number)) return print("inf");
 80a34f2:	f04f 32ff 	mov.w	r2, #4294967295
 80a34f6:	4650      	mov	r0, sl
 80a34f8:	4621      	mov	r1, r4
 80a34fa:	4b4b      	ldr	r3, [pc, #300]	; (80a3628 <_ZN5Print10printFloatEdh+0x164>)
 80a34fc:	f002 ff74 	bl	80a63e8 <__aeabi_dcmpun>
 80a3500:	b948      	cbnz	r0, 80a3516 <_ZN5Print10printFloatEdh+0x52>
 80a3502:	f04f 32ff 	mov.w	r2, #4294967295
 80a3506:	4650      	mov	r0, sl
 80a3508:	4621      	mov	r1, r4
 80a350a:	4b47      	ldr	r3, [pc, #284]	; (80a3628 <_ZN5Print10printFloatEdh+0x164>)
 80a350c:	f002 ff4e 	bl	80a63ac <__aeabi_dcmple>
 80a3510:	b908      	cbnz	r0, 80a3516 <_ZN5Print10printFloatEdh+0x52>
  return write(str);
 80a3512:	4946      	ldr	r1, [pc, #280]	; (80a362c <_ZN5Print10printFloatEdh+0x168>)
 80a3514:	e7e3      	b.n	80a34de <_ZN5Print10printFloatEdh+0x1a>
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
 80a3516:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80a351a:	4650      	mov	r0, sl
 80a351c:	4639      	mov	r1, r7
 80a351e:	4b44      	ldr	r3, [pc, #272]	; (80a3630 <_ZN5Print10printFloatEdh+0x16c>)
 80a3520:	f002 ff58 	bl	80a63d4 <__aeabi_dcmpgt>
 80a3524:	b108      	cbz	r0, 80a352a <_ZN5Print10printFloatEdh+0x66>
  return write(str);
 80a3526:	4943      	ldr	r1, [pc, #268]	; (80a3634 <_ZN5Print10printFloatEdh+0x170>)
 80a3528:	e7d9      	b.n	80a34de <_ZN5Print10printFloatEdh+0x1a>
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
 80a352a:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80a352e:	4650      	mov	r0, sl
 80a3530:	4639      	mov	r1, r7
 80a3532:	4b41      	ldr	r3, [pc, #260]	; (80a3638 <_ZN5Print10printFloatEdh+0x174>)
 80a3534:	f002 ff30 	bl	80a6398 <__aeabi_dcmplt>
 80a3538:	2800      	cmp	r0, #0
 80a353a:	d1f4      	bne.n	80a3526 <_ZN5Print10printFloatEdh+0x62>
  if (number < 0.0)
 80a353c:	2200      	movs	r2, #0
 80a353e:	2300      	movs	r3, #0
 80a3540:	4650      	mov	r0, sl
 80a3542:	4639      	mov	r1, r7
 80a3544:	f002 ff28 	bl	80a6398 <__aeabi_dcmplt>
 80a3548:	4604      	mov	r4, r0
 80a354a:	b130      	cbz	r0, 80a355a <_ZN5Print10printFloatEdh+0x96>
     n += print('-');
 80a354c:	212d      	movs	r1, #45	; 0x2d
 80a354e:	4628      	mov	r0, r5
 80a3550:	f7ff ff82 	bl	80a3458 <_ZN5Print5printEc>
 80a3554:	4604      	mov	r4, r0
     number = -number;
 80a3556:	f107 4700 	add.w	r7, r7, #2147483648	; 0x80000000
  size_t n = 0;
 80a355a:	f04f 0b00 	mov.w	fp, #0
  double rounding = 0.5;
 80a355e:	2000      	movs	r0, #0
    rounding /= 10.0;
 80a3560:	f04f 0800 	mov.w	r8, #0
  double rounding = 0.5;
 80a3564:	4935      	ldr	r1, [pc, #212]	; (80a363c <_ZN5Print10printFloatEdh+0x178>)
    rounding /= 10.0;
 80a3566:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 80a3640 <_ZN5Print10printFloatEdh+0x17c>
  for (uint8_t i=0; i<digits; ++i)
 80a356a:	fa5f f38b 	uxtb.w	r3, fp
 80a356e:	429e      	cmp	r6, r3
 80a3570:	d906      	bls.n	80a3580 <_ZN5Print10printFloatEdh+0xbc>
    rounding /= 10.0;
 80a3572:	4642      	mov	r2, r8
 80a3574:	464b      	mov	r3, r9
 80a3576:	f002 fdc7 	bl	80a6108 <__aeabi_ddiv>
  for (uint8_t i=0; i<digits; ++i)
 80a357a:	f10b 0b01 	add.w	fp, fp, #1
 80a357e:	e7f4      	b.n	80a356a <_ZN5Print10printFloatEdh+0xa6>
  number += rounding;
 80a3580:	463b      	mov	r3, r7
 80a3582:	4652      	mov	r2, sl
 80a3584:	f002 fae0 	bl	80a5b48 <__adddf3>
 80a3588:	4689      	mov	r9, r1
 80a358a:	4680      	mov	r8, r0
  unsigned long int_part = (unsigned long)number;
 80a358c:	f002 ff6a 	bl	80a6464 <__aeabi_d2uiz>
 80a3590:	4607      	mov	r7, r0
  double remainder = number - (double)int_part;
 80a3592:	f002 fc15 	bl	80a5dc0 <__aeabi_ui2d>
 80a3596:	4602      	mov	r2, r0
 80a3598:	460b      	mov	r3, r1
 80a359a:	4640      	mov	r0, r8
 80a359c:	4649      	mov	r1, r9
 80a359e:	f002 fad1 	bl	80a5b44 <__aeabi_dsub>
            val = n;
        }
#if __GNUC__ >= 9
#pragma GCC diagnostic pop
#endif // __GNUC__ >= 9
        return printNumber(val, base) + t;
 80a35a2:	220a      	movs	r2, #10
 80a35a4:	4680      	mov	r8, r0
 80a35a6:	4689      	mov	r9, r1
 80a35a8:	4628      	mov	r0, r5
 80a35aa:	4639      	mov	r1, r7
 80a35ac:	f7ff ff6d 	bl	80a348a <_ZN5Print11printNumberEmh>
  n += print(int_part);
 80a35b0:	4404      	add	r4, r0
  if (digits > 0) {
 80a35b2:	2e00      	cmp	r6, #0
 80a35b4:	d097      	beq.n	80a34e6 <_ZN5Print10printFloatEdh+0x22>
  return write(str);
 80a35b6:	4628      	mov	r0, r5
 80a35b8:	4922      	ldr	r1, [pc, #136]	; (80a3644 <_ZN5Print10printFloatEdh+0x180>)
 80a35ba:	f7ff ff39 	bl	80a3430 <_ZN5Print5writeEPKc>
    remainder *= 10.0;
 80a35be:	f04f 0a00 	mov.w	sl, #0
 80a35c2:	f8df b07c 	ldr.w	fp, [pc, #124]	; 80a3640 <_ZN5Print10printFloatEdh+0x17c>
    n += print(".");
 80a35c6:	4404      	add	r4, r0
  while (digits-- > 0)
 80a35c8:	2e00      	cmp	r6, #0
 80a35ca:	d08c      	beq.n	80a34e6 <_ZN5Print10printFloatEdh+0x22>
    remainder *= 10.0;
 80a35cc:	4652      	mov	r2, sl
 80a35ce:	465b      	mov	r3, fp
 80a35d0:	4640      	mov	r0, r8
 80a35d2:	4649      	mov	r1, r9
 80a35d4:	f002 fc6e 	bl	80a5eb4 <__aeabi_dmul>
 80a35d8:	4680      	mov	r8, r0
 80a35da:	4689      	mov	r9, r1
    int toPrint = int(remainder);
 80a35dc:	f002 ff1a 	bl	80a6414 <__aeabi_d2iz>
        if (n < 0 && base == 10) {
 80a35e0:	1e07      	subs	r7, r0, #0
 80a35e2:	da1b      	bge.n	80a361c <_ZN5Print10printFloatEdh+0x158>
            t = print('-');
 80a35e4:	212d      	movs	r1, #45	; 0x2d
 80a35e6:	4628      	mov	r0, r5
 80a35e8:	f7ff ff36 	bl	80a3458 <_ZN5Print5printEc>
 80a35ec:	4603      	mov	r3, r0
            val = -n;
 80a35ee:	4279      	negs	r1, r7
        return printNumber(val, base) + t;
 80a35f0:	220a      	movs	r2, #10
 80a35f2:	4628      	mov	r0, r5
 80a35f4:	9301      	str	r3, [sp, #4]
 80a35f6:	f7ff ff48 	bl	80a348a <_ZN5Print11printNumberEmh>
 80a35fa:	9b01      	ldr	r3, [sp, #4]
 80a35fc:	3e01      	subs	r6, #1
 80a35fe:	4403      	add	r3, r0
    remainder -= toPrint;
 80a3600:	4638      	mov	r0, r7
    n += print(toPrint);
 80a3602:	441c      	add	r4, r3
    remainder -= toPrint;
 80a3604:	f002 fbec 	bl	80a5de0 <__aeabi_i2d>
 80a3608:	4602      	mov	r2, r0
 80a360a:	460b      	mov	r3, r1
 80a360c:	4640      	mov	r0, r8
 80a360e:	4649      	mov	r1, r9
 80a3610:	f002 fa98 	bl	80a5b44 <__aeabi_dsub>
 80a3614:	b2f6      	uxtb	r6, r6
 80a3616:	4680      	mov	r8, r0
 80a3618:	4689      	mov	r9, r1
  while (digits-- > 0)
 80a361a:	e7d5      	b.n	80a35c8 <_ZN5Print10printFloatEdh+0x104>
            val = n;
 80a361c:	4639      	mov	r1, r7
        size_t t = 0;
 80a361e:	2300      	movs	r3, #0
 80a3620:	e7e6      	b.n	80a35f0 <_ZN5Print10printFloatEdh+0x12c>
 80a3622:	bf00      	nop
 80a3624:	080a72d9 	.word	0x080a72d9
 80a3628:	7fefffff 	.word	0x7fefffff
 80a362c:	080a72dd 	.word	0x080a72dd
 80a3630:	41efffff 	.word	0x41efffff
 80a3634:	080a72e1 	.word	0x080a72e1
 80a3638:	c1efffff 	.word	0xc1efffff
 80a363c:	3fe00000 	.word	0x3fe00000
 80a3640:	40240000 	.word	0x40240000
 80a3644:	080a7070 	.word	0x080a7070

080a3648 <_ZN5Print5printEdi>:
  return printFloat(n, digits);
 80a3648:	f89d 1000 	ldrb.w	r1, [sp]
 80a364c:	9100      	str	r1, [sp, #0]
 80a364e:	f7ff bf39 	b.w	80a34c4 <_ZN5Print10printFloatEdh>

080a3652 <_ZN5spark9WiFiClass2onEv>:
    WiFiClass() :
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
    }

    void on(void) {
        network_on(*this, 0, 0, NULL);
 80a3652:	2300      	movs	r3, #0
 80a3654:	6840      	ldr	r0, [r0, #4]
 80a3656:	461a      	mov	r2, r3
 80a3658:	4619      	mov	r1, r3
 80a365a:	f7ff bca9 	b.w	80a2fb0 <network_on>
	...

080a3660 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a3660:	4b01      	ldr	r3, [pc, #4]	; (80a3668 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a3662:	4a02      	ldr	r2, [pc, #8]	; (80a366c <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a3664:	601a      	str	r2, [r3, #0]
#if Wiring_LogConfig

// spark::
void spark::logProcessControlRequest(ctrl_request* req) {
    JSONRequestHandler::process(req);
}
 80a3666:	4770      	bx	lr
 80a3668:	20000560 	.word	0x20000560
 80a366c:	080a72e5 	.word	0x080a72e5

080a3670 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a3670:	4b02      	ldr	r3, [pc, #8]	; (80a367c <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a3672:	681a      	ldr	r2, [r3, #0]
 80a3674:	4b02      	ldr	r3, [pc, #8]	; (80a3680 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a3676:	601a      	str	r2, [r3, #0]
{
  return isValid();
}


TimeClass Time;
 80a3678:	4770      	bx	lr
 80a367a:	bf00      	nop
 80a367c:	2000001c 	.word	0x2000001c
 80a3680:	20000564 	.word	0x20000564

080a3684 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a3684:	2100      	movs	r1, #0
 80a3686:	f7ff bc3d 	b.w	80a2f04 <system_delay_ms>

080a368a <_ZNSt14_Function_baseD1Ev>:
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a368a:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a368c:	6883      	ldr	r3, [r0, #8]
    ~_Function_base()
 80a368e:	4604      	mov	r4, r0
      if (_M_manager)
 80a3690:	b113      	cbz	r3, 80a3698 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a3692:	2203      	movs	r2, #3
 80a3694:	4601      	mov	r1, r0
 80a3696:	4798      	blx	r3
    }
 80a3698:	4620      	mov	r0, r4
 80a369a:	bd10      	pop	{r4, pc}

080a369c <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a369c:	b510      	push	{r4, lr}
 80a369e:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a36a0:	f7ff fff3 	bl	80a368a <_ZNSt14_Function_baseD1Ev>
 80a36a4:	4620      	mov	r0, r4
 80a36a6:	bd10      	pop	{r4, pc}

080a36a8 <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>:
			      is_move_constructible<_Tp>,
			      is_move_assignable<_Tp>>::value>::type
#else
    void
#endif
    swap(_Tp& __a, _Tp& __b)
 80a36a8:	b513      	push	{r0, r1, r4, lr}
    {
#if __cplusplus < 201103L
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
#endif
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a36aa:	466c      	mov	r4, sp
    swap(_Tp& __a, _Tp& __b)
 80a36ac:	460b      	mov	r3, r1
 80a36ae:	4602      	mov	r2, r0
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a36b0:	c803      	ldmia	r0, {r0, r1}
 80a36b2:	e884 0003 	stmia.w	r4, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a36b6:	e893 0003 	ldmia.w	r3, {r0, r1}
 80a36ba:	e882 0003 	stmia.w	r2, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a36be:	e894 0003 	ldmia.w	r4, {r0, r1}
 80a36c2:	e883 0003 	stmia.w	r3, {r0, r1}
    }
 80a36c6:	b002      	add	sp, #8
 80a36c8:	bd10      	pop	{r4, pc}
	...

080a36cc <_GLOBAL__sub_I_RGB>:
    _Function_base() : _M_manager(nullptr) { }
 80a36cc:	2300      	movs	r3, #0
 80a36ce:	4803      	ldr	r0, [pc, #12]	; (80a36dc <_GLOBAL__sub_I_RGB+0x10>)
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a36d0:	4a03      	ldr	r2, [pc, #12]	; (80a36e0 <_GLOBAL__sub_I_RGB+0x14>)
 80a36d2:	4904      	ldr	r1, [pc, #16]	; (80a36e4 <_GLOBAL__sub_I_RGB+0x18>)
 80a36d4:	6083      	str	r3, [r0, #8]
 80a36d6:	f000 bfd1 	b.w	80a467c <__aeabi_atexit>
 80a36da:	bf00      	nop
 80a36dc:	20000568 	.word	0x20000568
 80a36e0:	20000088 	.word	0x20000088
 80a36e4:	080a369d 	.word	0x080a369d

080a36e8 <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_>:

void module_user_init_hook()
{
#if HAL_PLATFORM_NEWLIB
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
        _impure_ptr = r;
 80a36e8:	4b01      	ldr	r3, [pc, #4]	; (80a36f0 <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_+0x8>)
 80a36ea:	6018      	str	r0, [r3, #0]
    }, nullptr);
 80a36ec:	4770      	bx	lr
 80a36ee:	bf00      	nop
 80a36f0:	20000024 	.word	0x20000024

080a36f4 <serialEventRun>:
{
 80a36f4:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a36f6:	4b13      	ldr	r3, [pc, #76]	; (80a3744 <serialEventRun+0x50>)
 80a36f8:	b143      	cbz	r3, 80a370c <serialEventRun+0x18>
 80a36fa:	f000 fc23 	bl	80a3f44 <_Z16_fetch_usbserialv>
 80a36fe:	6803      	ldr	r3, [r0, #0]
 80a3700:	691b      	ldr	r3, [r3, #16]
 80a3702:	4798      	blx	r3
 80a3704:	2800      	cmp	r0, #0
 80a3706:	dd01      	ble.n	80a370c <serialEventRun+0x18>
        serialEvent();
 80a3708:	f3af 8000 	nop.w
    if (serialEvent1 && Serial1.available()>0)
 80a370c:	4b0e      	ldr	r3, [pc, #56]	; (80a3748 <serialEventRun+0x54>)
 80a370e:	b143      	cbz	r3, 80a3722 <serialEventRun+0x2e>
 80a3710:	f000 fcfa 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a3714:	6803      	ldr	r3, [r0, #0]
 80a3716:	691b      	ldr	r3, [r3, #16]
 80a3718:	4798      	blx	r3
 80a371a:	2800      	cmp	r0, #0
 80a371c:	dd01      	ble.n	80a3722 <serialEventRun+0x2e>
        serialEvent1();
 80a371e:	f3af 8000 	nop.w
    if (serialEventRun2) serialEventRun2();
 80a3722:	4b0a      	ldr	r3, [pc, #40]	; (80a374c <serialEventRun+0x58>)
 80a3724:	b10b      	cbz	r3, 80a372a <serialEventRun+0x36>
 80a3726:	f3af 8000 	nop.w
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a372a:	4b09      	ldr	r3, [pc, #36]	; (80a3750 <serialEventRun+0x5c>)
 80a372c:	b143      	cbz	r3, 80a3740 <serialEventRun+0x4c>
 80a372e:	f000 fc39 	bl	80a3fa4 <_Z17_fetch_usbserial1v>
 80a3732:	6803      	ldr	r3, [r0, #0]
 80a3734:	691b      	ldr	r3, [r3, #16]
 80a3736:	4798      	blx	r3
 80a3738:	2800      	cmp	r0, #0
 80a373a:	dd01      	ble.n	80a3740 <serialEventRun+0x4c>
        usbSerialEvent1();
 80a373c:	f3af 8000 	nop.w
}
 80a3740:	bd08      	pop	{r3, pc}
 80a3742:	bf00      	nop
	...

080a3754 <_post_loop>:
{
 80a3754:	b508      	push	{r3, lr}
	serialEventRun();
 80a3756:	f7ff ffcd 	bl	80a36f4 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a375a:	f7ff fac7 	bl	80a2cec <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a375e:	4b01      	ldr	r3, [pc, #4]	; (80a3764 <_post_loop+0x10>)
 80a3760:	6018      	str	r0, [r3, #0]
}
 80a3762:	bd08      	pop	{r3, pc}
 80a3764:	200005f0 	.word	0x200005f0

080a3768 <_Z33system_initialize_user_backup_ramv>:
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a3768:	4805      	ldr	r0, [pc, #20]	; (80a3780 <_Z33system_initialize_user_backup_ramv+0x18>)
 80a376a:	4a06      	ldr	r2, [pc, #24]	; (80a3784 <_Z33system_initialize_user_backup_ramv+0x1c>)
{
 80a376c:	b508      	push	{r3, lr}
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a376e:	1a12      	subs	r2, r2, r0
 80a3770:	4905      	ldr	r1, [pc, #20]	; (80a3788 <_Z33system_initialize_user_backup_ramv+0x20>)
 80a3772:	f003 fa17 	bl	80a6ba4 <memcpy>
    __backup_sram_signature = signature;
 80a3776:	4b05      	ldr	r3, [pc, #20]	; (80a378c <_Z33system_initialize_user_backup_ramv+0x24>)
 80a3778:	4a05      	ldr	r2, [pc, #20]	; (80a3790 <_Z33system_initialize_user_backup_ramv+0x28>)
 80a377a:	601a      	str	r2, [r3, #0]
}
 80a377c:	bd08      	pop	{r3, pc}
 80a377e:	bf00      	nop
 80a3780:	40024000 	.word	0x40024000
 80a3784:	40024004 	.word	0x40024004
 80a3788:	080a7610 	.word	0x080a7610
 80a378c:	40024000 	.word	0x40024000
 80a3790:	9a271c1e 	.word	0x9a271c1e

080a3794 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a3794:	2300      	movs	r3, #0
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a3796:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a3798:	461a      	mov	r2, r3
 80a379a:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a379e:	9300      	str	r3, [sp, #0]
 80a37a0:	f7ff fbd2 	bl	80a2f48 <system_ctrl_set_result>
}
 80a37a4:	b003      	add	sp, #12
 80a37a6:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a37ac <_ZL20ctrl_request_handlerP12ctrl_request>:
static void ctrl_request_handler(ctrl_request* req) {
 80a37ac:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a37ae:	8843      	ldrh	r3, [r0, #2]
 80a37b0:	2b0a      	cmp	r3, #10
 80a37b2:	d008      	beq.n	80a37c6 <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a37b4:	2b50      	cmp	r3, #80	; 0x50
 80a37b6:	d10b      	bne.n	80a37d0 <_ZL20ctrl_request_handlerP12ctrl_request+0x24>
        if (log_process_ctrl_request_callback) {
 80a37b8:	4b09      	ldr	r3, [pc, #36]	; (80a37e0 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a37ba:	681b      	ldr	r3, [r3, #0]
 80a37bc:	b14b      	cbz	r3, 80a37d2 <_ZL20ctrl_request_handlerP12ctrl_request+0x26>
}
 80a37be:	b003      	add	sp, #12
 80a37c0:	f85d eb04 	ldr.w	lr, [sp], #4
            log_process_ctrl_request_callback(req);
 80a37c4:	4718      	bx	r3
        ctrl_request_custom_handler(req);
 80a37c6:	f7ff ffe5 	bl	80a3794 <_Z27ctrl_request_custom_handlerP12ctrl_request>
}
 80a37ca:	b003      	add	sp, #12
 80a37cc:	f85d fb04 	ldr.w	pc, [sp], #4
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a37d0:	2300      	movs	r3, #0
 80a37d2:	461a      	mov	r2, r3
 80a37d4:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a37d8:	9300      	str	r3, [sp, #0]
 80a37da:	f7ff fbb5 	bl	80a2f48 <system_ctrl_set_result>
}
 80a37de:	e7f4      	b.n	80a37ca <_ZL20ctrl_request_handlerP12ctrl_request+0x1e>
 80a37e0:	2000057c 	.word	0x2000057c

080a37e4 <module_user_init_hook>:
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
 80a37e4:	2100      	movs	r1, #0
{
 80a37e6:	b510      	push	{r4, lr}
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
 80a37e8:	4811      	ldr	r0, [pc, #68]	; (80a3830 <module_user_init_hook+0x4c>)
 80a37ea:	f7ff fca9 	bl	80a3140 <newlib_impure_ptr_callback>
#endif // HAL_PLATFORM_NEWLIB

#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ = __backup_sram_signature == signature;
 80a37ee:	4b11      	ldr	r3, [pc, #68]	; (80a3834 <module_user_init_hook+0x50>)
 80a37f0:	681a      	ldr	r2, [r3, #0]
 80a37f2:	4b11      	ldr	r3, [pc, #68]	; (80a3838 <module_user_init_hook+0x54>)
 80a37f4:	429a      	cmp	r2, r3
 80a37f6:	bf0c      	ite	eq
 80a37f8:	2201      	moveq	r2, #1
 80a37fa:	2200      	movne	r2, #0
 80a37fc:	4b0f      	ldr	r3, [pc, #60]	; (80a383c <module_user_init_hook+0x58>)
 80a37fe:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a3800:	d001      	beq.n	80a3806 <module_user_init_hook+0x22>
        system_initialize_user_backup_ram();
 80a3802:	f7ff ffb1 	bl	80a3768 <_Z33system_initialize_user_backup_ramv>
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
 80a3806:	f7ff fa61 	bl	80a2ccc <HAL_RNG_GetRandomNumber>
 80a380a:	4604      	mov	r4, r0
    srand(seed);
 80a380c:	f003 f9e0 	bl	80a6bd0 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a3810:	4b0b      	ldr	r3, [pc, #44]	; (80a3840 <module_user_init_hook+0x5c>)
 80a3812:	b113      	cbz	r3, 80a381a <module_user_init_hook+0x36>
        random_seed_from_cloud(seed);
 80a3814:	4620      	mov	r0, r4
 80a3816:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a381a:	2100      	movs	r1, #0
 80a381c:	4808      	ldr	r0, [pc, #32]	; (80a3840 <module_user_init_hook+0x5c>)
 80a381e:	f7ff fc3f 	bl	80a30a0 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a3822:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a3826:	2100      	movs	r1, #0
 80a3828:	4806      	ldr	r0, [pc, #24]	; (80a3844 <module_user_init_hook+0x60>)
 80a382a:	f7ff bb83 	b.w	80a2f34 <system_ctrl_set_app_request_handler>
 80a382e:	bf00      	nop
 80a3830:	080a36e9 	.word	0x080a36e9
 80a3834:	40024000 	.word	0x40024000
 80a3838:	9a271c1e 	.word	0x9a271c1e
 80a383c:	20000578 	.word	0x20000578
 80a3840:	00000000 	.word	0x00000000
 80a3844:	080a37ad 	.word	0x080a37ad

080a3848 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a3848:	4770      	bx	lr

080a384a <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      { return nullptr; }
 80a384a:	2000      	movs	r0, #0
 80a384c:	4770      	bx	lr

080a384e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a384e:	b510      	push	{r4, lr}
 80a3850:	4604      	mov	r4, r0
 80a3852:	2110      	movs	r1, #16
 80a3854:	f000 ff17 	bl	80a4686 <_ZdlPvj>
 80a3858:	4620      	mov	r0, r4
 80a385a:	bd10      	pop	{r4, pc}

080a385c <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      _M_destroy() noexcept
 80a385c:	b508      	push	{r3, lr}
      { delete this; }
 80a385e:	f7ff fff6 	bl	80a384e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>
 80a3862:	bd08      	pop	{r3, pc}

080a3864 <_ZN8particle5ErrorC1EOS0_>:

} // namespace particle

inline particle::Error::Error(Type type) :
        msg_(nullptr),
        type_(type) {
 80a3864:	2200      	movs	r2, #0

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
}

inline particle::Error::Error(Error&& error) :
 80a3866:	b530      	push	{r4, r5, lr}
        type_(type) {
 80a3868:	f64f 749c 	movw	r4, #65436	; 0xff9c
 80a386c:	6002      	str	r2, [r0, #0]
 80a386e:	8084      	strh	r4, [r0, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a3870:	888d      	ldrh	r5, [r1, #4]
      __b = _GLIBCXX_MOVE(__tmp);
 80a3872:	808c      	strh	r4, [r1, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a3874:	680c      	ldr	r4, [r1, #0]
 80a3876:	8085      	strh	r5, [r0, #4]
 80a3878:	6004      	str	r4, [r0, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 80a387a:	600a      	str	r2, [r1, #0]
        Error() {
    swap(*this, error);
}
 80a387c:	bd30      	pop	{r4, r5, pc}

080a387e <_ZN8particle5ErrorD1Ev>:

inline particle::Error::~Error() {
 80a387e:	b510      	push	{r4, lr}
 80a3880:	4604      	mov	r4, r0
    free((void*)msg_);
 80a3882:	6800      	ldr	r0, [r0, #0]
 80a3884:	f7ff fc1c 	bl	80a30c0 <free>
}
 80a3888:	4620      	mov	r0, r4
 80a388a:	bd10      	pop	{r4, pc}

080a388c <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
 80a388c:	b538      	push	{r3, r4, r5, lr}
      { delete _M_ptr; }
 80a388e:	68c4      	ldr	r4, [r0, #12]
 80a3890:	b1f4      	cbz	r4, 80a38d0 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x44>
 80a3892:	7823      	ldrb	r3, [r4, #0]
    ~FutureImpl() {
        // Call destructor of the appropriate unnamed enum's field
        const State s = this->state();
        if (s == State::SUCCEEDED) {
            result_.~ResultT();
        } else if (s == State::FAILED) {
 80a3894:	2b02      	cmp	r3, #2
 80a3896:	d103      	bne.n	80a38a0 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x14>
            error_.~Error();
 80a3898:	f104 000c 	add.w	r0, r4, #12
 80a389c:	f7ff ffef 	bl	80a387e <_ZN8particle5ErrorD1Ev>
      {
	memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_p, int(__m));
 80a38a0:	6865      	ldr	r5, [r4, #4]
        delete onSuccess_.load(std::memory_order_relaxed);
 80a38a2:	b135      	cbz	r5, 80a38b2 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x26>
    class function<_Res(_ArgTypes...)>
 80a38a4:	4628      	mov	r0, r5
 80a38a6:	f7ff fef0 	bl	80a368a <_ZNSt14_Function_baseD1Ev>
 80a38aa:	2110      	movs	r1, #16
 80a38ac:	4628      	mov	r0, r5
 80a38ae:	f000 feea 	bl	80a4686 <_ZdlPvj>
 80a38b2:	68a5      	ldr	r5, [r4, #8]
        delete onError_.load(std::memory_order_relaxed);
 80a38b4:	b135      	cbz	r5, 80a38c4 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x38>
 80a38b6:	4628      	mov	r0, r5
 80a38b8:	f7ff fee7 	bl	80a368a <_ZNSt14_Function_baseD1Ev>
 80a38bc:	2110      	movs	r1, #16
 80a38be:	4628      	mov	r0, r5
 80a38c0:	f000 fee1 	bl	80a4686 <_ZdlPvj>
 80a38c4:	4620      	mov	r0, r4
 80a38c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a38ca:	2114      	movs	r1, #20
 80a38cc:	f000 bedb 	b.w	80a4686 <_ZdlPvj>
 80a38d0:	bd38      	pop	{r3, r4, r5, pc}

080a38d2 <_ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
    }
    return CloudDisconnectOptions(options->flags, options->timeout, options->graceful, clearSession);
}

int CloudClass::call_raw_user_function(void* data, const char* param, void* reserved)
{
 80a38d2:	b510      	push	{r4, lr}
 80a38d4:	b088      	sub	sp, #32
 80a38d6:	4604      	mov	r4, r0
    user_function_int_str_t* fn = (user_function_int_str_t*)(data);
    String p(param);
 80a38d8:	4668      	mov	r0, sp
 80a38da:	f7ff fcd3 	bl	80a3284 <_ZN6StringC1EPK19__FlashStringHelper>
    return (*fn)(p);
 80a38de:	4669      	mov	r1, sp
 80a38e0:	a804      	add	r0, sp, #16
 80a38e2:	f7ff fcf1 	bl	80a32c8 <_ZN6StringC1ERKS_>
 80a38e6:	a804      	add	r0, sp, #16
 80a38e8:	47a0      	blx	r4
 80a38ea:	4604      	mov	r4, r0
 80a38ec:	a804      	add	r0, sp, #16
 80a38ee:	f7ff fc7f 	bl	80a31f0 <_ZN6StringD1Ev>
    String p(param);
 80a38f2:	4668      	mov	r0, sp
 80a38f4:	f7ff fc7c 	bl	80a31f0 <_ZN6StringD1Ev>
}
 80a38f8:	4620      	mov	r0, r4
 80a38fa:	b008      	add	sp, #32
 80a38fc:	bd10      	pop	{r4, pc}

080a38fe <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
 80a38fe:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
 80a3900:	2300      	movs	r3, #0
         size = sizeof(*this);
 80a3902:	2410      	movs	r4, #16
    cloud_function_descriptor desc = {};
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
 80a3904:	e9cd 0102 	strd	r0, r1, [sp, #8]
    desc.funcKey = funcKey;
 80a3908:	9201      	str	r2, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a390a:	4669      	mov	r1, sp
 80a390c:	461a      	mov	r2, r3
 80a390e:	4618      	mov	r0, r3
         memset(this, 0, sizeof(*this));
 80a3910:	f8ad 3002 	strh.w	r3, [sp, #2]
         size = sizeof(*this);
 80a3914:	f8ad 4000 	strh.w	r4, [sp]
 80a3918:	f7ff fb92 	bl	80a3040 <spark_function>
}
 80a391c:	b004      	add	sp, #16
 80a391e:	bd10      	pop	{r4, pc}

080a3920 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>:
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a3920:	680b      	ldr	r3, [r1, #0]
 80a3922:	6003      	str	r3, [r0, #0]
      : _M_pi(__r._M_pi)
 80a3924:	684b      	ldr	r3, [r1, #4]
 80a3926:	6043      	str	r3, [r0, #4]
	if (_M_pi != 0)
 80a3928:	b113      	cbz	r3, 80a3930 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_+0x10>
    { ++_M_use_count; }
 80a392a:	685a      	ldr	r2, [r3, #4]
 80a392c:	3201      	adds	r2, #1
 80a392e:	605a      	str	r2, [r3, #4]
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a3930:	4770      	bx	lr

080a3932 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>:
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
    }

    // Unwraps promise from an object pointer created via dataPtr() method
    static Promise<ResultT, ContextT> fromDataPtr(void* data) {
 80a3932:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a3934:	4604      	mov	r4, r0
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count()==0 && get()==0
       */
      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default; ///< Copy constructor
 80a3936:	4668      	mov	r0, sp
 80a3938:	460d      	mov	r5, r1
 80a393a:	f7ff fff1 	bl	80a3920 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a393e:	9b00      	ldr	r3, [sp, #0]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a3940:	9a01      	ldr	r2, [sp, #4]
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a3942:	6023      	str	r3, [r4, #0]
	__r._M_pi = _M_pi;
 80a3944:	2300      	movs	r3, #0
	_M_pi = __tmp;
 80a3946:	6062      	str	r2, [r4, #4]
      ~__shared_ptr() = default;
 80a3948:	a801      	add	r0, sp, #4
	__r._M_pi = _M_pi;
 80a394a:	9301      	str	r3, [sp, #4]
	__r._M_ptr = 0;
 80a394c:	9300      	str	r3, [sp, #0]
      ~__shared_ptr() = default;
 80a394e:	f7fd fbf7 	bl	80a1140 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        auto d = static_cast<detail::FutureImplPtr<ResultT, ContextT>*>(data);
        const Promise<ResultT, ContextT> p(*d);
        delete d;
 80a3952:	b135      	cbz	r5, 80a3962 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv+0x30>
 80a3954:	1d28      	adds	r0, r5, #4
 80a3956:	f7fd fbf3 	bl	80a1140 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a395a:	2108      	movs	r1, #8
 80a395c:	4628      	mov	r0, r5
 80a395e:	f000 fe92 	bl	80a4686 <_ZdlPvj>
        return p;
    }
 80a3962:	4620      	mov	r0, r4
 80a3964:	b003      	add	sp, #12
 80a3966:	bd30      	pop	{r4, r5, pc}

080a3968 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a3968:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
 80a396a:	b510      	push	{r4, lr}
      if (_M_empty())
 80a396c:	b90a      	cbnz	r2, 80a3972 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_+0xa>
	__throw_bad_function_call();
 80a396e:	f000 fe8e 	bl	80a468e <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3972:	68c3      	ldr	r3, [r0, #12]
    }
 80a3974:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3978:	4718      	bx	r3

080a397a <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a397a:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
 80a397c:	6800      	ldr	r0, [r0, #0]
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
 80a397e:	f100 0110 	add.w	r1, r0, #16
 80a3982:	f7ff fff1 	bl	80a3968 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
      }
 80a3986:	bd08      	pop	{r3, pc}

080a3988 <_ZNKSt8functionIFvRKbEEclES1_>:
      if (_M_empty())
 80a3988:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
 80a398a:	b510      	push	{r4, lr}
      if (_M_empty())
 80a398c:	b90a      	cbnz	r2, 80a3992 <_ZNKSt8functionIFvRKbEEclES1_+0xa>
	__throw_bad_function_call();
 80a398e:	f000 fe7e 	bl	80a468e <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3992:	68c3      	ldr	r3, [r0, #12]
    }
 80a3994:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3998:	4718      	bx	r3

080a399a <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a399a:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
 80a399c:	6800      	ldr	r0, [r0, #0]
 80a399e:	f100 0110 	add.w	r1, r0, #16
 80a39a2:	f7ff fff1 	bl	80a3988 <_ZNKSt8functionIFvRKbEEclES1_>
      }
 80a39a6:	bd08      	pop	{r3, pc}

080a39a8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>:
	__shared_count(_Ptr __p) : _M_pi(0)
 80a39a8:	b538      	push	{r3, r4, r5, lr}
 80a39aa:	2300      	movs	r3, #0
 80a39ac:	4604      	mov	r4, r0
 80a39ae:	6003      	str	r3, [r0, #0]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a39b0:	2010      	movs	r0, #16
	__shared_count(_Ptr __p) : _M_pi(0)
 80a39b2:	460d      	mov	r5, r1
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a39b4:	f7fc fb71 	bl	80a009a <_Znwj>
 80a39b8:	b128      	cbz	r0, 80a39c6 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x1e>
      : _M_use_count(1), _M_weak_count(1) { }
 80a39ba:	2301      	movs	r3, #1
 80a39bc:	e9c0 3301 	strd	r3, r3, [r0, #4]
      : _M_ptr(__p) { }
 80a39c0:	4b02      	ldr	r3, [pc, #8]	; (80a39cc <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x24>)
 80a39c2:	60c5      	str	r5, [r0, #12]
 80a39c4:	6003      	str	r3, [r0, #0]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a39c6:	6020      	str	r0, [r4, #0]
	}
 80a39c8:	4620      	mov	r0, r4
 80a39ca:	bd38      	pop	{r3, r4, r5, pc}
 80a39cc:	080a7310 	.word	0x080a7310

080a39d0 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>:
    function<_Res(_ArgTypes...)>::
 80a39d0:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
 80a39d2:	2300      	movs	r3, #0
 80a39d4:	6083      	str	r3, [r0, #8]
    bool _M_empty() const { return !_M_manager; }
 80a39d6:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
 80a39d8:	4604      	mov	r4, r0
 80a39da:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
 80a39dc:	b12b      	cbz	r3, 80a39ea <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a39de:	2202      	movs	r2, #2
 80a39e0:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a39e2:	68eb      	ldr	r3, [r5, #12]
 80a39e4:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a39e6:	68ab      	ldr	r3, [r5, #8]
 80a39e8:	60a3      	str	r3, [r4, #8]
    }
 80a39ea:	4620      	mov	r0, r4
 80a39ec:	bd38      	pop	{r3, r4, r5, pc}
	...

080a39f0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>:
    void setError(Error error) {
 80a39f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a39f2:	b089      	sub	sp, #36	; 0x24
      { return _M_ptr; }
 80a39f4:	6804      	ldr	r4, [r0, #0]
        p_->setError(std::move(error));
 80a39f6:	4668      	mov	r0, sp
 80a39f8:	f7ff ff34 	bl	80a3864 <_ZN8particle5ErrorC1EOS0_>

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(std::__addressof(_M_i),
 80a39fc:	f04f 0302 	mov.w	r3, #2
 80a3a00:	e8d4 2f4f 	ldrexb	r2, [r4]
 80a3a04:	2a00      	cmp	r2, #0
 80a3a06:	d103      	bne.n	80a3a10 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x20>
 80a3a08:	e8c4 3f41 	strexb	r1, r3, [r4]
 80a3a0c:	2900      	cmp	r1, #0
 80a3a0e:	d1f7      	bne.n	80a3a00 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x10>
        if (this->changeState(State::FAILED)) {
 80a3a10:	d125      	bne.n	80a3a5e <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
            new(&error_) Error(std::move(error));
 80a3a12:	f104 050c 	add.w	r5, r4, #12
 80a3a16:	4669      	mov	r1, sp
 80a3a18:	4628      	mov	r0, r5
 80a3a1a:	f7ff ff23 	bl	80a3864 <_ZN8particle5ErrorC1EOS0_>
	__atomic_store_n(&_M_i, __i, int(__m));
 80a3a1e:	2301      	movs	r3, #1
 80a3a20:	f3bf 8f5b 	dmb	ish
 80a3a24:	7063      	strb	r3, [r4, #1]

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, int(__m));
 80a3a26:	2000      	movs	r0, #0
 80a3a28:	f3bf 8f5b 	dmb	ish
 80a3a2c:	f104 0308 	add.w	r3, r4, #8
 80a3a30:	e853 6f00 	ldrex	r6, [r3]
 80a3a34:	e843 0200 	strex	r2, r0, [r3]
 80a3a38:	2a00      	cmp	r2, #0
 80a3a3a:	d1f9      	bne.n	80a3a30 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x40>
 80a3a3c:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
 80a3a40:	b16e      	cbz	r6, 80a3a5e <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
        return (application_thread_current(nullptr) != 0);
 80a3a42:	f7ff fa67 	bl	80a2f14 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
 80a3a46:	b178      	cbz	r0, 80a3a68 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x78>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a3a48:	4629      	mov	r1, r5
 80a3a4a:	4630      	mov	r0, r6
 80a3a4c:	f7ff ff8c 	bl	80a3968 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
    class function<_Res(_ArgTypes...)>
 80a3a50:	4630      	mov	r0, r6
 80a3a52:	f7ff fe1a 	bl	80a368a <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
 80a3a56:	2110      	movs	r1, #16
 80a3a58:	4630      	mov	r0, r6
 80a3a5a:	f000 fe14 	bl	80a4686 <_ZdlPvj>
        p_->setError(std::move(error));
 80a3a5e:	4668      	mov	r0, sp
 80a3a60:	f7ff ff0d 	bl	80a387e <_ZN8particle5ErrorD1Ev>
    }
 80a3a64:	b009      	add	sp, #36	; 0x24
 80a3a66:	bdf0      	pop	{r4, r5, r6, r7, pc}

     public:
      template<typename... _Args>
	explicit _GLIBCXX20_CONSTEXPR
	_Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a3a68:	4631      	mov	r1, r6
 80a3a6a:	a802      	add	r0, sp, #8
 80a3a6c:	f7ff ffb0 	bl	80a39d0 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
 80a3a70:	68e0      	ldr	r0, [r4, #12]
 80a3a72:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
 80a3a76:	b108      	cbz	r0, 80a3a7c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x8c>
 80a3a78:	f003 f8e2 	bl	80a6c40 <strdup>
        type_(type) {
 80a3a7c:	9006      	str	r0, [sp, #24]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a3a7e:	2010      	movs	r0, #16
 80a3a80:	f8ad 501c 	strh.w	r5, [sp, #28]
 80a3a84:	f7fc fb09 	bl	80a009a <_Znwj>
 80a3a88:	4605      	mov	r5, r0
 80a3a8a:	b1e8      	cbz	r0, 80a3ac8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xd8>
    _Function_base() : _M_manager(nullptr) { }
 80a3a8c:	2700      	movs	r7, #0
 80a3a8e:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a3a90:	2018      	movs	r0, #24
 80a3a92:	f7fc fb02 	bl	80a009a <_Znwj>
 80a3a96:	4604      	mov	r4, r0
 80a3a98:	b188      	cbz	r0, 80a3abe <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xce>
	std::swap(_M_functor, __x._M_functor);
 80a3a9a:	4601      	mov	r1, r0
    _Function_base() : _M_manager(nullptr) { }
 80a3a9c:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
 80a3a9e:	a802      	add	r0, sp, #8
 80a3aa0:	f7ff fe02 	bl	80a36a8 <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a3aa4:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
 80a3aa6:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a3aa8:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a3aaa:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
 80a3aac:	9204      	str	r2, [sp, #16]
 80a3aae:	68e2      	ldr	r2, [r4, #12]
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a3ab0:	a906      	add	r1, sp, #24
      __b = _GLIBCXX_MOVE(__tmp);
 80a3ab2:	60e3      	str	r3, [r4, #12]
 80a3ab4:	f104 0010 	add.w	r0, r4, #16
      __a = _GLIBCXX_MOVE(__b);
 80a3ab8:	9205      	str	r2, [sp, #20]
 80a3aba:	f7ff fed3 	bl	80a3864 <_ZN8particle5ErrorC1EOS0_>
	    _M_invoker = &_My_handler::_M_invoke;
 80a3abe:	4b08      	ldr	r3, [pc, #32]	; (80a3ae0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf0>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a3ac0:	602c      	str	r4, [r5, #0]
	    _M_invoker = &_My_handler::_M_invoke;
 80a3ac2:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a3ac4:	4b07      	ldr	r3, [pc, #28]	; (80a3ae4 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf4>)
 80a3ac6:	60ab      	str	r3, [r5, #8]
    struct _Head_base<_Idx, _Head, false>
 80a3ac8:	a806      	add	r0, sp, #24
 80a3aca:	f7ff fed8 	bl	80a387e <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
 80a3ace:	a802      	add	r0, sp, #8
 80a3ad0:	f7ff fddb 	bl	80a368a <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a3ad4:	2200      	movs	r2, #0
 80a3ad6:	4629      	mov	r1, r5
 80a3ad8:	4803      	ldr	r0, [pc, #12]	; (80a3ae8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf8>)
 80a3ada:	f7ff fa23 	bl	80a2f24 <application_thread_invoke>
 80a3ade:	e7b7      	b.n	80a3a50 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x60>
 80a3ae0:	080a397b 	.word	0x080a397b
 80a3ae4:	080a3c05 	.word	0x080a3c05
 80a3ae8:	080a418d 	.word	0x080a418d

080a3aec <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>:

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a3aec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a3af0:	b08a      	sub	sp, #40	; 0x28
 80a3af2:	4605      	mov	r5, r0
 80a3af4:	460c      	mov	r4, r1
 80a3af6:	4617      	mov	r7, r2
 80a3af8:	4698      	mov	r8, r3
 80a3afa:	f89d 9048 	ldrb.w	r9, [sp, #72]	; 0x48
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a3afe:	f7ff faaf 	bl	80a3060 <spark_cloud_flag_connected>
 80a3b02:	ae07      	add	r6, sp, #28
    if (!connected()) {
 80a3b04:	4682      	mov	sl, r0
 80a3b06:	bb38      	cbnz	r0, 80a3b58 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x6c>
        type_(type) {
 80a3b08:	f64f 732e 	movw	r3, #65326	; 0xff2e
 80a3b0c:	9005      	str	r0, [sp, #20]
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnSuccessCallback OnSuccessCallback;
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnErrorCallback OnErrorCallback;

    // Construct failed future
    explicit FutureBase(Error error) :
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
 80a3b0e:	a905      	add	r1, sp, #20
 80a3b10:	4630      	mov	r0, r6
 80a3b12:	f8ad 3018 	strh.w	r3, [sp, #24]
 80a3b16:	f7ff fea5 	bl	80a3864 <_ZN8particle5ErrorC1EOS0_>
 80a3b1a:	2014      	movs	r0, #20
 80a3b1c:	f7fc fabd 	bl	80a009a <_Znwj>
 80a3b20:	4604      	mov	r4, r0
 80a3b22:	b148      	cbz	r0, 80a3b38 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x4c>
      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
 80a3b24:	2302      	movs	r3, #2
 80a3b26:	7003      	strb	r3, [r0, #0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a3b28:	2301      	movs	r3, #1
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
 80a3b2a:	e9c0 aa01 	strd	sl, sl, [r0, #4]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a3b2e:	7043      	strb	r3, [r0, #1]
            error_(std::move(error)) {
 80a3b30:	4631      	mov	r1, r6
 80a3b32:	300c      	adds	r0, #12
 80a3b34:	f7ff fe96 	bl	80a3864 <_ZN8particle5ErrorC1EOS0_>
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 80a3b38:	4628      	mov	r0, r5
	: __shared_count(__p)
 80a3b3a:	4621      	mov	r1, r4
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 80a3b3c:	f840 4b04 	str.w	r4, [r0], #4
	: __shared_count(__p)
 80a3b40:	f7ff ff32 	bl	80a39a8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
 80a3b44:	4630      	mov	r0, r6
 80a3b46:	f7ff fe9a 	bl	80a387e <_ZN8particle5ErrorD1Ev>
    }

    explicit FutureBase(Error::Type error) :
            FutureBase(Error(error)) {
 80a3b4a:	a805      	add	r0, sp, #20
 80a3b4c:	f7ff fe97 	bl	80a387e <_ZN8particle5ErrorD1Ev>
        p.setError(Error::UNKNOWN);
        p.fromDataPtr(d.handler_data); // Free wrapper object
    }

    return p.future();
}
 80a3b50:	4628      	mov	r0, r5
 80a3b52:	b00a      	add	sp, #40	; 0x28
 80a3b54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a3b58:	230c      	movs	r3, #12
 80a3b5a:	f04f 0a00 	mov.w	sl, #0
            p_(new detail::FutureImpl<ResultT, ContextT>(State::RUNNING)) {
 80a3b5e:	2014      	movs	r0, #20
 80a3b60:	e9cd aa08 	strd	sl, sl, [sp, #32]
 80a3b64:	9307      	str	r3, [sp, #28]
 80a3b66:	f7fc fa98 	bl	80a009a <_Znwj>
 80a3b6a:	4601      	mov	r1, r0
 80a3b6c:	b128      	cbz	r0, 80a3b7a <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x8e>
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
 80a3b6e:	e9c0 aa01 	strd	sl, sl, [r0, #4]
 80a3b72:	f880 a000 	strb.w	sl, [r0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a3b76:	f880 a001 	strb.w	sl, [r0, #1]
 80a3b7a:	a804      	add	r0, sp, #16
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 80a3b7c:	9103      	str	r1, [sp, #12]
	: __shared_count(__p)
 80a3b7e:	f7ff ff13 	bl	80a39a8 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
    d.handler_callback = publishCompletionCallback;
 80a3b82:	4b1f      	ldr	r3, [pc, #124]	; (80a3c00 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x114>)
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
 80a3b84:	2008      	movs	r0, #8
 80a3b86:	9308      	str	r3, [sp, #32]
 80a3b88:	f7fc fa87 	bl	80a009a <_Znwj>
 80a3b8c:	4682      	mov	sl, r0
 80a3b8e:	b110      	cbz	r0, 80a3b96 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xaa>
 80a3b90:	a903      	add	r1, sp, #12
 80a3b92:	f7ff fec5 	bl	80a3920 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a3b96:	4642      	mov	r2, r8
 80a3b98:	4639      	mov	r1, r7
 80a3b9a:	4620      	mov	r0, r4
 80a3b9c:	9600      	str	r6, [sp, #0]
 80a3b9e:	fa5f f389 	uxtb.w	r3, r9
    d.handler_data = p.dataPtr();
 80a3ba2:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a3ba6:	f7ff fa63 	bl	80a3070 <spark_send_event>
 80a3baa:	b9b8      	cbnz	r0, 80a3bdc <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xf0>
	return __atomic_load_n(&_M_i, int(__m));
 80a3bac:	9b03      	ldr	r3, [sp, #12]
 80a3bae:	785b      	ldrb	r3, [r3, #1]
 80a3bb0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80a3bb4:	b993      	cbnz	r3, 80a3bdc <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xf0>
 80a3bb6:	f64f 739c 	movw	r3, #65436	; 0xff9c
        p.setError(Error::UNKNOWN);
 80a3bba:	a905      	add	r1, sp, #20
 80a3bbc:	a803      	add	r0, sp, #12
 80a3bbe:	9205      	str	r2, [sp, #20]
 80a3bc0:	f8ad 3018 	strh.w	r3, [sp, #24]
 80a3bc4:	f7ff ff14 	bl	80a39f0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
 80a3bc8:	a805      	add	r0, sp, #20
 80a3bca:	f7ff fe58 	bl	80a387e <_ZN8particle5ErrorD1Ev>
        p.fromDataPtr(d.handler_data); // Free wrapper object
 80a3bce:	a805      	add	r0, sp, #20
 80a3bd0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80a3bd2:	f7ff feae 	bl	80a3932 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
      ~__shared_ptr() = default;
 80a3bd6:	a806      	add	r0, sp, #24
 80a3bd8:	f7fd fab2 	bl	80a1140 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a3bdc:	a903      	add	r1, sp, #12
 80a3bde:	a805      	add	r0, sp, #20
 80a3be0:	f7ff fe9e 	bl	80a3920 <_ZNSt12__shared_ptrIN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EEC1ERKS7_>
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a3be4:	9b05      	ldr	r3, [sp, #20]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a3be6:	9a06      	ldr	r2, [sp, #24]
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a3be8:	602b      	str	r3, [r5, #0]
	__r._M_pi = _M_pi;
 80a3bea:	2300      	movs	r3, #0
	_M_pi = __tmp;
 80a3bec:	606a      	str	r2, [r5, #4]
      ~__shared_ptr() = default;
 80a3bee:	a806      	add	r0, sp, #24
	__r._M_pi = _M_pi;
 80a3bf0:	9306      	str	r3, [sp, #24]
	__r._M_ptr = 0;
 80a3bf2:	9305      	str	r3, [sp, #20]
      ~__shared_ptr() = default;
 80a3bf4:	f7fd faa4 	bl	80a1140 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a3bf8:	a804      	add	r0, sp, #16
 80a3bfa:	f7fd faa1 	bl	80a1140 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
class Promise: public PromiseBase<ResultT, ContextT> {
 80a3bfe:	e7a7      	b.n	80a3b50 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x64>
 80a3c00:	080a3c81 	.word	0x080a3c81

080a3c04 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
	switch (__op)
 80a3c04:	2a01      	cmp	r2, #1
      _M_manager(_Any_data& __dest, const _Any_data& __source,
 80a3c06:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3c08:	4605      	mov	r5, r0
	switch (__op)
 80a3c0a:	d103      	bne.n	80a3c14 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x10>
	    return __source._M_access<_Functor*>();
 80a3c0c:	680b      	ldr	r3, [r1, #0]
	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
 80a3c0e:	6003      	str	r3, [r0, #0]
      }
 80a3c10:	2000      	movs	r0, #0
 80a3c12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  switch (__op)
 80a3c14:	2a02      	cmp	r2, #2
 80a3c16:	d010      	beq.n	80a3c3a <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x36>
 80a3c18:	2a03      	cmp	r2, #3
 80a3c1a:	d1f9      	bne.n	80a3c10 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>
	  delete __victim._M_access<_Functor*>();
 80a3c1c:	6804      	ldr	r4, [r0, #0]
 80a3c1e:	2c00      	cmp	r4, #0
 80a3c20:	d0f6      	beq.n	80a3c10 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>
 80a3c22:	f104 0010 	add.w	r0, r4, #16
 80a3c26:	f7ff fe2a 	bl	80a387e <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
 80a3c2a:	4620      	mov	r0, r4
 80a3c2c:	f7ff fd2d 	bl	80a368a <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
 80a3c30:	2118      	movs	r1, #24
 80a3c32:	4620      	mov	r0, r4
 80a3c34:	f000 fd27 	bl	80a4686 <_ZdlPvj>
 80a3c38:	e7ea      	b.n	80a3c10 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>
	    new _Functor(*__source._M_access<const _Functor*>());
 80a3c3a:	2018      	movs	r0, #24
	  __dest._M_access<_Functor*>() =
 80a3c3c:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
 80a3c3e:	f7fc fa2c 	bl	80a009a <_Znwj>
 80a3c42:	4604      	mov	r4, r0
 80a3c44:	b150      	cbz	r0, 80a3c5c <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x58>
	explicit _GLIBCXX20_CONSTEXPR
	_Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
 80a3c46:	4631      	mov	r1, r6
 80a3c48:	f7ff fec2 	bl	80a39d0 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
 80a3c4c:	6930      	ldr	r0, [r6, #16]
 80a3c4e:	f9b6 7014 	ldrsh.w	r7, [r6, #20]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
 80a3c52:	b108      	cbz	r0, 80a3c58 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x54>
 80a3c54:	f002 fff4 	bl	80a6c40 <strdup>
        type_(type) {
 80a3c58:	6120      	str	r0, [r4, #16]
 80a3c5a:	82a7      	strh	r7, [r4, #20]
	  __dest._M_access<_Functor*>() =
 80a3c5c:	602c      	str	r4, [r5, #0]
	}
 80a3c5e:	e7d7      	b.n	80a3c10 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0xc>

080a3c60 <_ZNSt8functionIFvRKbEEC1ERKS3_>:
    function<_Res(_ArgTypes...)>::
 80a3c60:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
 80a3c62:	2300      	movs	r3, #0
 80a3c64:	6083      	str	r3, [r0, #8]
    bool _M_empty() const { return !_M_manager; }
 80a3c66:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
 80a3c68:	4604      	mov	r4, r0
 80a3c6a:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
 80a3c6c:	b12b      	cbz	r3, 80a3c7a <_ZNSt8functionIFvRKbEEC1ERKS3_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a3c6e:	2202      	movs	r2, #2
 80a3c70:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a3c72:	68eb      	ldr	r3, [r5, #12]
 80a3c74:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a3c76:	68ab      	ldr	r3, [r5, #8]
 80a3c78:	60a3      	str	r3, [r4, #8]
    }
 80a3c7a:	4620      	mov	r0, r4
 80a3c7c:	bd38      	pop	{r3, r4, r5, pc}
	...

080a3c80 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_>:
void publishCompletionCallback(int error, const void* data, void* callbackData, void* reserved) {
 80a3c80:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a3c82:	4604      	mov	r4, r0
 80a3c84:	b089      	sub	sp, #36	; 0x24
 80a3c86:	460d      	mov	r5, r1
    auto p = Promise<bool>::fromDataPtr(callbackData);
 80a3c88:	a801      	add	r0, sp, #4
 80a3c8a:	4611      	mov	r1, r2
 80a3c8c:	f7ff fe51 	bl	80a3932 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
    if (error != Error::NONE) {
 80a3c90:	b1a4      	cbz	r4, 80a3cbc <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x3c>
        p.setError(Error((Error::Type)error, (const char*)data));
 80a3c92:	b224      	sxth	r4, r4
        msg_(msg ? (const char*)strdup(msg) : nullptr),
 80a3c94:	b11d      	cbz	r5, 80a3c9e <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x1e>
 80a3c96:	4628      	mov	r0, r5
 80a3c98:	f002 ffd2 	bl	80a6c40 <strdup>
 80a3c9c:	4605      	mov	r5, r0
 80a3c9e:	a801      	add	r0, sp, #4
 80a3ca0:	a903      	add	r1, sp, #12
        type_(type) {
 80a3ca2:	9503      	str	r5, [sp, #12]
 80a3ca4:	f8ad 4010 	strh.w	r4, [sp, #16]
 80a3ca8:	f7ff fea2 	bl	80a39f0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
 80a3cac:	a803      	add	r0, sp, #12
 80a3cae:	f7ff fde6 	bl	80a387e <_ZN8particle5ErrorD1Ev>
 80a3cb2:	a802      	add	r0, sp, #8
 80a3cb4:	f7fd fa44 	bl	80a1140 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a3cb8:	b009      	add	sp, #36	; 0x24
 80a3cba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return __atomic_compare_exchange(std::__addressof(_M_i),
 80a3cbc:	2301      	movs	r3, #1
      { return _M_ptr; }
 80a3cbe:	9d01      	ldr	r5, [sp, #4]
 80a3cc0:	e8d5 2f4f 	ldrexb	r2, [r5]
 80a3cc4:	2a00      	cmp	r2, #0
 80a3cc6:	d103      	bne.n	80a3cd0 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x50>
 80a3cc8:	e8c5 3f41 	strexb	r1, r3, [r5]
 80a3ccc:	2900      	cmp	r1, #0
 80a3cce:	d1f7      	bne.n	80a3cc0 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x40>
        if (this->changeState(State::SUCCEEDED)) {
 80a3cd0:	d1ef      	bne.n	80a3cb2 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
            new(&result_) ResultT(std::move(result));
 80a3cd2:	732b      	strb	r3, [r5, #12]
	__atomic_store_n(&_M_i, __i, int(__m));
 80a3cd4:	f3bf 8f5b 	dmb	ish
 80a3cd8:	706b      	strb	r3, [r5, #1]
	return __atomic_exchange_n(&_M_p, __p, int(__m));
 80a3cda:	f3bf 8f5b 	dmb	ish
 80a3cde:	1d2b      	adds	r3, r5, #4
 80a3ce0:	e853 6f00 	ldrex	r6, [r3]
 80a3ce4:	e843 4200 	strex	r2, r4, [r3]
 80a3ce8:	2a00      	cmp	r2, #0
 80a3cea:	d1f9      	bne.n	80a3ce0 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x60>
 80a3cec:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
 80a3cf0:	2e00      	cmp	r6, #0
 80a3cf2:	d0de      	beq.n	80a3cb2 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
        return (application_thread_current(nullptr) != 0);
 80a3cf4:	4620      	mov	r0, r4
 80a3cf6:	f7ff f90d 	bl	80a2f14 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
 80a3cfa:	4607      	mov	r7, r0
 80a3cfc:	b160      	cbz	r0, 80a3d18 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x98>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a3cfe:	4630      	mov	r0, r6
 80a3d00:	f105 010c 	add.w	r1, r5, #12
 80a3d04:	f7ff fe40 	bl	80a3988 <_ZNKSt8functionIFvRKbEEclES1_>
    class function<_Res(_ArgTypes...)>
 80a3d08:	4630      	mov	r0, r6
 80a3d0a:	f7ff fcbe 	bl	80a368a <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
 80a3d0e:	2110      	movs	r1, #16
 80a3d10:	4630      	mov	r0, r6
 80a3d12:	f000 fcb8 	bl	80a4686 <_ZdlPvj>
 80a3d16:	e7cc      	b.n	80a3cb2 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a3d18:	4631      	mov	r1, r6
 80a3d1a:	a803      	add	r0, sp, #12
 80a3d1c:	f7ff ffa0 	bl	80a3c60 <_ZNSt8functionIFvRKbEEC1ERKS3_>
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a3d20:	7b2b      	ldrb	r3, [r5, #12]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a3d22:	2010      	movs	r0, #16
 80a3d24:	f88d 301c 	strb.w	r3, [sp, #28]
 80a3d28:	f7fc f9b7 	bl	80a009a <_Znwj>
 80a3d2c:	4605      	mov	r5, r0
 80a3d2e:	b1d0      	cbz	r0, 80a3d66 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xe6>
    _Function_base() : _M_manager(nullptr) { }
 80a3d30:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a3d32:	2014      	movs	r0, #20
 80a3d34:	f7fc f9b1 	bl	80a009a <_Znwj>
 80a3d38:	4604      	mov	r4, r0
 80a3d3a:	b178      	cbz	r0, 80a3d5c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xdc>
	std::swap(_M_functor, __x._M_functor);
 80a3d3c:	4601      	mov	r1, r0
    _Function_base() : _M_manager(nullptr) { }
 80a3d3e:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
 80a3d40:	a803      	add	r0, sp, #12
 80a3d42:	f7ff fcb1 	bl	80a36a8 <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a3d46:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
 80a3d48:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a3d4a:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a3d4c:	9b06      	ldr	r3, [sp, #24]
      __a = _GLIBCXX_MOVE(__b);
 80a3d4e:	9205      	str	r2, [sp, #20]
 80a3d50:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a3d52:	60e3      	str	r3, [r4, #12]
 80a3d54:	f89d 301c 	ldrb.w	r3, [sp, #28]
      __a = _GLIBCXX_MOVE(__b);
 80a3d58:	9206      	str	r2, [sp, #24]
 80a3d5a:	7423      	strb	r3, [r4, #16]
	    _M_invoker = &_My_handler::_M_invoke;
 80a3d5c:	4b06      	ldr	r3, [pc, #24]	; (80a3d78 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xf8>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a3d5e:	602c      	str	r4, [r5, #0]
	    _M_invoker = &_My_handler::_M_invoke;
 80a3d60:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a3d62:	4b06      	ldr	r3, [pc, #24]	; (80a3d7c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xfc>)
 80a3d64:	60ab      	str	r3, [r5, #8]
    class function<_Res(_ArgTypes...)>
 80a3d66:	a803      	add	r0, sp, #12
 80a3d68:	f7ff fc8f 	bl	80a368a <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a3d6c:	2200      	movs	r2, #0
 80a3d6e:	4629      	mov	r1, r5
 80a3d70:	4803      	ldr	r0, [pc, #12]	; (80a3d80 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x100>)
 80a3d72:	f7ff f8d7 	bl	80a2f24 <application_thread_invoke>
 80a3d76:	e7c7      	b.n	80a3d08 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x88>
 80a3d78:	080a399b 	.word	0x080a399b
 80a3d7c:	080a3d85 	.word	0x080a3d85
 80a3d80:	080a418d 	.word	0x080a418d

080a3d84 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation>:
	switch (__op)
 80a3d84:	2a01      	cmp	r2, #1
      _M_manager(_Any_data& __dest, const _Any_data& __source,
 80a3d86:	b570      	push	{r4, r5, r6, lr}
 80a3d88:	4604      	mov	r4, r0
	switch (__op)
 80a3d8a:	d103      	bne.n	80a3d94 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x10>
	    return __source._M_access<_Functor*>();
 80a3d8c:	680b      	ldr	r3, [r1, #0]
	    __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
 80a3d8e:	6003      	str	r3, [r0, #0]
      }
 80a3d90:	2000      	movs	r0, #0
 80a3d92:	bd70      	pop	{r4, r5, r6, pc}
	  switch (__op)
 80a3d94:	2a02      	cmp	r2, #2
 80a3d96:	d00c      	beq.n	80a3db2 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x2e>
 80a3d98:	2a03      	cmp	r2, #3
 80a3d9a:	d1f9      	bne.n	80a3d90 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>
	  delete __victim._M_access<_Functor*>();
 80a3d9c:	6804      	ldr	r4, [r0, #0]
 80a3d9e:	2c00      	cmp	r4, #0
 80a3da0:	d0f6      	beq.n	80a3d90 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>
    class function<_Res(_ArgTypes...)>
 80a3da2:	4620      	mov	r0, r4
 80a3da4:	f7ff fc71 	bl	80a368a <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
 80a3da8:	2114      	movs	r1, #20
 80a3daa:	4620      	mov	r0, r4
 80a3dac:	f000 fc6b 	bl	80a4686 <_ZdlPvj>
 80a3db0:	e7ee      	b.n	80a3d90 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>
	    new _Functor(*__source._M_access<const _Functor*>());
 80a3db2:	2014      	movs	r0, #20
	  __dest._M_access<_Functor*>() =
 80a3db4:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
 80a3db6:	f7fc f970 	bl	80a009a <_Znwj>
 80a3dba:	4605      	mov	r5, r0
 80a3dbc:	b120      	cbz	r0, 80a3dc8 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x44>
      _Bind(const _Bind&) = default;
 80a3dbe:	4631      	mov	r1, r6
 80a3dc0:	f7ff ff4e 	bl	80a3c60 <_ZNSt8functionIFvRKbEEC1ERKS3_>
 80a3dc4:	7c33      	ldrb	r3, [r6, #16]
 80a3dc6:	742b      	strb	r3, [r5, #16]
	  __dest._M_access<_Functor*>() =
 80a3dc8:	6025      	str	r5, [r4, #0]
	}
 80a3dca:	e7e1      	b.n	80a3d90 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0xc>

080a3dcc <_ZN9IPAddressD1Ev>:
    IPAddress(uint32_t address);
    // 4 bytes defining the IP address in network order
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a3dcc:	4770      	bx	lr

080a3dce <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a3dce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3dd0:	460e      	mov	r6, r1
 80a3dd2:	2400      	movs	r4, #0
 80a3dd4:	f100 0708 	add.w	r7, r0, #8
 80a3dd8:	1d05      	adds	r5, r0, #4
        return printNumber(val, base) + t;
 80a3dda:	f817 1d01 	ldrb.w	r1, [r7, #-1]!
 80a3dde:	220a      	movs	r2, #10
 80a3de0:	4630      	mov	r0, r6
 80a3de2:	f7ff fb52 	bl	80a348a <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a3de6:	42af      	cmp	r7, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a3de8:	4404      	add	r4, r0
    for (int i = 0; i < 4; i++)
 80a3dea:	d101      	bne.n	80a3df0 <_ZNK9IPAddress7printToER5Print+0x22>
    }
    return n;
}
 80a3dec:	4620      	mov	r0, r4
 80a3dee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (n)
 80a3df0:	2c00      	cmp	r4, #0
 80a3df2:	d0f2      	beq.n	80a3dda <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a3df4:	212e      	movs	r1, #46	; 0x2e
 80a3df6:	4630      	mov	r0, r6
 80a3df8:	f7ff fb2e 	bl	80a3458 <_ZN5Print5printEc>
 80a3dfc:	4404      	add	r4, r0
 80a3dfe:	e7ec      	b.n	80a3dda <_ZNK9IPAddress7printToER5Print+0xc>

080a3e00 <_ZN9IPAddressD0Ev>:
 80a3e00:	b510      	push	{r4, lr}
 80a3e02:	4604      	mov	r4, r0
 80a3e04:	2118      	movs	r1, #24
 80a3e06:	f000 fc3e 	bl	80a4686 <_ZdlPvj>
 80a3e0a:	4620      	mov	r0, r4
 80a3e0c:	bd10      	pop	{r4, pc}
	...

080a3e10 <_ZN9IPAddressC1Ev>:
IPAddress::IPAddress()
 80a3e10:	b510      	push	{r4, lr}
 80a3e12:	4604      	mov	r4, r0
 80a3e14:	4b04      	ldr	r3, [pc, #16]	; (80a3e28 <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a3e16:	2211      	movs	r2, #17
 80a3e18:	2100      	movs	r1, #0
 80a3e1a:	f840 3b04 	str.w	r3, [r0], #4
 80a3e1e:	f002 fecf 	bl	80a6bc0 <memset>
}
 80a3e22:	4620      	mov	r0, r4
 80a3e24:	bd10      	pop	{r4, pc}
 80a3e26:	bf00      	nop
 80a3e28:	080a732c 	.word	0x080a732c

080a3e2c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:
IPAddress::IPAddress(const HAL_IPAddress& address)
 80a3e2c:	4603      	mov	r3, r0
 80a3e2e:	4a07      	ldr	r2, [pc, #28]	; (80a3e4c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
 80a3e30:	b510      	push	{r4, lr}
 80a3e32:	f843 2b04 	str.w	r2, [r3], #4
    memcpy(&this->address, &address, sizeof(address));
 80a3e36:	f101 0210 	add.w	r2, r1, #16
 80a3e3a:	f851 4b04 	ldr.w	r4, [r1], #4
 80a3e3e:	4291      	cmp	r1, r2
 80a3e40:	f843 4b04 	str.w	r4, [r3], #4
 80a3e44:	d1f9      	bne.n	80a3e3a <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
 80a3e46:	780a      	ldrb	r2, [r1, #0]
 80a3e48:	701a      	strb	r2, [r3, #0]
}
 80a3e4a:	bd10      	pop	{r4, pc}
 80a3e4c:	080a732c 	.word	0x080a732c

080a3e50 <_ZN9IPAddressC1Em>:
IPAddress::IPAddress(uint32_t addr)
 80a3e50:	4a02      	ldr	r2, [pc, #8]	; (80a3e5c <_ZN9IPAddressC1Em+0xc>)
    address.ipv4 = addr;
 80a3e52:	e9c0 2100 	strd	r2, r1, [r0]
        address.v = version;
 80a3e56:	2204      	movs	r2, #4
 80a3e58:	7502      	strb	r2, [r0, #20]
}
 80a3e5a:	4770      	bx	lr
 80a3e5c:	080a732c 	.word	0x080a732c

080a3e60 <_ZN9IPAddress8set_ipv4Ehhhh>:
{
 80a3e60:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a3e62:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a3e66:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 80a3e6a:	2304      	movs	r3, #4
 80a3e6c:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80a3e70:	ea44 6401 	orr.w	r4, r4, r1, lsl #24
 80a3e74:	6044      	str	r4, [r0, #4]
 80a3e76:	7503      	strb	r3, [r0, #20]
}
 80a3e78:	bd10      	pop	{r4, pc}
	...

080a3e7c <_ZN9IPAddressC1Ehhhh>:
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a3e7c:	b513      	push	{r0, r1, r4, lr}
 80a3e7e:	4c04      	ldr	r4, [pc, #16]	; (80a3e90 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a3e80:	6004      	str	r4, [r0, #0]
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a3e82:	f89d 4010 	ldrb.w	r4, [sp, #16]
 80a3e86:	9400      	str	r4, [sp, #0]
 80a3e88:	f7ff ffea 	bl	80a3e60 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a3e8c:	b002      	add	sp, #8
 80a3e8e:	bd10      	pop	{r4, pc}
 80a3e90:	080a732c 	.word	0x080a732c

080a3e94 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a3e94:	7441      	strb	r1, [r0, #17]
}
 80a3e96:	4770      	bx	lr

080a3e98 <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
 80a3e98:	4770      	bx	lr

080a3e9a <_ZN9USBSerial4readEv>:
{
 80a3e9a:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
 80a3e9c:	2100      	movs	r1, #0
 80a3e9e:	7c00      	ldrb	r0, [r0, #16]
 80a3ea0:	f7ff f808 	bl	80a2eb4 <HAL_USB_USART_Receive_Data>
}
 80a3ea4:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a3ea8:	bd08      	pop	{r3, pc}

080a3eaa <_ZN9USBSerial4peekEv>:

int USBSerial::peek()
{
 80a3eaa:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
 80a3eac:	2101      	movs	r1, #1
 80a3eae:	7c00      	ldrb	r0, [r0, #16]
 80a3eb0:	f7ff f800 	bl	80a2eb4 <HAL_USB_USART_Receive_Data>
}
 80a3eb4:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a3eb8:	bd08      	pop	{r3, pc}

080a3eba <_ZN9USBSerial17availableForWriteEv>:
{
 80a3eba:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
 80a3ebc:	7c00      	ldrb	r0, [r0, #16]
 80a3ebe:	f7fe fff1 	bl	80a2ea4 <HAL_USB_USART_Available_Data_For_Write>
}
 80a3ec2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a3ec6:	bd08      	pop	{r3, pc}

080a3ec8 <_ZN9USBSerial9availableEv>:
{
 80a3ec8:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
 80a3eca:	7c00      	ldrb	r0, [r0, #16]
 80a3ecc:	f7fe ffe2 	bl	80a2e94 <HAL_USB_USART_Available_Data>
}
 80a3ed0:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a3ed4:	bd08      	pop	{r3, pc}

080a3ed6 <_ZN9USBSerial5writeEh>:
{
 80a3ed6:	b538      	push	{r3, r4, r5, lr}
 80a3ed8:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a3eda:	7c00      	ldrb	r0, [r0, #16]
{
 80a3edc:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a3ede:	f7fe ffe1 	bl	80a2ea4 <HAL_USB_USART_Available_Data_For_Write>
 80a3ee2:	2800      	cmp	r0, #0
 80a3ee4:	dc01      	bgt.n	80a3eea <_ZN9USBSerial5writeEh+0x14>
 80a3ee6:	7c60      	ldrb	r0, [r4, #17]
 80a3ee8:	b128      	cbz	r0, 80a3ef6 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
 80a3eea:	4629      	mov	r1, r5
 80a3eec:	7c20      	ldrb	r0, [r4, #16]
 80a3eee:	f7fe ffe9 	bl	80a2ec4 <HAL_USB_USART_Send_Data>
 80a3ef2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
}
 80a3ef6:	bd38      	pop	{r3, r4, r5, pc}

080a3ef8 <_ZN9USBSerial5flushEv>:
  HAL_USB_USART_Flush_Data(_serial);
 80a3ef8:	7c00      	ldrb	r0, [r0, #16]
 80a3efa:	f7fe bfeb 	b.w	80a2ed4 <HAL_USB_USART_Flush_Data>

080a3efe <_ZN9USBSerialD0Ev>:
 80a3efe:	b510      	push	{r4, lr}
 80a3f00:	4604      	mov	r4, r0
 80a3f02:	2114      	movs	r1, #20
 80a3f04:	f000 fbbf 	bl	80a4686 <_ZdlPvj>
 80a3f08:	4620      	mov	r0, r4
 80a3f0a:	bd10      	pop	{r4, pc}

080a3f0c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a3f0c:	b510      	push	{r4, lr}
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a3f0e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a3f12:	4604      	mov	r4, r0
 80a3f14:	4608      	mov	r0, r1
 80a3f16:	2100      	movs	r1, #0
 80a3f18:	e9c4 1301 	strd	r1, r3, [r4, #4]
 80a3f1c:	4b04      	ldr	r3, [pc, #16]	; (80a3f30 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
  _serial = serial;
 80a3f1e:	7420      	strb	r0, [r4, #16]
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a3f20:	6023      	str	r3, [r4, #0]
  _blocking = true;
 80a3f22:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
 80a3f24:	4611      	mov	r1, r2
  _blocking = true;
 80a3f26:	7463      	strb	r3, [r4, #17]
  HAL_USB_USART_Init(_serial, &conf);
 80a3f28:	f7fe ffac 	bl	80a2e84 <HAL_USB_USART_Init>
}
 80a3f2c:	4620      	mov	r0, r4
 80a3f2e:	bd10      	pop	{r4, pc}
 80a3f30:	080a7340 	.word	0x080a7340

080a3f34 <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a3f34:	b510      	push	{r4, lr}
 80a3f36:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a3f38:	2214      	movs	r2, #20
 80a3f3a:	2100      	movs	r1, #0
 80a3f3c:	f002 fe40 	bl	80a6bc0 <memset>
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a3f40:	4620      	mov	r0, r4
 80a3f42:	bd10      	pop	{r4, pc}

080a3f44 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a3f44:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a3f46:	4d0f      	ldr	r5, [pc, #60]	; (80a3f84 <_Z16_fetch_usbserialv+0x40>)
{
 80a3f48:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a3f4a:	a801      	add	r0, sp, #4
 80a3f4c:	f7ff fff2 	bl	80a3f34 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a3f50:	7829      	ldrb	r1, [r5, #0]
 80a3f52:	f3bf 8f5b 	dmb	ish
 80a3f56:	f011 0401 	ands.w	r4, r1, #1
 80a3f5a:	d110      	bne.n	80a3f7e <_Z16_fetch_usbserialv+0x3a>
 80a3f5c:	4628      	mov	r0, r5
 80a3f5e:	f7fc f8a2 	bl	80a00a6 <__cxa_guard_acquire>
 80a3f62:	b160      	cbz	r0, 80a3f7e <_Z16_fetch_usbserialv+0x3a>
 80a3f64:	4621      	mov	r1, r4
 80a3f66:	aa01      	add	r2, sp, #4
 80a3f68:	4807      	ldr	r0, [pc, #28]	; (80a3f88 <_Z16_fetch_usbserialv+0x44>)
 80a3f6a:	f7ff ffcf 	bl	80a3f0c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a3f6e:	4628      	mov	r0, r5
 80a3f70:	f7fc f89e 	bl	80a00b0 <__cxa_guard_release>
 80a3f74:	4a05      	ldr	r2, [pc, #20]	; (80a3f8c <_Z16_fetch_usbserialv+0x48>)
 80a3f76:	4906      	ldr	r1, [pc, #24]	; (80a3f90 <_Z16_fetch_usbserialv+0x4c>)
 80a3f78:	4803      	ldr	r0, [pc, #12]	; (80a3f88 <_Z16_fetch_usbserialv+0x44>)
 80a3f7a:	f000 fb7f 	bl	80a467c <__aeabi_atexit>
	return _usbserial;
}
 80a3f7e:	4802      	ldr	r0, [pc, #8]	; (80a3f88 <_Z16_fetch_usbserialv+0x44>)
 80a3f80:	b007      	add	sp, #28
 80a3f82:	bd30      	pop	{r4, r5, pc}
 80a3f84:	20000580 	.word	0x20000580
 80a3f88:	20000588 	.word	0x20000588
 80a3f8c:	20000088 	.word	0x20000088
 80a3f90:	080a3e99 	.word	0x080a3e99

080a3f94 <_Z23acquireUSBSerial1Bufferv>:
 80a3f94:	b510      	push	{r4, lr}
 80a3f96:	4604      	mov	r4, r0
 80a3f98:	2214      	movs	r2, #20
 80a3f9a:	2100      	movs	r1, #0
 80a3f9c:	f002 fe10 	bl	80a6bc0 <memset>
 80a3fa0:	4620      	mov	r0, r4
 80a3fa2:	bd10      	pop	{r4, pc}

080a3fa4 <_Z17_fetch_usbserial1v>:

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a3fa4:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a3fa6:	4c0f      	ldr	r4, [pc, #60]	; (80a3fe4 <_Z17_fetch_usbserial1v+0x40>)
{
 80a3fa8:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a3faa:	a801      	add	r0, sp, #4
 80a3fac:	f7ff fff2 	bl	80a3f94 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a3fb0:	7823      	ldrb	r3, [r4, #0]
 80a3fb2:	f3bf 8f5b 	dmb	ish
 80a3fb6:	07db      	lsls	r3, r3, #31
 80a3fb8:	d410      	bmi.n	80a3fdc <_Z17_fetch_usbserial1v+0x38>
 80a3fba:	4620      	mov	r0, r4
 80a3fbc:	f7fc f873 	bl	80a00a6 <__cxa_guard_acquire>
 80a3fc0:	b160      	cbz	r0, 80a3fdc <_Z17_fetch_usbserial1v+0x38>
 80a3fc2:	2101      	movs	r1, #1
 80a3fc4:	aa01      	add	r2, sp, #4
 80a3fc6:	4808      	ldr	r0, [pc, #32]	; (80a3fe8 <_Z17_fetch_usbserial1v+0x44>)
 80a3fc8:	f7ff ffa0 	bl	80a3f0c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a3fcc:	4620      	mov	r0, r4
 80a3fce:	f7fc f86f 	bl	80a00b0 <__cxa_guard_release>
 80a3fd2:	4a06      	ldr	r2, [pc, #24]	; (80a3fec <_Z17_fetch_usbserial1v+0x48>)
 80a3fd4:	4906      	ldr	r1, [pc, #24]	; (80a3ff0 <_Z17_fetch_usbserial1v+0x4c>)
 80a3fd6:	4804      	ldr	r0, [pc, #16]	; (80a3fe8 <_Z17_fetch_usbserial1v+0x44>)
 80a3fd8:	f000 fb50 	bl	80a467c <__aeabi_atexit>
  return _usbserial1;
}
 80a3fdc:	4802      	ldr	r0, [pc, #8]	; (80a3fe8 <_Z17_fetch_usbserial1v+0x44>)
 80a3fde:	b006      	add	sp, #24
 80a3fe0:	bd10      	pop	{r4, pc}
 80a3fe2:	bf00      	nop
 80a3fe4:	20000584 	.word	0x20000584
 80a3fe8:	2000059c 	.word	0x2000059c
 80a3fec:	20000088 	.word	0x20000088
 80a3ff0:	080a3e99 	.word	0x080a3e99

080a3ff4 <_Z26call_raw_interrupt_handlerPv>:
}

void call_raw_interrupt_handler(void* data)
{
    raw_interrupt_handler_t handler = raw_interrupt_handler_t(data);
    handler();
 80a3ff4:	4700      	bx	r0
	...

080a3ff8 <_Z15attachInterrupttPFvvE13InterruptModeah>:
    }
    return handler!=NULL;
}

bool attachInterrupt(uint16_t pin, raw_interrupt_handler_t handler, InterruptMode mode, int8_t priority, uint8_t subpriority)
{
 80a3ff8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    HAL_Interrupts_Detach(pin);
    HAL_InterruptExtraConfiguration extra = {0};
 80a3ffc:	2400      	movs	r4, #0
{
 80a3ffe:	461d      	mov	r5, r3
 80a4000:	460f      	mov	r7, r1
 80a4002:	4690      	mov	r8, r2
 80a4004:	4606      	mov	r6, r0
    HAL_Interrupts_Detach(pin);
 80a4006:	f7fe fe31 	bl	80a2c6c <HAL_Interrupts_Detach>
  extra.version = HAL_INTERRUPT_EXTRA_CONFIGURATION_VERSION_1;
 80a400a:	2304      	movs	r3, #4
  if (priority >= 0) {
 80a400c:	42a5      	cmp	r5, r4
  extra.version = HAL_INTERRUPT_EXTRA_CONFIGURATION_VERSION_1;
 80a400e:	f88d 300c 	strb.w	r3, [sp, #12]
    extra.IRQChannelSubPriority = subpriority;
 80a4012:	bfa8      	it	ge
 80a4014:	f89d 3028 	ldrbge.w	r3, [sp, #40]	; 0x28
    HAL_InterruptExtraConfiguration extra = {0};
 80a4018:	f8ad 400d 	strh.w	r4, [sp, #13]
 80a401c:	f88d 400f 	strb.w	r4, [sp, #15]
    return &extra;
 80a4020:	bfa4      	itt	ge
 80a4022:	ac03      	addge	r4, sp, #12
    extra.IRQChannelSubPriority = subpriority;
 80a4024:	f88d 300e 	strbge.w	r3, [sp, #14]
    if (SYSTEM_ERROR_NONE != HAL_Interrupts_Attach(pin, call_raw_interrupt_handler, (void*)handler, mode, configure_interrupt(extra, priority, subpriority))) {
 80a4028:	463a      	mov	r2, r7
 80a402a:	4643      	mov	r3, r8
 80a402c:	4630      	mov	r0, r6
 80a402e:	4906      	ldr	r1, [pc, #24]	; (80a4048 <_Z15attachInterrupttPFvvE13InterruptModeah+0x50>)
 80a4030:	9400      	str	r4, [sp, #0]
    extra.IRQChannelPreemptionPriority = (uint8_t)priority;
 80a4032:	bfa8      	it	ge
 80a4034:	f88d 500d 	strbge.w	r5, [sp, #13]
    if (SYSTEM_ERROR_NONE != HAL_Interrupts_Attach(pin, call_raw_interrupt_handler, (void*)handler, mode, configure_interrupt(extra, priority, subpriority))) {
 80a4038:	f7fe fe10 	bl	80a2c5c <HAL_Interrupts_Attach>
        return false;
    }
    return true;
}
 80a403c:	fab0 f080 	clz	r0, r0
 80a4040:	0940      	lsrs	r0, r0, #5
 80a4042:	b004      	add	sp, #16
 80a4044:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a4048:	080a3ff5 	.word	0x080a3ff5

080a404c <_Z12noInterruptsv>:
 * Return         : None.
 *******************************************************************************/
void noInterrupts(void)
{
  //Only disable the interrupts that are exposed to the user
  HAL_Interrupts_Disable_All();
 80a404c:	f7fe be1e 	b.w	80a2c8c <HAL_Interrupts_Disable_All>

080a4050 <_Z10interruptsv>:
 * Return         : None.
 *******************************************************************************/
void interrupts(void)
{
  //Only enable the interrupts that are exposed to the user
  HAL_Interrupts_Enable_All();
 80a4050:	f7fe be14 	b.w	80a2c7c <HAL_Interrupts_Enable_All>

080a4054 <_ZN11USARTSerialD1Ev>:
private:
  hal_usart_interface_t _serial;
  bool _blocking;
public:
  USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer);
  virtual ~USARTSerial() {};
 80a4054:	4770      	bx	lr

080a4056 <_ZN11USARTSerial14blockOnOverrunEb>:
    hal_usart_half_duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a4056:	7441      	strb	r1, [r0, #17]
}
 80a4058:	4770      	bx	lr

080a405a <_ZN11USARTSerial17availableForWriteEv>:


int USARTSerial::availableForWrite(void)
{
 80a405a:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available_data_for_write(_serial));
 80a405c:	7c00      	ldrb	r0, [r0, #16]
 80a405e:	f7fe fe95 	bl	80a2d8c <hal_usart_available_data_for_write>
}
 80a4062:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a4066:	bd08      	pop	{r3, pc}

080a4068 <_ZN11USARTSerial9availableEv>:

int USARTSerial::available(void)
{
 80a4068:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available(_serial));
 80a406a:	7c00      	ldrb	r0, [r0, #16]
 80a406c:	f7fe fe66 	bl	80a2d3c <hal_usart_available>
}
 80a4070:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a4074:	bd08      	pop	{r3, pc}

080a4076 <_ZN11USARTSerial4peekEv>:

int USARTSerial::peek(void)
{
 80a4076:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_peek(_serial));
 80a4078:	7c00      	ldrb	r0, [r0, #16]
 80a407a:	f7fe fe6f 	bl	80a2d5c <hal_usart_peek>
}
 80a407e:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a4082:	bd08      	pop	{r3, pc}

080a4084 <_ZN11USARTSerial4readEv>:

int USARTSerial::read(void)
{
 80a4084:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_read(_serial));
 80a4086:	7c00      	ldrb	r0, [r0, #16]
 80a4088:	f7fe fe60 	bl	80a2d4c <hal_usart_read>
}
 80a408c:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a4090:	bd08      	pop	{r3, pc}

080a4092 <_ZN11USARTSerial5flushEv>:

void USARTSerial::flush()
{
  hal_usart_flush(_serial);
 80a4092:	7c00      	ldrb	r0, [r0, #16]
 80a4094:	f7fe be6a 	b.w	80a2d6c <hal_usart_flush>

080a4098 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a4098:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a409a:	7c46      	ldrb	r6, [r0, #17]
{
 80a409c:	4604      	mov	r4, r0
 80a409e:	460d      	mov	r5, r1
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a40a0:	b12e      	cbz	r6, 80a40ae <_ZN11USARTSerial5writeEh+0x16>
    // the HAL always blocks.
	  return hal_usart_write(_serial, c);
 80a40a2:	4629      	mov	r1, r5
 80a40a4:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a40a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	  return hal_usart_write(_serial, c);
 80a40aa:	f7fe be3f 	b.w	80a2d2c <hal_usart_write>
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a40ae:	7c00      	ldrb	r0, [r0, #16]
 80a40b0:	f7fe fe6c 	bl	80a2d8c <hal_usart_available_data_for_write>
 80a40b4:	2800      	cmp	r0, #0
 80a40b6:	dcf4      	bgt.n	80a40a2 <_ZN11USARTSerial5writeEh+0xa>
}
 80a40b8:	4630      	mov	r0, r6
 80a40ba:	bd70      	pop	{r4, r5, r6, pc}

080a40bc <_ZN11USARTSerialD0Ev>:
 80a40bc:	b510      	push	{r4, lr}
 80a40be:	4604      	mov	r4, r0
 80a40c0:	2114      	movs	r1, #20
 80a40c2:	f000 fae0 	bl	80a4686 <_ZdlPvj>
 80a40c6:	4620      	mov	r0, r4
 80a40c8:	bd10      	pop	{r4, pc}
	...

080a40cc <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_>:
 80a40cc:	f04f 0c00 	mov.w	ip, #0
USARTSerial::USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer)
 80a40d0:	b510      	push	{r4, lr}
 80a40d2:	4604      	mov	r4, r0
 80a40d4:	4608      	mov	r0, r1
 80a40d6:	4611      	mov	r1, r2
 80a40d8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a40dc:	e9c4 c201 	strd	ip, r2, [r4, #4]
 80a40e0:	4a04      	ldr	r2, [pc, #16]	; (80a40f4 <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_+0x28>)
  _serial = serial;
 80a40e2:	7420      	strb	r0, [r4, #16]
USARTSerial::USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer)
 80a40e4:	6022      	str	r2, [r4, #0]
  _blocking = true;
 80a40e6:	2201      	movs	r2, #1
 80a40e8:	7462      	strb	r2, [r4, #17]
  hal_usart_init(serial, rx_buffer, tx_buffer);
 80a40ea:	461a      	mov	r2, r3
 80a40ec:	f7fe fe16 	bl	80a2d1c <hal_usart_init>
}
 80a40f0:	4620      	mov	r0, r4
 80a40f2:	bd10      	pop	{r4, pc}
 80a40f4:	080a7370 	.word	0x080a7370

080a40f8 <_ZN11USARTSerial5beginEmm>:
  hal_usart_begin_config(_serial, baud, config, nullptr);
 80a40f8:	2300      	movs	r3, #0
 80a40fa:	7c00      	ldrb	r0, [r0, #16]
 80a40fc:	f7fe be4e 	b.w	80a2d9c <hal_usart_begin_config>

080a4100 <_ZN11USARTSerial5beginEm>:
  begin(baud, SERIAL_8N1);
 80a4100:	2200      	movs	r2, #0
 80a4102:	f7ff bff9 	b.w	80a40f8 <_ZN11USARTSerial5beginEmm>
	...

080a4108 <_Z22__fetch_global_Serial1v>:
static hal_usart_ring_buffer_t* serial1_rx_buffer = nullptr;
static hal_usart_ring_buffer_t* serial1_tx_buffer = nullptr;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a4108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
#else
  if (!serial1_rx_buffer) {
 80a410a:	4e1a      	ldr	r6, [pc, #104]	; (80a4174 <_Z22__fetch_global_Serial1v+0x6c>)
 80a410c:	6835      	ldr	r5, [r6, #0]
 80a410e:	b94d      	cbnz	r5, 80a4124 <_Z22__fetch_global_Serial1v+0x1c>
    serial1_rx_buffer = new hal_usart_ring_buffer_t();
 80a4110:	2084      	movs	r0, #132	; 0x84
 80a4112:	f7fb ffc2 	bl	80a009a <_Znwj>
 80a4116:	4604      	mov	r4, r0
 80a4118:	b118      	cbz	r0, 80a4122 <_Z22__fetch_global_Serial1v+0x1a>
 80a411a:	2284      	movs	r2, #132	; 0x84
 80a411c:	4629      	mov	r1, r5
 80a411e:	f002 fd4f 	bl	80a6bc0 <memset>
 80a4122:	6034      	str	r4, [r6, #0]
  }
  if (!serial1_tx_buffer) {
 80a4124:	4f14      	ldr	r7, [pc, #80]	; (80a4178 <_Z22__fetch_global_Serial1v+0x70>)
 80a4126:	683d      	ldr	r5, [r7, #0]
 80a4128:	b94d      	cbnz	r5, 80a413e <_Z22__fetch_global_Serial1v+0x36>
    serial1_tx_buffer = new hal_usart_ring_buffer_t();
 80a412a:	2084      	movs	r0, #132	; 0x84
 80a412c:	f7fb ffb5 	bl	80a009a <_Znwj>
 80a4130:	4604      	mov	r4, r0
 80a4132:	b118      	cbz	r0, 80a413c <_Z22__fetch_global_Serial1v+0x34>
 80a4134:	2284      	movs	r2, #132	; 0x84
 80a4136:	4629      	mov	r1, r5
 80a4138:	f002 fd42 	bl	80a6bc0 <memset>
 80a413c:	603c      	str	r4, [r7, #0]
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
 80a413e:	4d0f      	ldr	r5, [pc, #60]	; (80a417c <_Z22__fetch_global_Serial1v+0x74>)
 80a4140:	7829      	ldrb	r1, [r5, #0]
 80a4142:	f3bf 8f5b 	dmb	ish
 80a4146:	f011 0401 	ands.w	r4, r1, #1
 80a414a:	d111      	bne.n	80a4170 <_Z22__fetch_global_Serial1v+0x68>
 80a414c:	4628      	mov	r0, r5
 80a414e:	f7fb ffaa 	bl	80a00a6 <__cxa_guard_acquire>
 80a4152:	b168      	cbz	r0, 80a4170 <_Z22__fetch_global_Serial1v+0x68>
 80a4154:	4621      	mov	r1, r4
 80a4156:	6832      	ldr	r2, [r6, #0]
 80a4158:	683b      	ldr	r3, [r7, #0]
 80a415a:	4809      	ldr	r0, [pc, #36]	; (80a4180 <_Z22__fetch_global_Serial1v+0x78>)
 80a415c:	f7ff ffb6 	bl	80a40cc <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_>
 80a4160:	4628      	mov	r0, r5
 80a4162:	f7fb ffa5 	bl	80a00b0 <__cxa_guard_release>
 80a4166:	4a07      	ldr	r2, [pc, #28]	; (80a4184 <_Z22__fetch_global_Serial1v+0x7c>)
 80a4168:	4907      	ldr	r1, [pc, #28]	; (80a4188 <_Z22__fetch_global_Serial1v+0x80>)
 80a416a:	4805      	ldr	r0, [pc, #20]	; (80a4180 <_Z22__fetch_global_Serial1v+0x78>)
 80a416c:	f000 fa86 	bl	80a467c <__aeabi_atexit>
#endif
	return serial1;
}
 80a4170:	4803      	ldr	r0, [pc, #12]	; (80a4180 <_Z22__fetch_global_Serial1v+0x78>)
 80a4172:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a4174:	200005b4 	.word	0x200005b4
 80a4178:	200005b8 	.word	0x200005b8
 80a417c:	200005b0 	.word	0x200005b0
 80a4180:	200005bc 	.word	0x200005bc
 80a4184:	20000088 	.word	0x20000088
 80a4188:	080a4055 	.word	0x080a4055

080a418c <_ZN8particle6detail21futureCallbackWrapperEPv>:
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
 80a418c:	b510      	push	{r4, lr}
      if (_M_empty())
 80a418e:	6883      	ldr	r3, [r0, #8]
 80a4190:	4604      	mov	r4, r0
 80a4192:	b90b      	cbnz	r3, 80a4198 <_ZN8particle6detail21futureCallbackWrapperEPv+0xc>
	__throw_bad_function_call();
 80a4194:	f000 fa7b 	bl	80a468e <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a4198:	68c3      	ldr	r3, [r0, #12]
 80a419a:	4798      	blx	r3
      if (_M_manager)
 80a419c:	68a3      	ldr	r3, [r4, #8]
 80a419e:	b11b      	cbz	r3, 80a41a8 <_ZN8particle6detail21futureCallbackWrapperEPv+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a41a0:	2203      	movs	r2, #3
 80a41a2:	4621      	mov	r1, r4
 80a41a4:	4620      	mov	r0, r4
 80a41a6:	4798      	blx	r3
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
 80a41a8:	4620      	mov	r0, r4
}
 80a41aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    delete callbackPtr;
 80a41ae:	2110      	movs	r1, #16
 80a41b0:	f000 ba69 	b.w	80a4686 <_ZdlPvj>

080a41b4 <_ZN7TwoWireD1Ev>:
private:
  hal_i2c_interface_t _i2c;

public:
  TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& config);
  virtual ~TwoWire() {};
 80a41b4:	4770      	bx	lr

080a41b6 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a41b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a41b8:	4606      	mov	r6, r0
 80a41ba:	4615      	mov	r5, r2
 80a41bc:	460c      	mov	r4, r1
 80a41be:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a41c0:	42bc      	cmp	r4, r7
 80a41c2:	d006      	beq.n	80a41d2 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a41c4:	6833      	ldr	r3, [r6, #0]
 80a41c6:	4630      	mov	r0, r6
 80a41c8:	689b      	ldr	r3, [r3, #8]
 80a41ca:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a41ce:	4798      	blx	r3
  for(size_t i = 0; i < quantity; ++i)
 80a41d0:	e7f6      	b.n	80a41c0 <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
 80a41d2:	4628      	mov	r0, r5
 80a41d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a41d6 <_ZN7TwoWire5writeEh>:
  return hal_i2c_write(_i2c, data, NULL);
 80a41d6:	2200      	movs	r2, #0
 80a41d8:	7c00      	ldrb	r0, [r0, #16]
 80a41da:	f7fe bdff 	b.w	80a2ddc <hal_i2c_write>

080a41de <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return hal_i2c_available(_i2c, NULL);
 80a41de:	2100      	movs	r1, #0
 80a41e0:	7c00      	ldrb	r0, [r0, #16]
 80a41e2:	f7fe be03 	b.w	80a2dec <hal_i2c_available>

080a41e6 <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return hal_i2c_read(_i2c, NULL);
 80a41e6:	2100      	movs	r1, #0
 80a41e8:	7c00      	ldrb	r0, [r0, #16]
 80a41ea:	f7fe be07 	b.w	80a2dfc <hal_i2c_read>

080a41ee <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return hal_i2c_peek(_i2c, NULL);
 80a41ee:	2100      	movs	r1, #0
 80a41f0:	7c00      	ldrb	r0, [r0, #16]
 80a41f2:	f7fe be0b 	b.w	80a2e0c <hal_i2c_peek>

080a41f6 <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  hal_i2c_flush(_i2c, NULL);
 80a41f6:	2100      	movs	r1, #0
 80a41f8:	7c00      	ldrb	r0, [r0, #16]
 80a41fa:	f7fe be0f 	b.w	80a2e1c <hal_i2c_flush>

080a41fe <_ZN7TwoWireD0Ev>:
 80a41fe:	b510      	push	{r4, lr}
 80a4200:	4604      	mov	r4, r0
 80a4202:	2114      	movs	r1, #20
 80a4204:	f000 fa3f 	bl	80a4686 <_ZdlPvj>
 80a4208:	4620      	mov	r0, r4
 80a420a:	bd10      	pop	{r4, pc}

080a420c <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>:
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
 80a420c:	b510      	push	{r4, lr}
 80a420e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a4212:	4604      	mov	r4, r0
 80a4214:	4608      	mov	r0, r1
 80a4216:	2100      	movs	r1, #0
 80a4218:	e9c4 1301 	strd	r1, r3, [r4, #4]
 80a421c:	4b03      	ldr	r3, [pc, #12]	; (80a422c <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t+0x20>)
  hal_i2c_init(_i2c, &conf);
 80a421e:	4611      	mov	r1, r2
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
 80a4220:	6023      	str	r3, [r4, #0]
  _i2c = i2c;
 80a4222:	7420      	strb	r0, [r4, #16]
  hal_i2c_init(_i2c, &conf);
 80a4224:	f7fe fe0a 	bl	80a2e3c <hal_i2c_init>
}
 80a4228:	4620      	mov	r0, r4
 80a422a:	bd10      	pop	{r4, pc}
 80a422c:	080a73a0 	.word	0x080a73a0

080a4230 <_ZN7TwoWire5beginEv>:
	hal_i2c_begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
 80a4230:	2300      	movs	r3, #0
 80a4232:	7c00      	ldrb	r0, [r0, #16]
 80a4234:	461a      	mov	r2, r3
 80a4236:	4619      	mov	r1, r3
 80a4238:	f7fe bdb8 	b.w	80a2dac <hal_i2c_begin>

080a423c <_ZN7TwoWire11requestFromERK16WireTransmission>:
size_t TwoWire::requestFrom(const WireTransmission& transfer) {
 80a423c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    hal_i2c_transmission_config_t conf = {
 80a423e:	2200      	movs	r2, #0
 80a4240:	2314      	movs	r3, #20
 80a4242:	e9cd 2201 	strd	r2, r2, [sp, #4]
 80a4246:	f8ad 3004 	strh.w	r3, [sp, #4]
    };
 80a424a:	780b      	ldrb	r3, [r1, #0]
  return hal_i2c_request_ex(_i2c, &conf, nullptr);
 80a424c:	7c00      	ldrb	r0, [r0, #16]
 80a424e:	f88d 3008 	strb.w	r3, [sp, #8]
 80a4252:	684b      	ldr	r3, [r1, #4]
 80a4254:	9303      	str	r3, [sp, #12]
 80a4256:	68cb      	ldr	r3, [r1, #12]
 80a4258:	9304      	str	r3, [sp, #16]
      .flags = (uint32_t)(stop_ ? HAL_I2C_TRANSMISSION_FLAG_STOP : 0)
 80a425a:	7a0b      	ldrb	r3, [r1, #8]
 80a425c:	a901      	add	r1, sp, #4
 80a425e:	9305      	str	r3, [sp, #20]
 80a4260:	f7fe fdf6 	bl	80a2e50 <hal_i2c_request_ex>
}
 80a4264:	b007      	add	sp, #28
 80a4266:	f85d fb04 	ldr.w	pc, [sp], #4

080a426a <_ZN7TwoWire11requestFromEhjh>:
{
 80a426a:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  return requestFrom(WireTransmission(address).quantity(quantity).stop(sendStop));
 80a426c:	3b00      	subs	r3, #0
        timeout_{HAL_I2C_DEFAULT_TIMEOUT_MS} {
 80a426e:	f88d 1000 	strb.w	r1, [sp]
 80a4272:	f04f 0164 	mov.w	r1, #100	; 0x64
 80a4276:	bf18      	it	ne
 80a4278:	2301      	movne	r3, #1
 80a427a:	9103      	str	r1, [sp, #12]
 80a427c:	4669      	mov	r1, sp
    size_ = size;
 80a427e:	9201      	str	r2, [sp, #4]
 80a4280:	f88d 3008 	strb.w	r3, [sp, #8]
 80a4284:	f7ff ffda 	bl	80a423c <_ZN7TwoWire11requestFromERK16WireTransmission>
}
 80a4288:	b005      	add	sp, #20
 80a428a:	f85d fb04 	ldr.w	pc, [sp], #4

080a428e <_ZN7TwoWire11requestFromEhj>:
  return requestFrom(address, quantity, (uint8_t)true);
 80a428e:	2301      	movs	r3, #1
 80a4290:	f7ff bfeb 	b.w	80a426a <_ZN7TwoWire11requestFromEhjh>

080a4294 <_ZN7TwoWire17beginTransmissionEh>:
	hal_i2c_begin_transmission(_i2c, address, NULL);
 80a4294:	2200      	movs	r2, #0
 80a4296:	7c00      	ldrb	r0, [r0, #16]
 80a4298:	f7fe bd90 	b.w	80a2dbc <hal_i2c_begin_transmission>

080a429c <_ZN7TwoWire17beginTransmissionEi>:
  beginTransmission((uint8_t)address);
 80a429c:	b2c9      	uxtb	r1, r1
 80a429e:	f7ff bff9 	b.w	80a4294 <_ZN7TwoWire17beginTransmissionEh>

080a42a2 <_ZN7TwoWire15endTransmissionEh>:
	return hal_i2c_end_transmission(_i2c, sendStop, NULL);
 80a42a2:	2200      	movs	r2, #0
 80a42a4:	7c00      	ldrb	r0, [r0, #16]
 80a42a6:	f7fe bd91 	b.w	80a2dcc <hal_i2c_end_transmission>

080a42aa <_ZN7TwoWire15endTransmissionEv>:
  return endTransmission(true);
 80a42aa:	2101      	movs	r1, #1
 80a42ac:	f7ff bff9 	b.w	80a42a2 <_ZN7TwoWire15endTransmissionEh>

080a42b0 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a42b0:	2200      	movs	r2, #0
 80a42b2:	6840      	ldr	r0, [r0, #4]
 80a42b4:	4611      	mov	r1, r2
 80a42b6:	f7fe be73 	b.w	80a2fa0 <network_ready>

080a42ba <_ZN5spark9WiFiClass7resolveEPKc>:
    bool clearCredentials(void) {
        return network_clear_credentials(*this, 0, NULL, NULL);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a42ba:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a42bc:	4615      	mov	r5, r2
 80a42be:	b089      	sub	sp, #36	; 0x24
    {
        HAL_IPAddress ip = {};
 80a42c0:	2211      	movs	r2, #17
    IPAddress resolve(const char* name)
 80a42c2:	460e      	mov	r6, r1
 80a42c4:	4604      	mov	r4, r0
        HAL_IPAddress ip = {};
 80a42c6:	2100      	movs	r1, #0
 80a42c8:	a803      	add	r0, sp, #12
 80a42ca:	f002 fc79 	bl	80a6bc0 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a42ce:	4628      	mov	r0, r5
 80a42d0:	f002 fcd1 	bl	80a6c76 <strlen>
 80a42d4:	2700      	movs	r7, #0
 80a42d6:	b281      	uxth	r1, r0
 80a42d8:	6873      	ldr	r3, [r6, #4]
 80a42da:	4628      	mov	r0, r5
 80a42dc:	9700      	str	r7, [sp, #0]
 80a42de:	aa03      	add	r2, sp, #12
 80a42e0:	f7fe fe00 	bl	80a2ee4 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a42e4:	b130      	cbz	r0, 80a42f4 <_ZN5spark9WiFiClass7resolveEPKc+0x3a>
 80a42e6:	4639      	mov	r1, r7
 80a42e8:	4620      	mov	r0, r4
 80a42ea:	f7ff fdb1 	bl	80a3e50 <_ZN9IPAddressC1Em>
    }
 80a42ee:	4620      	mov	r0, r4
 80a42f0:	b009      	add	sp, #36	; 0x24
 80a42f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a42f4:	4620      	mov	r0, r4
 80a42f6:	a903      	add	r1, sp, #12
 80a42f8:	f7ff fd98 	bl	80a3e2c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
 80a42fc:	e7f7      	b.n	80a42ee <_ZN5spark9WiFiClass7resolveEPKc+0x34>

080a42fe <_ZN5spark9WiFiClass9listeningEv>:
        return network_listening(*this, 0, NULL);
 80a42fe:	2200      	movs	r2, #0
 80a4300:	6840      	ldr	r0, [r0, #4]
 80a4302:	4611      	mov	r1, r2
 80a4304:	f7fe be6c 	b.w	80a2fe0 <network_listening>

080a4308 <_ZN5spark9WiFiClass16getListenTimeoutEv>:
        return network_get_listen_timeout(*this, 0, NULL);
 80a4308:	2200      	movs	r2, #0
 80a430a:	6840      	ldr	r0, [r0, #4]
 80a430c:	4611      	mov	r1, r2
 80a430e:	f7fe be77 	b.w	80a3000 <network_get_listen_timeout>

080a4312 <_ZN5spark9WiFiClass16setListenTimeoutEt>:
        network_set_listen_timeout(*this, timeout, NULL);
 80a4312:	2200      	movs	r2, #0
 80a4314:	6840      	ldr	r0, [r0, #4]
 80a4316:	f7fe be6b 	b.w	80a2ff0 <network_set_listen_timeout>

080a431a <_ZN5spark9WiFiClass6listenEb>:
        network_listen(*this, begin ? 0 : 1, NULL);
 80a431a:	2200      	movs	r2, #0
 80a431c:	6840      	ldr	r0, [r0, #4]
 80a431e:	f081 0101 	eor.w	r1, r1, #1
 80a4322:	f7fe be55 	b.w	80a2fd0 <network_listen>

080a4326 <_ZN5spark9WiFiClass3offEv>:
        network_off(*this, 0, 0, NULL);
 80a4326:	2300      	movs	r3, #0
 80a4328:	6840      	ldr	r0, [r0, #4]
 80a432a:	461a      	mov	r2, r3
 80a432c:	4619      	mov	r1, r3
 80a432e:	f7fe be47 	b.w	80a2fc0 <network_off>

080a4332 <_ZN5spark9WiFiClass10connectingEv>:
        return network_connecting(*this, 0, NULL);
 80a4332:	2200      	movs	r2, #0
 80a4334:	6840      	ldr	r0, [r0, #4]
 80a4336:	4611      	mov	r1, r2
 80a4338:	f7fe be22 	b.w	80a2f80 <network_connecting>

080a433c <_ZN5spark9WiFiClass10disconnectEv>:
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a433c:	2200      	movs	r2, #0
 80a433e:	2102      	movs	r1, #2
 80a4340:	6840      	ldr	r0, [r0, #4]
 80a4342:	f7fe be25 	b.w	80a2f90 <network_disconnect>

080a4346 <_ZN5spark9WiFiClass7connectEj>:
        network_connect(*this, flags, 0, NULL);
 80a4346:	2300      	movs	r3, #0
 80a4348:	6840      	ldr	r0, [r0, #4]
 80a434a:	461a      	mov	r2, r3
 80a434c:	f7fe be10 	b.w	80a2f70 <network_connect>

080a4350 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
 80a4350:	2204      	movs	r2, #4
 80a4352:	4b02      	ldr	r3, [pc, #8]	; (80a435c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0xc>)
 80a4354:	605a      	str	r2, [r3, #4]
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
 80a4356:	4a02      	ldr	r2, [pc, #8]	; (80a4360 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a4358:	601a      	str	r2, [r3, #0]
the same way.
*****************************************************************************/

    WiFiClass WiFi;
    // NetworkClass& Network = WiFi;
}
 80a435a:	4770      	bx	lr
 80a435c:	200005d0 	.word	0x200005d0
 80a4360:	080a73c8 	.word	0x080a73c8

080a4364 <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
 80a4364:	2300      	movs	r3, #0
 80a4366:	6840      	ldr	r0, [r0, #4]
 80a4368:	461a      	mov	r2, r3
 80a436a:	f7fe be01 	b.w	80a2f70 <network_connect>

080a436e <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
 80a436e:	2200      	movs	r2, #0
 80a4370:	2102      	movs	r1, #2
 80a4372:	6840      	ldr	r0, [r0, #4]
 80a4374:	f7fe be0c 	b.w	80a2f90 <network_disconnect>

080a4378 <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
 80a4378:	2200      	movs	r2, #0
 80a437a:	6840      	ldr	r0, [r0, #4]
 80a437c:	4611      	mov	r1, r2
 80a437e:	f7fe bdff 	b.w	80a2f80 <network_connecting>

080a4382 <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
 80a4382:	2200      	movs	r2, #0
 80a4384:	6840      	ldr	r0, [r0, #4]
 80a4386:	4611      	mov	r1, r2
 80a4388:	f7fe be0a 	b.w	80a2fa0 <network_ready>

080a438c <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
 80a438c:	2300      	movs	r3, #0
 80a438e:	6840      	ldr	r0, [r0, #4]
 80a4390:	461a      	mov	r2, r3
 80a4392:	4619      	mov	r1, r3
 80a4394:	f7fe be0c 	b.w	80a2fb0 <network_on>

080a4398 <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
 80a4398:	2300      	movs	r3, #0
 80a439a:	6840      	ldr	r0, [r0, #4]
 80a439c:	461a      	mov	r2, r3
 80a439e:	4619      	mov	r1, r3
 80a43a0:	f7fe be0e 	b.w	80a2fc0 <network_off>

080a43a4 <_ZN5spark12NetworkClass4isOnEv>:
}

bool NetworkClass::isOn() {
    return network_is_on(*this, nullptr);
 80a43a4:	2100      	movs	r1, #0
 80a43a6:	6840      	ldr	r0, [r0, #4]
 80a43a8:	f7fe be32 	b.w	80a3010 <network_is_on>

080a43ac <_ZN5spark12NetworkClass5isOffEv>:
}

bool NetworkClass::isOff() {
    return network_is_off(*this, nullptr);
 80a43ac:	2100      	movs	r1, #0
 80a43ae:	6840      	ldr	r0, [r0, #4]
 80a43b0:	f7fe be36 	b.w	80a3020 <network_is_off>

080a43b4 <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
 80a43b4:	2200      	movs	r2, #0
 80a43b6:	6840      	ldr	r0, [r0, #4]
 80a43b8:	f081 0101 	eor.w	r1, r1, #1
 80a43bc:	f7fe be08 	b.w	80a2fd0 <network_listen>

080a43c0 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
 80a43c0:	2200      	movs	r2, #0
 80a43c2:	6840      	ldr	r0, [r0, #4]
 80a43c4:	f7fe be14 	b.w	80a2ff0 <network_set_listen_timeout>

080a43c8 <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
 80a43c8:	2200      	movs	r2, #0
 80a43ca:	6840      	ldr	r0, [r0, #4]
 80a43cc:	4611      	mov	r1, r2
 80a43ce:	f7fe be17 	b.w	80a3000 <network_get_listen_timeout>

080a43d2 <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
 80a43d2:	2200      	movs	r2, #0
 80a43d4:	6840      	ldr	r0, [r0, #4]
 80a43d6:	4611      	mov	r1, r2
 80a43d8:	f7fe be02 	b.w	80a2fe0 <network_listening>

080a43dc <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
 80a43dc:	b570      	push	{r4, r5, r6, lr}
 80a43de:	4615      	mov	r5, r2
 80a43e0:	b08e      	sub	sp, #56	; 0x38
 80a43e2:	4604      	mov	r4, r0
    IPAddress addr;
 80a43e4:	a808      	add	r0, sp, #32
 80a43e6:	f7ff fd13 	bl	80a3e10 <_ZN9IPAddressC1Ev>
        HAL_IPAddress ip = {};
 80a43ea:	2211      	movs	r2, #17
 80a43ec:	2100      	movs	r1, #0
 80a43ee:	a803      	add	r0, sp, #12
 80a43f0:	f002 fbe6 	bl	80a6bc0 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a43f4:	2600      	movs	r6, #0
 80a43f6:	4628      	mov	r0, r5
 80a43f8:	f002 fc3d 	bl	80a6c76 <strlen>
 80a43fc:	4b0a      	ldr	r3, [pc, #40]	; (80a4428 <_ZN5spark12NetworkClass7resolveEPKc+0x4c>)
 80a43fe:	9600      	str	r6, [sp, #0]
 80a4400:	b281      	uxth	r1, r0
 80a4402:	685b      	ldr	r3, [r3, #4]
 80a4404:	4628      	mov	r0, r5
 80a4406:	aa03      	add	r2, sp, #12
 80a4408:	f7fe fd6c 	bl	80a2ee4 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a440c:	b130      	cbz	r0, 80a441c <_ZN5spark12NetworkClass7resolveEPKc+0x40>
 80a440e:	4631      	mov	r1, r6
 80a4410:	4620      	mov	r0, r4
 80a4412:	f7ff fd1d 	bl	80a3e50 <_ZN9IPAddressC1Em>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
 80a4416:	4620      	mov	r0, r4
 80a4418:	b00e      	add	sp, #56	; 0x38
 80a441a:	bd70      	pop	{r4, r5, r6, pc}
 80a441c:	4620      	mov	r0, r4
 80a441e:	a903      	add	r1, sp, #12
 80a4420:	f7ff fd04 	bl	80a3e2c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    virtual ~IPAddress() {}
 80a4424:	e7f7      	b.n	80a4416 <_ZN5spark12NetworkClass7resolveEPKc+0x3a>
 80a4426:	bf00      	nop
 80a4428:	200005d0 	.word	0x200005d0

080a442c <_GLOBAL__sub_I__ZN5spark7NetworkE>:
 80a442c:	4b02      	ldr	r3, [pc, #8]	; (80a4438 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
 80a442e:	4a03      	ldr	r2, [pc, #12]	; (80a443c <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
 80a4430:	601a      	str	r2, [r3, #0]
 80a4432:	2200      	movs	r2, #0
 80a4434:	605a      	str	r2, [r3, #4]

} // spark
 80a4436:	4770      	bx	lr
 80a4438:	200005d8 	.word	0x200005d8
 80a443c:	080a7404 	.word	0x080a7404

080a4440 <_ZN8SPIClassD1Ev>:
  RecursiveMutex _mutex;
#endif

public:
  SPIClass(hal_spi_interface_t spi);
  ~SPIClass() = default;
 80a4440:	b510      	push	{r4, lr}
 80a4442:	4604      	mov	r4, r0
        dispose();
    }

    void dispose()
    {
        if (handle_) {
 80a4444:	6880      	ldr	r0, [r0, #8]
 80a4446:	b108      	cbz	r0, 80a444c <_ZN8SPIClassD1Ev+0xc>
            os_mutex_recursive_destroy(handle_);
 80a4448:	f7fe fc60 	bl	80a2d0c <os_mutex_recursive_destroy>
 80a444c:	4620      	mov	r0, r4
 80a444e:	bd10      	pop	{r4, pc}

080a4450 <pinAvailable>:
/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
  if (pin >= TOTAL_PINS) {
 80a4450:	2817      	cmp	r0, #23
bool pinAvailable(uint16_t pin) {
 80a4452:	b570      	push	{r4, r5, r6, lr}
 80a4454:	4604      	mov	r4, r0
  if (pin >= TOTAL_PINS) {
 80a4456:	d901      	bls.n	80a445c <pinAvailable+0xc>
    return false;
 80a4458:	2000      	movs	r0, #0
    return false; // 'pin' is used
  }
#endif

  return true; // 'pin' is available
}
 80a445a:	bd70      	pop	{r4, r5, r6, pc}
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
 80a445c:	f1a0 030d 	sub.w	r3, r0, #13
 80a4460:	2b02      	cmp	r3, #2
 80a4462:	d90b      	bls.n	80a447c <pinAvailable+0x2c>
  if((pin == SCL || pin == SDA) && hal_i2c_is_enabled(Wire.interface(), nullptr) == true)
 80a4464:	2801      	cmp	r0, #1
 80a4466:	d826      	bhi.n	80a44b6 <pinAvailable+0x66>
 80a4468:	f000 f8e0 	bl	80a462c <_Z19__fetch_global_Wirev>
 80a446c:	2100      	movs	r1, #0
 80a446e:	7c00      	ldrb	r0, [r0, #16]
 80a4470:	f7fe fcdc 	bl	80a2e2c <hal_i2c_is_enabled>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
 80a4474:	f080 0001 	eor.w	r0, r0, #1
 80a4478:	b2c0      	uxtb	r0, r0
 80a447a:	e7ee      	b.n	80a445a <pinAvailable+0xa>

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
 80a447c:	4e13      	ldr	r6, [pc, #76]	; (80a44cc <pinAvailable+0x7c>)
 80a447e:	7831      	ldrb	r1, [r6, #0]
 80a4480:	f3bf 8f5b 	dmb	ish
 80a4484:	f011 0501 	ands.w	r5, r1, #1
 80a4488:	d10f      	bne.n	80a44aa <pinAvailable+0x5a>
 80a448a:	4630      	mov	r0, r6
 80a448c:	f7fb fe0b 	bl	80a00a6 <__cxa_guard_acquire>
 80a4490:	b158      	cbz	r0, 80a44aa <pinAvailable+0x5a>
 80a4492:	4629      	mov	r1, r5
 80a4494:	480e      	ldr	r0, [pc, #56]	; (80a44d0 <pinAvailable+0x80>)
 80a4496:	f7fe fe5b 	bl	80a3150 <_ZN8SPIClassC1E19hal_spi_interface_t>
 80a449a:	4630      	mov	r0, r6
 80a449c:	f7fb fe08 	bl	80a00b0 <__cxa_guard_release>
 80a44a0:	4a0c      	ldr	r2, [pc, #48]	; (80a44d4 <pinAvailable+0x84>)
 80a44a2:	490d      	ldr	r1, [pc, #52]	; (80a44d8 <pinAvailable+0x88>)
 80a44a4:	480a      	ldr	r0, [pc, #40]	; (80a44d0 <pinAvailable+0x80>)
 80a44a6:	f000 f8e9 	bl	80a467c <__aeabi_atexit>
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
 80a44aa:	4b09      	ldr	r3, [pc, #36]	; (80a44d0 <pinAvailable+0x80>)
 80a44ac:	7818      	ldrb	r0, [r3, #0]
 80a44ae:	f7fe fce1 	bl	80a2e74 <hal_spi_is_enabled>
 80a44b2:	2800      	cmp	r0, #0
 80a44b4:	d1d0      	bne.n	80a4458 <pinAvailable+0x8>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
 80a44b6:	3c12      	subs	r4, #18
 80a44b8:	2c01      	cmp	r4, #1
 80a44ba:	d805      	bhi.n	80a44c8 <pinAvailable+0x78>
 80a44bc:	f7ff fe24 	bl	80a4108 <_Z22__fetch_global_Serial1v>
 80a44c0:	7c00      	ldrb	r0, [r0, #16]
 80a44c2:	f7fe fc5b 	bl	80a2d7c <hal_usart_is_enabled>
 80a44c6:	e7d5      	b.n	80a4474 <pinAvailable+0x24>
  return true; // 'pin' is available
 80a44c8:	2001      	movs	r0, #1
 80a44ca:	e7c6      	b.n	80a445a <pinAvailable+0xa>
 80a44cc:	200005e0 	.word	0x200005e0
 80a44d0:	200005e4 	.word	0x200005e4
 80a44d4:	20000088 	.word	0x20000088
 80a44d8:	080a4441 	.word	0x080a4441

080a44dc <pinMode>:
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a44dc:	2817      	cmp	r0, #23
{
 80a44de:	b538      	push	{r3, r4, r5, lr}
 80a44e0:	4604      	mov	r4, r0
 80a44e2:	460d      	mov	r5, r1
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a44e4:	d80a      	bhi.n	80a44fc <pinMode+0x20>
 80a44e6:	29ff      	cmp	r1, #255	; 0xff
 80a44e8:	d008      	beq.n	80a44fc <pinMode+0x20>
  if( !pinAvailable(pin) ) {
 80a44ea:	f7ff ffb1 	bl	80a4450 <pinAvailable>
 80a44ee:	b128      	cbz	r0, 80a44fc <pinMode+0x20>
  HAL_Pin_Mode(pin, setMode);
 80a44f0:	4629      	mov	r1, r5
 80a44f2:	4620      	mov	r0, r4
}
 80a44f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_Pin_Mode(pin, setMode);
 80a44f8:	f7fe bb90 	b.w	80a2c1c <HAL_Pin_Mode>
}
 80a44fc:	bd38      	pop	{r3, r4, r5, pc}

080a44fe <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a44fe:	b538      	push	{r3, r4, r5, lr}
 80a4500:	4604      	mov	r4, r0
 80a4502:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a4504:	f7fe fb92 	bl	80a2c2c <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a4508:	28ff      	cmp	r0, #255	; 0xff
 80a450a:	d010      	beq.n	80a452e <digitalWrite+0x30>
            mode == INPUT_PULLDOWN ||
 80a450c:	2806      	cmp	r0, #6
 80a450e:	d804      	bhi.n	80a451a <digitalWrite+0x1c>
 80a4510:	234d      	movs	r3, #77	; 0x4d
 80a4512:	fa23 f000 	lsr.w	r0, r3, r0
 80a4516:	07c3      	lsls	r3, r0, #31
 80a4518:	d409      	bmi.n	80a452e <digitalWrite+0x30>
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a451a:	4620      	mov	r0, r4
 80a451c:	f7ff ff98 	bl	80a4450 <pinAvailable>
 80a4520:	b128      	cbz	r0, 80a452e <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a4522:	4629      	mov	r1, r5
 80a4524:	4620      	mov	r0, r4
}
 80a4526:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_GPIO_Write(pin, value);
 80a452a:	f7fe bb87 	b.w	80a2c3c <HAL_GPIO_Write>
}
 80a452e:	bd38      	pop	{r3, r4, r5, pc}

080a4530 <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
 80a4530:	b510      	push	{r4, lr}
 80a4532:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a4534:	f7fe fb7a 	bl	80a2c2c <HAL_Get_Pin_Mode>
    return mode == AF_OUTPUT_PUSHPULL ||
 80a4538:	1f03      	subs	r3, r0, #4
    if (is_af_output_mode(mode))
 80a453a:	b2db      	uxtb	r3, r3
 80a453c:	2b01      	cmp	r3, #1
 80a453e:	d908      	bls.n	80a4552 <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
 80a4540:	4620      	mov	r0, r4
 80a4542:	f7ff ff85 	bl	80a4450 <pinAvailable>
 80a4546:	b120      	cbz	r0, 80a4552 <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a4548:	4620      	mov	r0, r4
}
 80a454a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return HAL_GPIO_Read(pin);
 80a454e:	f7fe bb7d 	b.w	80a2c4c <HAL_GPIO_Read>
}
 80a4552:	2000      	movs	r0, #0
 80a4554:	bd10      	pop	{r4, pc}

080a4556 <analogRead>:
 * @brief Read the analog value of a pin.
 * Should return a 16-bit value, 0-65536 (0 = LOW, 65536 = HIGH)
 * Note: ADC is 12-bit. Currently it returns 0-4095
 */
int32_t analogRead(pin_t pin)
{
 80a4556:	b510      	push	{r4, lr}
 80a4558:	4604      	mov	r4, r0
  // Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
  if(pin < FIRST_ANALOG_PIN)
 80a455a:	2809      	cmp	r0, #9
  {
    pin = pin + FIRST_ANALOG_PIN;
 80a455c:	bf9c      	itt	ls
 80a455e:	340a      	addls	r4, #10
 80a4560:	b2a4      	uxthls	r4, r4
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a4562:	4620      	mov	r0, r4
 80a4564:	f7ff ff74 	bl	80a4450 <pinAvailable>
 80a4568:	b150      	cbz	r0, 80a4580 <analogRead+0x2a>
    return LOW;
  }

  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
 80a456a:	2103      	movs	r1, #3
 80a456c:	4620      	mov	r0, r4
 80a456e:	f7fe fb4d 	bl	80a2c0c <HAL_Validate_Pin_Function>
 80a4572:	2803      	cmp	r0, #3
 80a4574:	d104      	bne.n	80a4580 <analogRead+0x2a>
  {
    return LOW;
  }

  return hal_adc_read(pin);
 80a4576:	4620      	mov	r0, r4
}
 80a4578:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return hal_adc_read(pin);
 80a457c:	f7fe bb96 	b.w	80a2cac <hal_adc_read>
}
 80a4580:	2000      	movs	r0, #0
 80a4582:	bd10      	pop	{r4, pc}

080a4584 <_Z11analogWritetm>:
/*
 * @brief Should take an integer 0-255 and create a 500Hz PWM signal with a duty cycle from 0-100%.
 * On Photon, DAC1 and DAC2 act as true analog outputs(values: 0 to 4095) using onchip DAC peripheral
 */
void analogWrite(pin_t pin, uint32_t value)
{
 80a4584:	b538      	push	{r3, r4, r5, lr}
 80a4586:	4604      	mov	r4, r0
 80a4588:	460d      	mov	r5, r1
    // Safety check
    if (!pinAvailable(pin))
 80a458a:	f7ff ff61 	bl	80a4450 <pinAvailable>
 80a458e:	b1f0      	cbz	r0, 80a45ce <_Z11analogWritetm+0x4a>
    {
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
 80a4590:	2104      	movs	r1, #4
 80a4592:	4620      	mov	r0, r4
 80a4594:	f7fe fb3a 	bl	80a2c0c <HAL_Validate_Pin_Function>
 80a4598:	2804      	cmp	r0, #4
 80a459a:	d105      	bne.n	80a45a8 <_Z11analogWritetm+0x24>
    {
        HAL_DAC_Write(pin, value);
 80a459c:	4620      	mov	r0, r4
 80a459e:	b2a9      	uxth	r1, r5
            return;
        }

        hal_pwm_write_ext(pin, value);
    }
}
 80a45a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        HAL_DAC_Write(pin, value);
 80a45a4:	f7fe bb7a 	b.w	80a2c9c <HAL_DAC_Write>
    else if (HAL_Validate_Pin_Function(pin, PF_TIMER) == PF_TIMER)
 80a45a8:	2102      	movs	r1, #2
 80a45aa:	4620      	mov	r0, r4
 80a45ac:	f7fe fb2e 	bl	80a2c0c <HAL_Validate_Pin_Function>
 80a45b0:	2802      	cmp	r0, #2
 80a45b2:	d10c      	bne.n	80a45ce <_Z11analogWritetm+0x4a>
        PinMode mode = HAL_Get_Pin_Mode(pin);
 80a45b4:	4620      	mov	r0, r4
 80a45b6:	f7fe fb39 	bl	80a2c2c <HAL_Get_Pin_Mode>
        if (mode != OUTPUT && mode != AF_OUTPUT_PUSHPULL)
 80a45ba:	2801      	cmp	r0, #1
 80a45bc:	d001      	beq.n	80a45c2 <_Z11analogWritetm+0x3e>
 80a45be:	2804      	cmp	r0, #4
 80a45c0:	d105      	bne.n	80a45ce <_Z11analogWritetm+0x4a>
        hal_pwm_write_ext(pin, value);
 80a45c2:	4629      	mov	r1, r5
 80a45c4:	4620      	mov	r0, r4
}
 80a45c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        hal_pwm_write_ext(pin, value);
 80a45ca:	f7fe bb77 	b.w	80a2cbc <hal_pwm_write_ext>
}
 80a45ce:	bd38      	pop	{r3, r4, r5, pc}

080a45d0 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

#if !HAL_USE_SOCKET_HAL_POSIX
const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a45d0:	2300      	movs	r3, #0
 80a45d2:	b513      	push	{r0, r1, r4, lr}
 80a45d4:	4c07      	ldr	r4, [pc, #28]	; (80a45f4 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a45d6:	461a      	mov	r2, r3
 80a45d8:	4619      	mov	r1, r3
 80a45da:	4620      	mov	r0, r4
 80a45dc:	9300      	str	r3, [sp, #0]
 80a45de:	f7ff fc4d 	bl	80a3e7c <_ZN9IPAddressC1Ehhhh>
 80a45e2:	4620      	mov	r0, r4
 80a45e4:	4a04      	ldr	r2, [pc, #16]	; (80a45f8 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a45e6:	4905      	ldr	r1, [pc, #20]	; (80a45fc <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a45e8:	b002      	add	sp, #8
 80a45ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a45ee:	f000 b845 	b.w	80a467c <__aeabi_atexit>
 80a45f2:	bf00      	nop
 80a45f4:	200005f4 	.word	0x200005f4
 80a45f8:	20000088 	.word	0x20000088
 80a45fc:	080a3dcd 	.word	0x080a3dcd

080a4600 <_Z17acquireWireBufferv>:
}

} // anonymous

hal_i2c_config_t __attribute__((weak)) acquireWireBuffer()
{
 80a4600:	b570      	push	{r4, r5, r6, lr}
	hal_i2c_config_t config = {
 80a4602:	2314      	movs	r3, #20
 80a4604:	2520      	movs	r5, #32
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a4606:	4e08      	ldr	r6, [pc, #32]	; (80a4628 <_Z17acquireWireBufferv+0x28>)
{
 80a4608:	4604      	mov	r4, r0
	hal_i2c_config_t config = {
 80a460a:	6003      	str	r3, [r0, #0]
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a460c:	4631      	mov	r1, r6
	hal_i2c_config_t config = {
 80a460e:	6085      	str	r5, [r0, #8]
 80a4610:	6105      	str	r5, [r0, #16]
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a4612:	4628      	mov	r0, r5
 80a4614:	f000 f839 	bl	80a468a <_ZnajRKSt9nothrow_t>
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a4618:	4631      	mov	r1, r6
	};
 80a461a:	6060      	str	r0, [r4, #4]
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a461c:	4628      	mov	r0, r5
 80a461e:	f000 f834 	bl	80a468a <_ZnajRKSt9nothrow_t>
	};
 80a4622:	60e0      	str	r0, [r4, #12]
	return defaultWireConfig();
}
 80a4624:	4620      	mov	r0, r4
 80a4626:	bd70      	pop	{r4, r5, r6, pc}
 80a4628:	080a7438 	.word	0x080a7438

080a462c <_Z19__fetch_global_Wirev>:
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
 80a462c:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a462e:	4d0f      	ldr	r5, [pc, #60]	; (80a466c <_Z19__fetch_global_Wirev+0x40>)
{
 80a4630:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a4632:	7829      	ldrb	r1, [r5, #0]
 80a4634:	f3bf 8f5b 	dmb	ish
 80a4638:	f011 0401 	ands.w	r4, r1, #1
 80a463c:	d113      	bne.n	80a4666 <_Z19__fetch_global_Wirev+0x3a>
 80a463e:	4628      	mov	r0, r5
 80a4640:	f7fb fd31 	bl	80a00a6 <__cxa_guard_acquire>
 80a4644:	b178      	cbz	r0, 80a4666 <_Z19__fetch_global_Wirev+0x3a>
 80a4646:	a801      	add	r0, sp, #4
 80a4648:	f7ff ffda 	bl	80a4600 <_Z17acquireWireBufferv>
 80a464c:	4621      	mov	r1, r4
 80a464e:	aa01      	add	r2, sp, #4
 80a4650:	4807      	ldr	r0, [pc, #28]	; (80a4670 <_Z19__fetch_global_Wirev+0x44>)
 80a4652:	f7ff fddb 	bl	80a420c <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>
 80a4656:	4628      	mov	r0, r5
 80a4658:	f7fb fd2a 	bl	80a00b0 <__cxa_guard_release>
 80a465c:	4a05      	ldr	r2, [pc, #20]	; (80a4674 <_Z19__fetch_global_Wirev+0x48>)
 80a465e:	4906      	ldr	r1, [pc, #24]	; (80a4678 <_Z19__fetch_global_Wirev+0x4c>)
 80a4660:	4803      	ldr	r0, [pc, #12]	; (80a4670 <_Z19__fetch_global_Wirev+0x44>)
 80a4662:	f000 f80b 	bl	80a467c <__aeabi_atexit>
	return wire;
}
 80a4666:	4802      	ldr	r0, [pc, #8]	; (80a4670 <_Z19__fetch_global_Wirev+0x44>)
 80a4668:	b007      	add	sp, #28
 80a466a:	bd30      	pop	{r4, r5, pc}
 80a466c:	2000060c 	.word	0x2000060c
 80a4670:	20000610 	.word	0x20000610
 80a4674:	20000088 	.word	0x20000088
 80a4678:	080a41b5 	.word	0x080a41b5

080a467c <__aeabi_atexit>:
 80a467c:	460b      	mov	r3, r1
 80a467e:	4601      	mov	r1, r0
 80a4680:	4618      	mov	r0, r3
 80a4682:	f002 ba81 	b.w	80a6b88 <__cxa_atexit>

080a4686 <_ZdlPvj>:
 80a4686:	f7fb bd0c 	b.w	80a00a2 <_ZdlPv>

080a468a <_ZnajRKSt9nothrow_t>:
 80a468a:	f7fb bd08 	b.w	80a009e <_Znaj>

080a468e <_ZSt25__throw_bad_function_callv>:
 80a468e:	b508      	push	{r3, lr}
 80a4690:	f7fe fd36 	bl	80a3100 <abort>

080a4694 <log>:
 80a4694:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a4696:	4604      	mov	r4, r0
 80a4698:	460d      	mov	r5, r1
 80a469a:	f000 f8f5 	bl	80a4888 <__ieee754_log>
 80a469e:	4b17      	ldr	r3, [pc, #92]	; (80a46fc <log+0x68>)
 80a46a0:	4606      	mov	r6, r0
 80a46a2:	f993 3000 	ldrsb.w	r3, [r3]
 80a46a6:	460f      	mov	r7, r1
 80a46a8:	3301      	adds	r3, #1
 80a46aa:	d01a      	beq.n	80a46e2 <log+0x4e>
 80a46ac:	4622      	mov	r2, r4
 80a46ae:	462b      	mov	r3, r5
 80a46b0:	4620      	mov	r0, r4
 80a46b2:	4629      	mov	r1, r5
 80a46b4:	f001 fe98 	bl	80a63e8 <__aeabi_dcmpun>
 80a46b8:	b998      	cbnz	r0, 80a46e2 <log+0x4e>
 80a46ba:	2200      	movs	r2, #0
 80a46bc:	2300      	movs	r3, #0
 80a46be:	4620      	mov	r0, r4
 80a46c0:	4629      	mov	r1, r5
 80a46c2:	f001 fe87 	bl	80a63d4 <__aeabi_dcmpgt>
 80a46c6:	b960      	cbnz	r0, 80a46e2 <log+0x4e>
 80a46c8:	2200      	movs	r2, #0
 80a46ca:	2300      	movs	r3, #0
 80a46cc:	4620      	mov	r0, r4
 80a46ce:	4629      	mov	r1, r5
 80a46d0:	f001 fe58 	bl	80a6384 <__aeabi_dcmpeq>
 80a46d4:	b140      	cbz	r0, 80a46e8 <log+0x54>
 80a46d6:	f7fe fd23 	bl	80a3120 <__errno>
 80a46da:	2322      	movs	r3, #34	; 0x22
 80a46dc:	2600      	movs	r6, #0
 80a46de:	4f08      	ldr	r7, [pc, #32]	; (80a4700 <log+0x6c>)
 80a46e0:	6003      	str	r3, [r0, #0]
 80a46e2:	4630      	mov	r0, r6
 80a46e4:	4639      	mov	r1, r7
 80a46e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a46e8:	f7fe fd1a 	bl	80a3120 <__errno>
 80a46ec:	2221      	movs	r2, #33	; 0x21
 80a46ee:	4603      	mov	r3, r0
 80a46f0:	4804      	ldr	r0, [pc, #16]	; (80a4704 <log+0x70>)
 80a46f2:	601a      	str	r2, [r3, #0]
 80a46f4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80a46f8:	f001 b8fe 	b.w	80a58f8 <nan>
 80a46fc:	20000020 	.word	0x20000020
 80a4700:	fff00000 	.word	0xfff00000
 80a4704:	080a743c 	.word	0x080a743c

080a4708 <pow>:
 80a4708:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a470c:	461d      	mov	r5, r3
 80a470e:	4606      	mov	r6, r0
 80a4710:	460f      	mov	r7, r1
 80a4712:	4614      	mov	r4, r2
 80a4714:	f000 fab8 	bl	80a4c88 <__ieee754_pow>
 80a4718:	4b57      	ldr	r3, [pc, #348]	; (80a4878 <pow+0x170>)
 80a471a:	4680      	mov	r8, r0
 80a471c:	f993 3000 	ldrsb.w	r3, [r3]
 80a4720:	4689      	mov	r9, r1
 80a4722:	3301      	adds	r3, #1
 80a4724:	d02a      	beq.n	80a477c <pow+0x74>
 80a4726:	4622      	mov	r2, r4
 80a4728:	462b      	mov	r3, r5
 80a472a:	4620      	mov	r0, r4
 80a472c:	4629      	mov	r1, r5
 80a472e:	f001 fe5b 	bl	80a63e8 <__aeabi_dcmpun>
 80a4732:	bb18      	cbnz	r0, 80a477c <pow+0x74>
 80a4734:	4632      	mov	r2, r6
 80a4736:	463b      	mov	r3, r7
 80a4738:	4630      	mov	r0, r6
 80a473a:	4639      	mov	r1, r7
 80a473c:	f001 fe54 	bl	80a63e8 <__aeabi_dcmpun>
 80a4740:	2800      	cmp	r0, #0
 80a4742:	d141      	bne.n	80a47c8 <pow+0xc0>
 80a4744:	2200      	movs	r2, #0
 80a4746:	2300      	movs	r3, #0
 80a4748:	4630      	mov	r0, r6
 80a474a:	4639      	mov	r1, r7
 80a474c:	f001 fe1a 	bl	80a6384 <__aeabi_dcmpeq>
 80a4750:	b1c0      	cbz	r0, 80a4784 <pow+0x7c>
 80a4752:	2200      	movs	r2, #0
 80a4754:	2300      	movs	r3, #0
 80a4756:	4620      	mov	r0, r4
 80a4758:	4629      	mov	r1, r5
 80a475a:	f001 fe13 	bl	80a6384 <__aeabi_dcmpeq>
 80a475e:	2800      	cmp	r0, #0
 80a4760:	d13a      	bne.n	80a47d8 <pow+0xd0>
 80a4762:	4620      	mov	r0, r4
 80a4764:	4629      	mov	r1, r5
 80a4766:	f001 f8c1 	bl	80a58ec <finite>
 80a476a:	b138      	cbz	r0, 80a477c <pow+0x74>
 80a476c:	4620      	mov	r0, r4
 80a476e:	4629      	mov	r1, r5
 80a4770:	2200      	movs	r2, #0
 80a4772:	2300      	movs	r3, #0
 80a4774:	f001 fe10 	bl	80a6398 <__aeabi_dcmplt>
 80a4778:	2800      	cmp	r0, #0
 80a477a:	d159      	bne.n	80a4830 <pow+0x128>
 80a477c:	4640      	mov	r0, r8
 80a477e:	4649      	mov	r1, r9
 80a4780:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a4784:	4640      	mov	r0, r8
 80a4786:	4649      	mov	r1, r9
 80a4788:	f001 f8b0 	bl	80a58ec <finite>
 80a478c:	b360      	cbz	r0, 80a47e8 <pow+0xe0>
 80a478e:	2200      	movs	r2, #0
 80a4790:	2300      	movs	r3, #0
 80a4792:	4640      	mov	r0, r8
 80a4794:	4649      	mov	r1, r9
 80a4796:	f001 fdf5 	bl	80a6384 <__aeabi_dcmpeq>
 80a479a:	2800      	cmp	r0, #0
 80a479c:	d0ee      	beq.n	80a477c <pow+0x74>
 80a479e:	4630      	mov	r0, r6
 80a47a0:	4639      	mov	r1, r7
 80a47a2:	f001 f8a3 	bl	80a58ec <finite>
 80a47a6:	2800      	cmp	r0, #0
 80a47a8:	d0e8      	beq.n	80a477c <pow+0x74>
 80a47aa:	4620      	mov	r0, r4
 80a47ac:	4629      	mov	r1, r5
 80a47ae:	f001 f89d 	bl	80a58ec <finite>
 80a47b2:	2800      	cmp	r0, #0
 80a47b4:	d0e2      	beq.n	80a477c <pow+0x74>
 80a47b6:	f7fe fcb3 	bl	80a3120 <__errno>
 80a47ba:	2322      	movs	r3, #34	; 0x22
 80a47bc:	f04f 0800 	mov.w	r8, #0
 80a47c0:	f04f 0900 	mov.w	r9, #0
 80a47c4:	6003      	str	r3, [r0, #0]
 80a47c6:	e7d9      	b.n	80a477c <pow+0x74>
 80a47c8:	4620      	mov	r0, r4
 80a47ca:	4629      	mov	r1, r5
 80a47cc:	2200      	movs	r2, #0
 80a47ce:	2300      	movs	r3, #0
 80a47d0:	f001 fdd8 	bl	80a6384 <__aeabi_dcmpeq>
 80a47d4:	2800      	cmp	r0, #0
 80a47d6:	d0d1      	beq.n	80a477c <pow+0x74>
 80a47d8:	f04f 0800 	mov.w	r8, #0
 80a47dc:	f8df 909c 	ldr.w	r9, [pc, #156]	; 80a487c <pow+0x174>
 80a47e0:	4640      	mov	r0, r8
 80a47e2:	4649      	mov	r1, r9
 80a47e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a47e8:	4630      	mov	r0, r6
 80a47ea:	4639      	mov	r1, r7
 80a47ec:	f001 f87e 	bl	80a58ec <finite>
 80a47f0:	2800      	cmp	r0, #0
 80a47f2:	d0cc      	beq.n	80a478e <pow+0x86>
 80a47f4:	4620      	mov	r0, r4
 80a47f6:	4629      	mov	r1, r5
 80a47f8:	f001 f878 	bl	80a58ec <finite>
 80a47fc:	2800      	cmp	r0, #0
 80a47fe:	d0c6      	beq.n	80a478e <pow+0x86>
 80a4800:	4642      	mov	r2, r8
 80a4802:	464b      	mov	r3, r9
 80a4804:	4640      	mov	r0, r8
 80a4806:	4649      	mov	r1, r9
 80a4808:	f001 fdee 	bl	80a63e8 <__aeabi_dcmpun>
 80a480c:	bb30      	cbnz	r0, 80a485c <pow+0x154>
 80a480e:	f7fe fc87 	bl	80a3120 <__errno>
 80a4812:	2222      	movs	r2, #34	; 0x22
 80a4814:	4603      	mov	r3, r0
 80a4816:	4639      	mov	r1, r7
 80a4818:	601a      	str	r2, [r3, #0]
 80a481a:	4630      	mov	r0, r6
 80a481c:	2200      	movs	r2, #0
 80a481e:	2300      	movs	r3, #0
 80a4820:	f001 fdba 	bl	80a6398 <__aeabi_dcmplt>
 80a4824:	f04f 0800 	mov.w	r8, #0
 80a4828:	b958      	cbnz	r0, 80a4842 <pow+0x13a>
 80a482a:	f8df 9054 	ldr.w	r9, [pc, #84]	; 80a4880 <pow+0x178>
 80a482e:	e7a5      	b.n	80a477c <pow+0x74>
 80a4830:	f7fe fc76 	bl	80a3120 <__errno>
 80a4834:	2321      	movs	r3, #33	; 0x21
 80a4836:	f04f 0800 	mov.w	r8, #0
 80a483a:	f8df 9048 	ldr.w	r9, [pc, #72]	; 80a4884 <pow+0x17c>
 80a483e:	6003      	str	r3, [r0, #0]
 80a4840:	e79c      	b.n	80a477c <pow+0x74>
 80a4842:	4620      	mov	r0, r4
 80a4844:	4629      	mov	r1, r5
 80a4846:	f001 f85d 	bl	80a5904 <rint>
 80a484a:	4622      	mov	r2, r4
 80a484c:	462b      	mov	r3, r5
 80a484e:	f001 fd99 	bl	80a6384 <__aeabi_dcmpeq>
 80a4852:	2800      	cmp	r0, #0
 80a4854:	d1e9      	bne.n	80a482a <pow+0x122>
 80a4856:	f8df 902c 	ldr.w	r9, [pc, #44]	; 80a4884 <pow+0x17c>
 80a485a:	e78f      	b.n	80a477c <pow+0x74>
 80a485c:	f7fe fc60 	bl	80a3120 <__errno>
 80a4860:	2200      	movs	r2, #0
 80a4862:	2300      	movs	r3, #0
 80a4864:	2121      	movs	r1, #33	; 0x21
 80a4866:	6001      	str	r1, [r0, #0]
 80a4868:	4610      	mov	r0, r2
 80a486a:	4619      	mov	r1, r3
 80a486c:	f001 fc4c 	bl	80a6108 <__aeabi_ddiv>
 80a4870:	4680      	mov	r8, r0
 80a4872:	4689      	mov	r9, r1
 80a4874:	e782      	b.n	80a477c <pow+0x74>
 80a4876:	bf00      	nop
 80a4878:	20000020 	.word	0x20000020
 80a487c:	3ff00000 	.word	0x3ff00000
 80a4880:	7ff00000 	.word	0x7ff00000
 80a4884:	fff00000 	.word	0xfff00000

080a4888 <__ieee754_log>:
 80a4888:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a488c:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80a4890:	4602      	mov	r2, r0
 80a4892:	460b      	mov	r3, r1
 80a4894:	460f      	mov	r7, r1
 80a4896:	b087      	sub	sp, #28
 80a4898:	da59      	bge.n	80a494e <__ieee754_log+0xc6>
 80a489a:	4604      	mov	r4, r0
 80a489c:	f021 4500 	bic.w	r5, r1, #2147483648	; 0x80000000
 80a48a0:	432c      	orrs	r4, r5
 80a48a2:	f000 80f8 	beq.w	80a4a96 <__ieee754_log+0x20e>
 80a48a6:	2900      	cmp	r1, #0
 80a48a8:	f2c0 8132 	blt.w	80a4b10 <__ieee754_log+0x288>
 80a48ac:	2200      	movs	r2, #0
 80a48ae:	4bd6      	ldr	r3, [pc, #856]	; (80a4c08 <__ieee754_log+0x380>)
 80a48b0:	f001 fb00 	bl	80a5eb4 <__aeabi_dmul>
 80a48b4:	460f      	mov	r7, r1
 80a48b6:	460b      	mov	r3, r1
 80a48b8:	49d4      	ldr	r1, [pc, #848]	; (80a4c0c <__ieee754_log+0x384>)
 80a48ba:	f06f 0435 	mvn.w	r4, #53	; 0x35
 80a48be:	428f      	cmp	r7, r1
 80a48c0:	4602      	mov	r2, r0
 80a48c2:	dc48      	bgt.n	80a4956 <__ieee754_log+0xce>
 80a48c4:	153e      	asrs	r6, r7, #20
 80a48c6:	f3c7 0713 	ubfx	r7, r7, #0, #20
 80a48ca:	f507 2115 	add.w	r1, r7, #610304	; 0x95000
 80a48ce:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
 80a48d2:	f601 7164 	addw	r1, r1, #3940	; 0xf64
 80a48d6:	f401 1180 	and.w	r1, r1, #1048576	; 0x100000
 80a48da:	4426      	add	r6, r4
 80a48dc:	eb06 5611 	add.w	r6, r6, r1, lsr #20
 80a48e0:	f081 517f 	eor.w	r1, r1, #1069547520	; 0x3fc00000
 80a48e4:	f481 1140 	eor.w	r1, r1, #3145728	; 0x300000
 80a48e8:	ea41 0307 	orr.w	r3, r1, r7
 80a48ec:	4610      	mov	r0, r2
 80a48ee:	4619      	mov	r1, r3
 80a48f0:	2200      	movs	r2, #0
 80a48f2:	4bc7      	ldr	r3, [pc, #796]	; (80a4c10 <__ieee754_log+0x388>)
 80a48f4:	f001 f926 	bl	80a5b44 <__aeabi_dsub>
 80a48f8:	1cbb      	adds	r3, r7, #2
 80a48fa:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80a48fe:	2b02      	cmp	r3, #2
 80a4900:	4682      	mov	sl, r0
 80a4902:	468b      	mov	fp, r1
 80a4904:	dc2e      	bgt.n	80a4964 <__ieee754_log+0xdc>
 80a4906:	2200      	movs	r2, #0
 80a4908:	2300      	movs	r3, #0
 80a490a:	f001 fd3b 	bl	80a6384 <__aeabi_dcmpeq>
 80a490e:	2800      	cmp	r0, #0
 80a4910:	f000 80ca 	beq.w	80a4aa8 <__ieee754_log+0x220>
 80a4914:	2e00      	cmp	r6, #0
 80a4916:	f000 814b 	beq.w	80a4bb0 <__ieee754_log+0x328>
 80a491a:	4630      	mov	r0, r6
 80a491c:	f001 fa60 	bl	80a5de0 <__aeabi_i2d>
 80a4920:	a3a5      	add	r3, pc, #660	; (adr r3, 80a4bb8 <__ieee754_log+0x330>)
 80a4922:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4926:	4606      	mov	r6, r0
 80a4928:	460f      	mov	r7, r1
 80a492a:	f001 fac3 	bl	80a5eb4 <__aeabi_dmul>
 80a492e:	a3a4      	add	r3, pc, #656	; (adr r3, 80a4bc0 <__ieee754_log+0x338>)
 80a4930:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4934:	4604      	mov	r4, r0
 80a4936:	460d      	mov	r5, r1
 80a4938:	4630      	mov	r0, r6
 80a493a:	4639      	mov	r1, r7
 80a493c:	f001 faba 	bl	80a5eb4 <__aeabi_dmul>
 80a4940:	4602      	mov	r2, r0
 80a4942:	460b      	mov	r3, r1
 80a4944:	4620      	mov	r0, r4
 80a4946:	4629      	mov	r1, r5
 80a4948:	f001 f8fe 	bl	80a5b48 <__adddf3>
 80a494c:	e007      	b.n	80a495e <__ieee754_log+0xd6>
 80a494e:	49af      	ldr	r1, [pc, #700]	; (80a4c0c <__ieee754_log+0x384>)
 80a4950:	2400      	movs	r4, #0
 80a4952:	428f      	cmp	r7, r1
 80a4954:	ddb6      	ble.n	80a48c4 <__ieee754_log+0x3c>
 80a4956:	4610      	mov	r0, r2
 80a4958:	4619      	mov	r1, r3
 80a495a:	f001 f8f5 	bl	80a5b48 <__adddf3>
 80a495e:	b007      	add	sp, #28
 80a4960:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4964:	f5a7 23c2 	sub.w	r3, r7, #397312	; 0x61000
 80a4968:	f2a3 437a 	subw	r3, r3, #1146	; 0x47a
 80a496c:	2200      	movs	r2, #0
 80a496e:	9301      	str	r3, [sp, #4]
 80a4970:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80a4974:	f001 f8e8 	bl	80a5b48 <__adddf3>
 80a4978:	460b      	mov	r3, r1
 80a497a:	4602      	mov	r2, r0
 80a497c:	4659      	mov	r1, fp
 80a497e:	4650      	mov	r0, sl
 80a4980:	f001 fbc2 	bl	80a6108 <__aeabi_ddiv>
 80a4984:	4602      	mov	r2, r0
 80a4986:	4630      	mov	r0, r6
 80a4988:	4614      	mov	r4, r2
 80a498a:	460d      	mov	r5, r1
 80a498c:	f001 fa28 	bl	80a5de0 <__aeabi_i2d>
 80a4990:	4622      	mov	r2, r4
 80a4992:	462b      	mov	r3, r5
 80a4994:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80a4998:	4620      	mov	r0, r4
 80a499a:	4629      	mov	r1, r5
 80a499c:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80a49a0:	f001 fa88 	bl	80a5eb4 <__aeabi_dmul>
 80a49a4:	4602      	mov	r2, r0
 80a49a6:	460b      	mov	r3, r1
 80a49a8:	4680      	mov	r8, r0
 80a49aa:	4689      	mov	r9, r1
 80a49ac:	f001 fa82 	bl	80a5eb4 <__aeabi_dmul>
 80a49b0:	a385      	add	r3, pc, #532	; (adr r3, 80a4bc8 <__ieee754_log+0x340>)
 80a49b2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a49b6:	4604      	mov	r4, r0
 80a49b8:	460d      	mov	r5, r1
 80a49ba:	f001 fa7b 	bl	80a5eb4 <__aeabi_dmul>
 80a49be:	a384      	add	r3, pc, #528	; (adr r3, 80a4bd0 <__ieee754_log+0x348>)
 80a49c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a49c4:	f001 f8c0 	bl	80a5b48 <__adddf3>
 80a49c8:	4622      	mov	r2, r4
 80a49ca:	462b      	mov	r3, r5
 80a49cc:	f001 fa72 	bl	80a5eb4 <__aeabi_dmul>
 80a49d0:	a381      	add	r3, pc, #516	; (adr r3, 80a4bd8 <__ieee754_log+0x350>)
 80a49d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a49d6:	f001 f8b7 	bl	80a5b48 <__adddf3>
 80a49da:	4622      	mov	r2, r4
 80a49dc:	462b      	mov	r3, r5
 80a49de:	f001 fa69 	bl	80a5eb4 <__aeabi_dmul>
 80a49e2:	a37f      	add	r3, pc, #508	; (adr r3, 80a4be0 <__ieee754_log+0x358>)
 80a49e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a49e8:	f001 f8ae 	bl	80a5b48 <__adddf3>
 80a49ec:	4642      	mov	r2, r8
 80a49ee:	464b      	mov	r3, r9
 80a49f0:	f001 fa60 	bl	80a5eb4 <__aeabi_dmul>
 80a49f4:	a37c      	add	r3, pc, #496	; (adr r3, 80a4be8 <__ieee754_log+0x360>)
 80a49f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a49fa:	4680      	mov	r8, r0
 80a49fc:	4689      	mov	r9, r1
 80a49fe:	4620      	mov	r0, r4
 80a4a00:	4629      	mov	r1, r5
 80a4a02:	f001 fa57 	bl	80a5eb4 <__aeabi_dmul>
 80a4a06:	a37a      	add	r3, pc, #488	; (adr r3, 80a4bf0 <__ieee754_log+0x368>)
 80a4a08:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4a0c:	f001 f89c 	bl	80a5b48 <__adddf3>
 80a4a10:	4622      	mov	r2, r4
 80a4a12:	462b      	mov	r3, r5
 80a4a14:	f001 fa4e 	bl	80a5eb4 <__aeabi_dmul>
 80a4a18:	a377      	add	r3, pc, #476	; (adr r3, 80a4bf8 <__ieee754_log+0x370>)
 80a4a1a:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4a1e:	f001 f893 	bl	80a5b48 <__adddf3>
 80a4a22:	4622      	mov	r2, r4
 80a4a24:	462b      	mov	r3, r5
 80a4a26:	f001 fa45 	bl	80a5eb4 <__aeabi_dmul>
 80a4a2a:	460b      	mov	r3, r1
 80a4a2c:	4602      	mov	r2, r0
 80a4a2e:	4649      	mov	r1, r9
 80a4a30:	4640      	mov	r0, r8
 80a4a32:	f001 f889 	bl	80a5b48 <__adddf3>
 80a4a36:	f5c7 27d7 	rsb	r7, r7, #440320	; 0x6b800
 80a4a3a:	9b01      	ldr	r3, [sp, #4]
 80a4a3c:	3751      	adds	r7, #81	; 0x51
 80a4a3e:	431f      	orrs	r7, r3
 80a4a40:	2f00      	cmp	r7, #0
 80a4a42:	4680      	mov	r8, r0
 80a4a44:	4689      	mov	r9, r1
 80a4a46:	dd55      	ble.n	80a4af4 <__ieee754_log+0x26c>
 80a4a48:	2200      	movs	r2, #0
 80a4a4a:	4b72      	ldr	r3, [pc, #456]	; (80a4c14 <__ieee754_log+0x38c>)
 80a4a4c:	4650      	mov	r0, sl
 80a4a4e:	4659      	mov	r1, fp
 80a4a50:	f001 fa30 	bl	80a5eb4 <__aeabi_dmul>
 80a4a54:	4652      	mov	r2, sl
 80a4a56:	465b      	mov	r3, fp
 80a4a58:	f001 fa2c 	bl	80a5eb4 <__aeabi_dmul>
 80a4a5c:	4604      	mov	r4, r0
 80a4a5e:	460d      	mov	r5, r1
 80a4a60:	2e00      	cmp	r6, #0
 80a4a62:	d15c      	bne.n	80a4b1e <__ieee754_log+0x296>
 80a4a64:	4622      	mov	r2, r4
 80a4a66:	462b      	mov	r3, r5
 80a4a68:	4640      	mov	r0, r8
 80a4a6a:	4649      	mov	r1, r9
 80a4a6c:	f001 f86c 	bl	80a5b48 <__adddf3>
 80a4a70:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80a4a74:	f001 fa1e 	bl	80a5eb4 <__aeabi_dmul>
 80a4a78:	4602      	mov	r2, r0
 80a4a7a:	460b      	mov	r3, r1
 80a4a7c:	4620      	mov	r0, r4
 80a4a7e:	4629      	mov	r1, r5
 80a4a80:	f001 f860 	bl	80a5b44 <__aeabi_dsub>
 80a4a84:	4602      	mov	r2, r0
 80a4a86:	460b      	mov	r3, r1
 80a4a88:	4650      	mov	r0, sl
 80a4a8a:	4659      	mov	r1, fp
 80a4a8c:	f001 f85a 	bl	80a5b44 <__aeabi_dsub>
 80a4a90:	b007      	add	sp, #28
 80a4a92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4a96:	2200      	movs	r2, #0
 80a4a98:	2300      	movs	r3, #0
 80a4a9a:	2000      	movs	r0, #0
 80a4a9c:	495e      	ldr	r1, [pc, #376]	; (80a4c18 <__ieee754_log+0x390>)
 80a4a9e:	f001 fb33 	bl	80a6108 <__aeabi_ddiv>
 80a4aa2:	b007      	add	sp, #28
 80a4aa4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4aa8:	a355      	add	r3, pc, #340	; (adr r3, 80a4c00 <__ieee754_log+0x378>)
 80a4aaa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4aae:	4650      	mov	r0, sl
 80a4ab0:	4659      	mov	r1, fp
 80a4ab2:	f001 f9ff 	bl	80a5eb4 <__aeabi_dmul>
 80a4ab6:	4602      	mov	r2, r0
 80a4ab8:	460b      	mov	r3, r1
 80a4aba:	2000      	movs	r0, #0
 80a4abc:	4955      	ldr	r1, [pc, #340]	; (80a4c14 <__ieee754_log+0x38c>)
 80a4abe:	f001 f841 	bl	80a5b44 <__aeabi_dsub>
 80a4ac2:	4652      	mov	r2, sl
 80a4ac4:	4604      	mov	r4, r0
 80a4ac6:	460d      	mov	r5, r1
 80a4ac8:	465b      	mov	r3, fp
 80a4aca:	4650      	mov	r0, sl
 80a4acc:	4659      	mov	r1, fp
 80a4ace:	f001 f9f1 	bl	80a5eb4 <__aeabi_dmul>
 80a4ad2:	4602      	mov	r2, r0
 80a4ad4:	460b      	mov	r3, r1
 80a4ad6:	4620      	mov	r0, r4
 80a4ad8:	4629      	mov	r1, r5
 80a4ada:	f001 f9eb 	bl	80a5eb4 <__aeabi_dmul>
 80a4ade:	4604      	mov	r4, r0
 80a4ae0:	460d      	mov	r5, r1
 80a4ae2:	2e00      	cmp	r6, #0
 80a4ae4:	d150      	bne.n	80a4b88 <__ieee754_log+0x300>
 80a4ae6:	4602      	mov	r2, r0
 80a4ae8:	460b      	mov	r3, r1
 80a4aea:	4650      	mov	r0, sl
 80a4aec:	4659      	mov	r1, fp
 80a4aee:	f001 f829 	bl	80a5b44 <__aeabi_dsub>
 80a4af2:	e734      	b.n	80a495e <__ieee754_log+0xd6>
 80a4af4:	2e00      	cmp	r6, #0
 80a4af6:	f040 8091 	bne.w	80a4c1c <__ieee754_log+0x394>
 80a4afa:	4602      	mov	r2, r0
 80a4afc:	460b      	mov	r3, r1
 80a4afe:	4650      	mov	r0, sl
 80a4b00:	4659      	mov	r1, fp
 80a4b02:	f001 f81f 	bl	80a5b44 <__aeabi_dsub>
 80a4b06:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80a4b0a:	f001 f9d3 	bl	80a5eb4 <__aeabi_dmul>
 80a4b0e:	e7b9      	b.n	80a4a84 <__ieee754_log+0x1fc>
 80a4b10:	f001 f818 	bl	80a5b44 <__aeabi_dsub>
 80a4b14:	2200      	movs	r2, #0
 80a4b16:	2300      	movs	r3, #0
 80a4b18:	f001 faf6 	bl	80a6108 <__aeabi_ddiv>
 80a4b1c:	e71f      	b.n	80a495e <__ieee754_log+0xd6>
 80a4b1e:	a326      	add	r3, pc, #152	; (adr r3, 80a4bb8 <__ieee754_log+0x330>)
 80a4b20:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4b24:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80a4b28:	f001 f9c4 	bl	80a5eb4 <__aeabi_dmul>
 80a4b2c:	4622      	mov	r2, r4
 80a4b2e:	462b      	mov	r3, r5
 80a4b30:	4606      	mov	r6, r0
 80a4b32:	460f      	mov	r7, r1
 80a4b34:	4640      	mov	r0, r8
 80a4b36:	4649      	mov	r1, r9
 80a4b38:	f001 f806 	bl	80a5b48 <__adddf3>
 80a4b3c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80a4b40:	f001 f9b8 	bl	80a5eb4 <__aeabi_dmul>
 80a4b44:	a31e      	add	r3, pc, #120	; (adr r3, 80a4bc0 <__ieee754_log+0x338>)
 80a4b46:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4b4a:	4680      	mov	r8, r0
 80a4b4c:	4689      	mov	r9, r1
 80a4b4e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80a4b52:	f001 f9af 	bl	80a5eb4 <__aeabi_dmul>
 80a4b56:	4602      	mov	r2, r0
 80a4b58:	460b      	mov	r3, r1
 80a4b5a:	4640      	mov	r0, r8
 80a4b5c:	4649      	mov	r1, r9
 80a4b5e:	f000 fff3 	bl	80a5b48 <__adddf3>
 80a4b62:	4602      	mov	r2, r0
 80a4b64:	460b      	mov	r3, r1
 80a4b66:	4620      	mov	r0, r4
 80a4b68:	4629      	mov	r1, r5
 80a4b6a:	f000 ffeb 	bl	80a5b44 <__aeabi_dsub>
 80a4b6e:	4652      	mov	r2, sl
 80a4b70:	465b      	mov	r3, fp
 80a4b72:	f000 ffe7 	bl	80a5b44 <__aeabi_dsub>
 80a4b76:	4602      	mov	r2, r0
 80a4b78:	460b      	mov	r3, r1
 80a4b7a:	4630      	mov	r0, r6
 80a4b7c:	4639      	mov	r1, r7
 80a4b7e:	f000 ffe1 	bl	80a5b44 <__aeabi_dsub>
 80a4b82:	b007      	add	sp, #28
 80a4b84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4b88:	4630      	mov	r0, r6
 80a4b8a:	f001 f929 	bl	80a5de0 <__aeabi_i2d>
 80a4b8e:	a30a      	add	r3, pc, #40	; (adr r3, 80a4bb8 <__ieee754_log+0x330>)
 80a4b90:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4b94:	4680      	mov	r8, r0
 80a4b96:	4689      	mov	r9, r1
 80a4b98:	f001 f98c 	bl	80a5eb4 <__aeabi_dmul>
 80a4b9c:	a308      	add	r3, pc, #32	; (adr r3, 80a4bc0 <__ieee754_log+0x338>)
 80a4b9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4ba2:	4606      	mov	r6, r0
 80a4ba4:	460f      	mov	r7, r1
 80a4ba6:	4640      	mov	r0, r8
 80a4ba8:	4649      	mov	r1, r9
 80a4baa:	f001 f983 	bl	80a5eb4 <__aeabi_dmul>
 80a4bae:	e7d8      	b.n	80a4b62 <__ieee754_log+0x2da>
 80a4bb0:	2000      	movs	r0, #0
 80a4bb2:	2100      	movs	r1, #0
 80a4bb4:	e6d3      	b.n	80a495e <__ieee754_log+0xd6>
 80a4bb6:	bf00      	nop
 80a4bb8:	fee00000 	.word	0xfee00000
 80a4bbc:	3fe62e42 	.word	0x3fe62e42
 80a4bc0:	35793c76 	.word	0x35793c76
 80a4bc4:	3dea39ef 	.word	0x3dea39ef
 80a4bc8:	df3e5244 	.word	0xdf3e5244
 80a4bcc:	3fc2f112 	.word	0x3fc2f112
 80a4bd0:	96cb03de 	.word	0x96cb03de
 80a4bd4:	3fc74664 	.word	0x3fc74664
 80a4bd8:	94229359 	.word	0x94229359
 80a4bdc:	3fd24924 	.word	0x3fd24924
 80a4be0:	55555593 	.word	0x55555593
 80a4be4:	3fe55555 	.word	0x3fe55555
 80a4be8:	d078c69f 	.word	0xd078c69f
 80a4bec:	3fc39a09 	.word	0x3fc39a09
 80a4bf0:	1d8e78af 	.word	0x1d8e78af
 80a4bf4:	3fcc71c5 	.word	0x3fcc71c5
 80a4bf8:	9997fa04 	.word	0x9997fa04
 80a4bfc:	3fd99999 	.word	0x3fd99999
 80a4c00:	55555555 	.word	0x55555555
 80a4c04:	3fd55555 	.word	0x3fd55555
 80a4c08:	43500000 	.word	0x43500000
 80a4c0c:	7fefffff 	.word	0x7fefffff
 80a4c10:	3ff00000 	.word	0x3ff00000
 80a4c14:	3fe00000 	.word	0x3fe00000
 80a4c18:	c3500000 	.word	0xc3500000
 80a4c1c:	a316      	add	r3, pc, #88	; (adr r3, 80a4c78 <__ieee754_log+0x3f0>)
 80a4c1e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4c22:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80a4c26:	f001 f945 	bl	80a5eb4 <__aeabi_dmul>
 80a4c2a:	4642      	mov	r2, r8
 80a4c2c:	464b      	mov	r3, r9
 80a4c2e:	4604      	mov	r4, r0
 80a4c30:	460d      	mov	r5, r1
 80a4c32:	4650      	mov	r0, sl
 80a4c34:	4659      	mov	r1, fp
 80a4c36:	f000 ff85 	bl	80a5b44 <__aeabi_dsub>
 80a4c3a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80a4c3e:	f001 f939 	bl	80a5eb4 <__aeabi_dmul>
 80a4c42:	a30f      	add	r3, pc, #60	; (adr r3, 80a4c80 <__ieee754_log+0x3f8>)
 80a4c44:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4c48:	4606      	mov	r6, r0
 80a4c4a:	460f      	mov	r7, r1
 80a4c4c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80a4c50:	f001 f930 	bl	80a5eb4 <__aeabi_dmul>
 80a4c54:	4602      	mov	r2, r0
 80a4c56:	460b      	mov	r3, r1
 80a4c58:	4630      	mov	r0, r6
 80a4c5a:	4639      	mov	r1, r7
 80a4c5c:	f000 ff72 	bl	80a5b44 <__aeabi_dsub>
 80a4c60:	4652      	mov	r2, sl
 80a4c62:	465b      	mov	r3, fp
 80a4c64:	f000 ff6e 	bl	80a5b44 <__aeabi_dsub>
 80a4c68:	4602      	mov	r2, r0
 80a4c6a:	460b      	mov	r3, r1
 80a4c6c:	4620      	mov	r0, r4
 80a4c6e:	4629      	mov	r1, r5
 80a4c70:	f000 ff68 	bl	80a5b44 <__aeabi_dsub>
 80a4c74:	e673      	b.n	80a495e <__ieee754_log+0xd6>
 80a4c76:	bf00      	nop
 80a4c78:	fee00000 	.word	0xfee00000
 80a4c7c:	3fe62e42 	.word	0x3fe62e42
 80a4c80:	35793c76 	.word	0x35793c76
 80a4c84:	3dea39ef 	.word	0x3dea39ef

080a4c88 <__ieee754_pow>:
 80a4c88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a4c8c:	4699      	mov	r9, r3
 80a4c8e:	4690      	mov	r8, r2
 80a4c90:	f029 4500 	bic.w	r5, r9, #2147483648	; 0x80000000
 80a4c94:	461e      	mov	r6, r3
 80a4c96:	4613      	mov	r3, r2
 80a4c98:	ea55 0208 	orrs.w	r2, r5, r8
 80a4c9c:	b093      	sub	sp, #76	; 0x4c
 80a4c9e:	d035      	beq.n	80a4d0c <__ieee754_pow+0x84>
 80a4ca0:	4a6b      	ldr	r2, [pc, #428]	; (80a4e50 <__ieee754_pow+0x1c8>)
 80a4ca2:	f021 4400 	bic.w	r4, r1, #2147483648	; 0x80000000
 80a4ca6:	4294      	cmp	r4, r2
 80a4ca8:	4683      	mov	fp, r0
 80a4caa:	468a      	mov	sl, r1
 80a4cac:	460f      	mov	r7, r1
 80a4cae:	9000      	str	r0, [sp, #0]
 80a4cb0:	dc25      	bgt.n	80a4cfe <__ieee754_pow+0x76>
 80a4cb2:	d034      	beq.n	80a4d1e <__ieee754_pow+0x96>
 80a4cb4:	4295      	cmp	r5, r2
 80a4cb6:	dc22      	bgt.n	80a4cfe <__ieee754_pow+0x76>
 80a4cb8:	4a65      	ldr	r2, [pc, #404]	; (80a4e50 <__ieee754_pow+0x1c8>)
 80a4cba:	4295      	cmp	r5, r2
 80a4cbc:	d01d      	beq.n	80a4cfa <__ieee754_pow+0x72>
 80a4cbe:	2f00      	cmp	r7, #0
 80a4cc0:	db36      	blt.n	80a4d30 <__ieee754_pow+0xa8>
 80a4cc2:	2200      	movs	r2, #0
 80a4cc4:	9202      	str	r2, [sp, #8]
 80a4cc6:	2b00      	cmp	r3, #0
 80a4cc8:	d14c      	bne.n	80a4d64 <__ieee754_pow+0xdc>
 80a4cca:	4b61      	ldr	r3, [pc, #388]	; (80a4e50 <__ieee754_pow+0x1c8>)
 80a4ccc:	429d      	cmp	r5, r3
 80a4cce:	f000 8097 	beq.w	80a4e00 <__ieee754_pow+0x178>
 80a4cd2:	4b60      	ldr	r3, [pc, #384]	; (80a4e54 <__ieee754_pow+0x1cc>)
 80a4cd4:	429d      	cmp	r5, r3
 80a4cd6:	f000 80a5 	beq.w	80a4e24 <__ieee754_pow+0x19c>
 80a4cda:	f1b6 4f80 	cmp.w	r6, #1073741824	; 0x40000000
 80a4cde:	f000 84a3 	beq.w	80a5628 <__ieee754_pow+0x9a0>
 80a4ce2:	4b5d      	ldr	r3, [pc, #372]	; (80a4e58 <__ieee754_pow+0x1d0>)
 80a4ce4:	429e      	cmp	r6, r3
 80a4ce6:	d13d      	bne.n	80a4d64 <__ieee754_pow+0xdc>
 80a4ce8:	2f00      	cmp	r7, #0
 80a4cea:	db3b      	blt.n	80a4d64 <__ieee754_pow+0xdc>
 80a4cec:	4658      	mov	r0, fp
 80a4cee:	4651      	mov	r1, sl
 80a4cf0:	b013      	add	sp, #76	; 0x4c
 80a4cf2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a4cf6:	f000 bd2f 	b.w	80a5758 <__ieee754_sqrt>
 80a4cfa:	2b00      	cmp	r3, #0
 80a4cfc:	d0df      	beq.n	80a4cbe <__ieee754_pow+0x36>
 80a4cfe:	9b00      	ldr	r3, [sp, #0]
 80a4d00:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
 80a4d04:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
 80a4d08:	4323      	orrs	r3, r4
 80a4d0a:	d10b      	bne.n	80a4d24 <__ieee754_pow+0x9c>
 80a4d0c:	2300      	movs	r3, #0
 80a4d0e:	4c51      	ldr	r4, [pc, #324]	; (80a4e54 <__ieee754_pow+0x1cc>)
 80a4d10:	e9cd 3400 	strd	r3, r4, [sp]
 80a4d14:	e9dd 0100 	ldrd	r0, r1, [sp]
 80a4d18:	b013      	add	sp, #76	; 0x4c
 80a4d1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4d1e:	b908      	cbnz	r0, 80a4d24 <__ieee754_pow+0x9c>
 80a4d20:	42a5      	cmp	r5, r4
 80a4d22:	ddc9      	ble.n	80a4cb8 <__ieee754_pow+0x30>
 80a4d24:	484d      	ldr	r0, [pc, #308]	; (80a4e5c <__ieee754_pow+0x1d4>)
 80a4d26:	b013      	add	sp, #76	; 0x4c
 80a4d28:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a4d2c:	f000 bde4 	b.w	80a58f8 <nan>
 80a4d30:	4a4b      	ldr	r2, [pc, #300]	; (80a4e60 <__ieee754_pow+0x1d8>)
 80a4d32:	4295      	cmp	r5, r2
 80a4d34:	dc7e      	bgt.n	80a4e34 <__ieee754_pow+0x1ac>
 80a4d36:	f1a2 7254 	sub.w	r2, r2, #55574528	; 0x3500000
 80a4d3a:	4295      	cmp	r5, r2
 80a4d3c:	dd0e      	ble.n	80a4d5c <__ieee754_pow+0xd4>
 80a4d3e:	152a      	asrs	r2, r5, #20
 80a4d40:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
 80a4d44:	2a14      	cmp	r2, #20
 80a4d46:	f340 8479 	ble.w	80a563c <__ieee754_pow+0x9b4>
 80a4d4a:	f1c2 0234 	rsb	r2, r2, #52	; 0x34
 80a4d4e:	fa23 f102 	lsr.w	r1, r3, r2
 80a4d52:	fa01 f202 	lsl.w	r2, r1, r2
 80a4d56:	429a      	cmp	r2, r3
 80a4d58:	f000 84c5 	beq.w	80a56e6 <__ieee754_pow+0xa5e>
 80a4d5c:	2200      	movs	r2, #0
 80a4d5e:	9202      	str	r2, [sp, #8]
 80a4d60:	2b00      	cmp	r3, #0
 80a4d62:	d0b6      	beq.n	80a4cd2 <__ieee754_pow+0x4a>
 80a4d64:	4658      	mov	r0, fp
 80a4d66:	4651      	mov	r1, sl
 80a4d68:	f000 fdbc 	bl	80a58e4 <fabs>
 80a4d6c:	465b      	mov	r3, fp
 80a4d6e:	e9cd 0100 	strd	r0, r1, [sp]
 80a4d72:	bb33      	cbnz	r3, 80a4dc2 <__ieee754_pow+0x13a>
 80a4d74:	b124      	cbz	r4, 80a4d80 <__ieee754_pow+0xf8>
 80a4d76:	4b37      	ldr	r3, [pc, #220]	; (80a4e54 <__ieee754_pow+0x1cc>)
 80a4d78:	f027 4240 	bic.w	r2, r7, #3221225472	; 0xc0000000
 80a4d7c:	429a      	cmp	r2, r3
 80a4d7e:	d120      	bne.n	80a4dc2 <__ieee754_pow+0x13a>
 80a4d80:	2e00      	cmp	r6, #0
 80a4d82:	da07      	bge.n	80a4d94 <__ieee754_pow+0x10c>
 80a4d84:	e9dd 2300 	ldrd	r2, r3, [sp]
 80a4d88:	2000      	movs	r0, #0
 80a4d8a:	4932      	ldr	r1, [pc, #200]	; (80a4e54 <__ieee754_pow+0x1cc>)
 80a4d8c:	f001 f9bc 	bl	80a6108 <__aeabi_ddiv>
 80a4d90:	e9cd 0100 	strd	r0, r1, [sp]
 80a4d94:	2f00      	cmp	r7, #0
 80a4d96:	dabd      	bge.n	80a4d14 <__ieee754_pow+0x8c>
 80a4d98:	9b02      	ldr	r3, [sp, #8]
 80a4d9a:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
 80a4d9e:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
 80a4da2:	4323      	orrs	r3, r4
 80a4da4:	f040 846f 	bne.w	80a5686 <__ieee754_pow+0x9fe>
 80a4da8:	e9dd 2300 	ldrd	r2, r3, [sp]
 80a4dac:	4610      	mov	r0, r2
 80a4dae:	4619      	mov	r1, r3
 80a4db0:	f000 fec8 	bl	80a5b44 <__aeabi_dsub>
 80a4db4:	4602      	mov	r2, r0
 80a4db6:	460b      	mov	r3, r1
 80a4db8:	f001 f9a6 	bl	80a6108 <__aeabi_ddiv>
 80a4dbc:	e9cd 0100 	strd	r0, r1, [sp]
 80a4dc0:	e7a8      	b.n	80a4d14 <__ieee754_pow+0x8c>
 80a4dc2:	9a02      	ldr	r2, [sp, #8]
 80a4dc4:	0ffb      	lsrs	r3, r7, #31
 80a4dc6:	3b01      	subs	r3, #1
 80a4dc8:	930a      	str	r3, [sp, #40]	; 0x28
 80a4dca:	4313      	orrs	r3, r2
 80a4dcc:	d035      	beq.n	80a4e3a <__ieee754_pow+0x1b2>
 80a4dce:	4b25      	ldr	r3, [pc, #148]	; (80a4e64 <__ieee754_pow+0x1dc>)
 80a4dd0:	429d      	cmp	r5, r3
 80a4dd2:	dd4b      	ble.n	80a4e6c <__ieee754_pow+0x1e4>
 80a4dd4:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
 80a4dd8:	429d      	cmp	r5, r3
 80a4dda:	4b23      	ldr	r3, [pc, #140]	; (80a4e68 <__ieee754_pow+0x1e0>)
 80a4ddc:	f340 83bc 	ble.w	80a5558 <__ieee754_pow+0x8d0>
 80a4de0:	429c      	cmp	r4, r3
 80a4de2:	f340 834f 	ble.w	80a5484 <__ieee754_pow+0x7fc>
 80a4de6:	2e00      	cmp	r6, #0
 80a4de8:	f340 834f 	ble.w	80a548a <__ieee754_pow+0x802>
 80a4dec:	a316      	add	r3, pc, #88	; (adr r3, 80a4e48 <__ieee754_pow+0x1c0>)
 80a4dee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4df2:	4610      	mov	r0, r2
 80a4df4:	4619      	mov	r1, r3
 80a4df6:	f001 f85d 	bl	80a5eb4 <__aeabi_dmul>
 80a4dfa:	e9cd 0100 	strd	r0, r1, [sp]
 80a4dfe:	e789      	b.n	80a4d14 <__ieee754_pow+0x8c>
 80a4e00:	9a00      	ldr	r2, [sp, #0]
 80a4e02:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
 80a4e06:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
 80a4e0a:	4313      	orrs	r3, r2
 80a4e0c:	f43f af7e 	beq.w	80a4d0c <__ieee754_pow+0x84>
 80a4e10:	4b15      	ldr	r3, [pc, #84]	; (80a4e68 <__ieee754_pow+0x1e0>)
 80a4e12:	429c      	cmp	r4, r3
 80a4e14:	f340 8363 	ble.w	80a54de <__ieee754_pow+0x856>
 80a4e18:	2e00      	cmp	r6, #0
 80a4e1a:	f2c0 8336 	blt.w	80a548a <__ieee754_pow+0x802>
 80a4e1e:	e9cd 8900 	strd	r8, r9, [sp]
 80a4e22:	e777      	b.n	80a4d14 <__ieee754_pow+0x8c>
 80a4e24:	2e00      	cmp	r6, #0
 80a4e26:	f2c0 83f5 	blt.w	80a5614 <__ieee754_pow+0x98c>
 80a4e2a:	4658      	mov	r0, fp
 80a4e2c:	4651      	mov	r1, sl
 80a4e2e:	e9cd 0100 	strd	r0, r1, [sp]
 80a4e32:	e76f      	b.n	80a4d14 <__ieee754_pow+0x8c>
 80a4e34:	2202      	movs	r2, #2
 80a4e36:	9202      	str	r2, [sp, #8]
 80a4e38:	e745      	b.n	80a4cc6 <__ieee754_pow+0x3e>
 80a4e3a:	465a      	mov	r2, fp
 80a4e3c:	4658      	mov	r0, fp
 80a4e3e:	4653      	mov	r3, sl
 80a4e40:	4651      	mov	r1, sl
 80a4e42:	e7b5      	b.n	80a4db0 <__ieee754_pow+0x128>
 80a4e44:	f3af 8000 	nop.w
 80a4e48:	8800759c 	.word	0x8800759c
 80a4e4c:	7e37e43c 	.word	0x7e37e43c
 80a4e50:	7ff00000 	.word	0x7ff00000
 80a4e54:	3ff00000 	.word	0x3ff00000
 80a4e58:	3fe00000 	.word	0x3fe00000
 80a4e5c:	080a743c 	.word	0x080a743c
 80a4e60:	433fffff 	.word	0x433fffff
 80a4e64:	41e00000 	.word	0x41e00000
 80a4e68:	3fefffff 	.word	0x3fefffff
 80a4e6c:	4bd4      	ldr	r3, [pc, #848]	; (80a51c0 <__ieee754_pow+0x538>)
 80a4e6e:	403b      	ands	r3, r7
 80a4e70:	2b00      	cmp	r3, #0
 80a4e72:	f040 83cd 	bne.w	80a5610 <__ieee754_pow+0x988>
 80a4e76:	e9dd 0100 	ldrd	r0, r1, [sp]
 80a4e7a:	2200      	movs	r2, #0
 80a4e7c:	4bd1      	ldr	r3, [pc, #836]	; (80a51c4 <__ieee754_pow+0x53c>)
 80a4e7e:	f001 f819 	bl	80a5eb4 <__aeabi_dmul>
 80a4e82:	f06f 0534 	mvn.w	r5, #52	; 0x34
 80a4e86:	460c      	mov	r4, r1
 80a4e88:	e9cd 0100 	strd	r0, r1, [sp]
 80a4e8c:	1523      	asrs	r3, r4, #20
 80a4e8e:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
 80a4e92:	1959      	adds	r1, r3, r5
 80a4e94:	4bcc      	ldr	r3, [pc, #816]	; (80a51c8 <__ieee754_pow+0x540>)
 80a4e96:	f3c4 0213 	ubfx	r2, r4, #0, #20
 80a4e9a:	f042 547f 	orr.w	r4, r2, #1069547520	; 0x3fc00000
 80a4e9e:	429a      	cmp	r2, r3
 80a4ea0:	910b      	str	r1, [sp, #44]	; 0x2c
 80a4ea2:	f444 1440 	orr.w	r4, r4, #3145728	; 0x300000
 80a4ea6:	dd07      	ble.n	80a4eb8 <__ieee754_pow+0x230>
 80a4ea8:	4bc8      	ldr	r3, [pc, #800]	; (80a51cc <__ieee754_pow+0x544>)
 80a4eaa:	429a      	cmp	r2, r3
 80a4eac:	f340 83f8 	ble.w	80a56a0 <__ieee754_pow+0xa18>
 80a4eb0:	3101      	adds	r1, #1
 80a4eb2:	910b      	str	r1, [sp, #44]	; 0x2c
 80a4eb4:	f5a4 1480 	sub.w	r4, r4, #1048576	; 0x100000
 80a4eb8:	2200      	movs	r2, #0
 80a4eba:	2300      	movs	r3, #0
 80a4ebc:	2000      	movs	r0, #0
 80a4ebe:	2500      	movs	r5, #0
 80a4ec0:	49c3      	ldr	r1, [pc, #780]	; (80a51d0 <__ieee754_pow+0x548>)
 80a4ec2:	e9cd 2308 	strd	r2, r3, [sp, #32]
 80a4ec6:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80a4eca:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
 80a4ece:	e9dd 0100 	ldrd	r0, r1, [sp]
 80a4ed2:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80a4ed6:	4621      	mov	r1, r4
 80a4ed8:	4682      	mov	sl, r0
 80a4eda:	f000 fe33 	bl	80a5b44 <__aeabi_dsub>
 80a4ede:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80a4ee2:	46a3      	mov	fp, r4
 80a4ee4:	4606      	mov	r6, r0
 80a4ee6:	460f      	mov	r7, r1
 80a4ee8:	4650      	mov	r0, sl
 80a4eea:	4621      	mov	r1, r4
 80a4eec:	e9cd ab0c 	strd	sl, fp, [sp, #48]	; 0x30
 80a4ef0:	f000 fe2a 	bl	80a5b48 <__adddf3>
 80a4ef4:	4602      	mov	r2, r0
 80a4ef6:	460b      	mov	r3, r1
 80a4ef8:	2000      	movs	r0, #0
 80a4efa:	49b5      	ldr	r1, [pc, #724]	; (80a51d0 <__ieee754_pow+0x548>)
 80a4efc:	f001 f904 	bl	80a6108 <__aeabi_ddiv>
 80a4f00:	468c      	mov	ip, r1
 80a4f02:	4683      	mov	fp, r0
 80a4f04:	4663      	mov	r3, ip
 80a4f06:	465a      	mov	r2, fp
 80a4f08:	4630      	mov	r0, r6
 80a4f0a:	4639      	mov	r1, r7
 80a4f0c:	e9cd bc0e 	strd	fp, ip, [sp, #56]	; 0x38
 80a4f10:	f000 ffd0 	bl	80a5eb4 <__aeabi_dmul>
 80a4f14:	4682      	mov	sl, r0
 80a4f16:	468b      	mov	fp, r1
 80a4f18:	1063      	asrs	r3, r4, #1
 80a4f1a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80a4f1e:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
 80a4f22:	1959      	adds	r1, r3, r5
 80a4f24:	460d      	mov	r5, r1
 80a4f26:	465a      	mov	r2, fp
 80a4f28:	4651      	mov	r1, sl
 80a4f2a:	2300      	movs	r3, #0
 80a4f2c:	2000      	movs	r0, #0
 80a4f2e:	e9cd 1200 	strd	r1, r2, [sp]
 80a4f32:	9300      	str	r3, [sp, #0]
 80a4f34:	4604      	mov	r4, r0
 80a4f36:	4602      	mov	r2, r0
 80a4f38:	462b      	mov	r3, r5
 80a4f3a:	e9cd ab04 	strd	sl, fp, [sp, #16]
 80a4f3e:	e9dd ab00 	ldrd	sl, fp, [sp]
 80a4f42:	4650      	mov	r0, sl
 80a4f44:	4659      	mov	r1, fp
 80a4f46:	f000 ffb5 	bl	80a5eb4 <__aeabi_dmul>
 80a4f4a:	4602      	mov	r2, r0
 80a4f4c:	460b      	mov	r3, r1
 80a4f4e:	4630      	mov	r0, r6
 80a4f50:	4639      	mov	r1, r7
 80a4f52:	f000 fdf7 	bl	80a5b44 <__aeabi_dsub>
 80a4f56:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80a4f5a:	4606      	mov	r6, r0
 80a4f5c:	460f      	mov	r7, r1
 80a4f5e:	4620      	mov	r0, r4
 80a4f60:	4629      	mov	r1, r5
 80a4f62:	f000 fdef 	bl	80a5b44 <__aeabi_dsub>
 80a4f66:	4602      	mov	r2, r0
 80a4f68:	460b      	mov	r3, r1
 80a4f6a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80a4f6e:	f000 fde9 	bl	80a5b44 <__aeabi_dsub>
 80a4f72:	4652      	mov	r2, sl
 80a4f74:	465b      	mov	r3, fp
 80a4f76:	f000 ff9d 	bl	80a5eb4 <__aeabi_dmul>
 80a4f7a:	4602      	mov	r2, r0
 80a4f7c:	460b      	mov	r3, r1
 80a4f7e:	4630      	mov	r0, r6
 80a4f80:	4639      	mov	r1, r7
 80a4f82:	f000 fddf 	bl	80a5b44 <__aeabi_dsub>
 80a4f86:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 80a4f8a:	f000 ff93 	bl	80a5eb4 <__aeabi_dmul>
 80a4f8e:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 80a4f92:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80a4f96:	4622      	mov	r2, r4
 80a4f98:	462b      	mov	r3, r5
 80a4f9a:	4620      	mov	r0, r4
 80a4f9c:	4629      	mov	r1, r5
 80a4f9e:	f000 ff89 	bl	80a5eb4 <__aeabi_dmul>
 80a4fa2:	a375      	add	r3, pc, #468	; (adr r3, 80a5178 <__ieee754_pow+0x4f0>)
 80a4fa4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4fa8:	4604      	mov	r4, r0
 80a4faa:	460d      	mov	r5, r1
 80a4fac:	f000 ff82 	bl	80a5eb4 <__aeabi_dmul>
 80a4fb0:	a373      	add	r3, pc, #460	; (adr r3, 80a5180 <__ieee754_pow+0x4f8>)
 80a4fb2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4fb6:	f000 fdc7 	bl	80a5b48 <__adddf3>
 80a4fba:	4622      	mov	r2, r4
 80a4fbc:	462b      	mov	r3, r5
 80a4fbe:	f000 ff79 	bl	80a5eb4 <__aeabi_dmul>
 80a4fc2:	a371      	add	r3, pc, #452	; (adr r3, 80a5188 <__ieee754_pow+0x500>)
 80a4fc4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4fc8:	f000 fdbe 	bl	80a5b48 <__adddf3>
 80a4fcc:	4622      	mov	r2, r4
 80a4fce:	462b      	mov	r3, r5
 80a4fd0:	f000 ff70 	bl	80a5eb4 <__aeabi_dmul>
 80a4fd4:	a36e      	add	r3, pc, #440	; (adr r3, 80a5190 <__ieee754_pow+0x508>)
 80a4fd6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4fda:	f000 fdb5 	bl	80a5b48 <__adddf3>
 80a4fde:	4622      	mov	r2, r4
 80a4fe0:	462b      	mov	r3, r5
 80a4fe2:	f000 ff67 	bl	80a5eb4 <__aeabi_dmul>
 80a4fe6:	a36c      	add	r3, pc, #432	; (adr r3, 80a5198 <__ieee754_pow+0x510>)
 80a4fe8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4fec:	f000 fdac 	bl	80a5b48 <__adddf3>
 80a4ff0:	4622      	mov	r2, r4
 80a4ff2:	462b      	mov	r3, r5
 80a4ff4:	f000 ff5e 	bl	80a5eb4 <__aeabi_dmul>
 80a4ff8:	a369      	add	r3, pc, #420	; (adr r3, 80a51a0 <__ieee754_pow+0x518>)
 80a4ffa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a4ffe:	f000 fda3 	bl	80a5b48 <__adddf3>
 80a5002:	4622      	mov	r2, r4
 80a5004:	4606      	mov	r6, r0
 80a5006:	460f      	mov	r7, r1
 80a5008:	462b      	mov	r3, r5
 80a500a:	4620      	mov	r0, r4
 80a500c:	4629      	mov	r1, r5
 80a500e:	f000 ff51 	bl	80a5eb4 <__aeabi_dmul>
 80a5012:	4602      	mov	r2, r0
 80a5014:	460b      	mov	r3, r1
 80a5016:	4630      	mov	r0, r6
 80a5018:	4639      	mov	r1, r7
 80a501a:	f000 ff4b 	bl	80a5eb4 <__aeabi_dmul>
 80a501e:	4604      	mov	r4, r0
 80a5020:	460d      	mov	r5, r1
 80a5022:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80a5026:	4652      	mov	r2, sl
 80a5028:	465b      	mov	r3, fp
 80a502a:	f000 fd8d 	bl	80a5b48 <__adddf3>
 80a502e:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80a5032:	f000 ff3f 	bl	80a5eb4 <__aeabi_dmul>
 80a5036:	4622      	mov	r2, r4
 80a5038:	462b      	mov	r3, r5
 80a503a:	f000 fd85 	bl	80a5b48 <__adddf3>
 80a503e:	4652      	mov	r2, sl
 80a5040:	4606      	mov	r6, r0
 80a5042:	460f      	mov	r7, r1
 80a5044:	465b      	mov	r3, fp
 80a5046:	4650      	mov	r0, sl
 80a5048:	4659      	mov	r1, fp
 80a504a:	f000 ff33 	bl	80a5eb4 <__aeabi_dmul>
 80a504e:	4602      	mov	r2, r0
 80a5050:	460b      	mov	r3, r1
 80a5052:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 80a5056:	2200      	movs	r2, #0
 80a5058:	4b5e      	ldr	r3, [pc, #376]	; (80a51d4 <__ieee754_pow+0x54c>)
 80a505a:	f000 fd75 	bl	80a5b48 <__adddf3>
 80a505e:	4632      	mov	r2, r6
 80a5060:	463b      	mov	r3, r7
 80a5062:	f000 fd71 	bl	80a5b48 <__adddf3>
 80a5066:	2400      	movs	r4, #0
 80a5068:	460d      	mov	r5, r1
 80a506a:	4622      	mov	r2, r4
 80a506c:	462b      	mov	r3, r5
 80a506e:	4650      	mov	r0, sl
 80a5070:	4659      	mov	r1, fp
 80a5072:	f000 ff1f 	bl	80a5eb4 <__aeabi_dmul>
 80a5076:	2200      	movs	r2, #0
 80a5078:	4682      	mov	sl, r0
 80a507a:	468b      	mov	fp, r1
 80a507c:	4620      	mov	r0, r4
 80a507e:	4629      	mov	r1, r5
 80a5080:	4b54      	ldr	r3, [pc, #336]	; (80a51d4 <__ieee754_pow+0x54c>)
 80a5082:	f000 fd5f 	bl	80a5b44 <__aeabi_dsub>
 80a5086:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 80a508a:	f000 fd5b 	bl	80a5b44 <__aeabi_dsub>
 80a508e:	4602      	mov	r2, r0
 80a5090:	460b      	mov	r3, r1
 80a5092:	4630      	mov	r0, r6
 80a5094:	4639      	mov	r1, r7
 80a5096:	f000 fd55 	bl	80a5b44 <__aeabi_dsub>
 80a509a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80a509e:	f000 ff09 	bl	80a5eb4 <__aeabi_dmul>
 80a50a2:	4622      	mov	r2, r4
 80a50a4:	4606      	mov	r6, r0
 80a50a6:	460f      	mov	r7, r1
 80a50a8:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80a50ac:	462b      	mov	r3, r5
 80a50ae:	f000 ff01 	bl	80a5eb4 <__aeabi_dmul>
 80a50b2:	4602      	mov	r2, r0
 80a50b4:	460b      	mov	r3, r1
 80a50b6:	4630      	mov	r0, r6
 80a50b8:	4639      	mov	r1, r7
 80a50ba:	f000 fd45 	bl	80a5b48 <__adddf3>
 80a50be:	4606      	mov	r6, r0
 80a50c0:	460f      	mov	r7, r1
 80a50c2:	2400      	movs	r4, #0
 80a50c4:	4632      	mov	r2, r6
 80a50c6:	463b      	mov	r3, r7
 80a50c8:	4650      	mov	r0, sl
 80a50ca:	4659      	mov	r1, fp
 80a50cc:	f000 fd3c 	bl	80a5b48 <__adddf3>
 80a50d0:	a335      	add	r3, pc, #212	; (adr r3, 80a51a8 <__ieee754_pow+0x520>)
 80a50d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a50d6:	4620      	mov	r0, r4
 80a50d8:	460d      	mov	r5, r1
 80a50da:	f000 feeb 	bl	80a5eb4 <__aeabi_dmul>
 80a50de:	4652      	mov	r2, sl
 80a50e0:	465b      	mov	r3, fp
 80a50e2:	4682      	mov	sl, r0
 80a50e4:	468b      	mov	fp, r1
 80a50e6:	4620      	mov	r0, r4
 80a50e8:	4629      	mov	r1, r5
 80a50ea:	f000 fd2b 	bl	80a5b44 <__aeabi_dsub>
 80a50ee:	4602      	mov	r2, r0
 80a50f0:	460b      	mov	r3, r1
 80a50f2:	4630      	mov	r0, r6
 80a50f4:	4639      	mov	r1, r7
 80a50f6:	f000 fd25 	bl	80a5b44 <__aeabi_dsub>
 80a50fa:	a32d      	add	r3, pc, #180	; (adr r3, 80a51b0 <__ieee754_pow+0x528>)
 80a50fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a5100:	f000 fed8 	bl	80a5eb4 <__aeabi_dmul>
 80a5104:	4602      	mov	r2, r0
 80a5106:	460b      	mov	r3, r1
 80a5108:	4620      	mov	r0, r4
 80a510a:	4629      	mov	r1, r5
 80a510c:	4614      	mov	r4, r2
 80a510e:	461d      	mov	r5, r3
 80a5110:	a329      	add	r3, pc, #164	; (adr r3, 80a51b8 <__ieee754_pow+0x530>)
 80a5112:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a5116:	f000 fecd 	bl	80a5eb4 <__aeabi_dmul>
 80a511a:	4602      	mov	r2, r0
 80a511c:	460b      	mov	r3, r1
 80a511e:	4620      	mov	r0, r4
 80a5120:	4629      	mov	r1, r5
 80a5122:	f000 fd11 	bl	80a5b48 <__adddf3>
 80a5126:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 80a512a:	f000 fd0d 	bl	80a5b48 <__adddf3>
 80a512e:	4606      	mov	r6, r0
 80a5130:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80a5132:	460f      	mov	r7, r1
 80a5134:	f000 fe54 	bl	80a5de0 <__aeabi_i2d>
 80a5138:	4604      	mov	r4, r0
 80a513a:	460d      	mov	r5, r1
 80a513c:	4632      	mov	r2, r6
 80a513e:	463b      	mov	r3, r7
 80a5140:	4650      	mov	r0, sl
 80a5142:	4659      	mov	r1, fp
 80a5144:	f000 fd00 	bl	80a5b48 <__adddf3>
 80a5148:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80a514c:	f000 fcfc 	bl	80a5b48 <__adddf3>
 80a5150:	4622      	mov	r2, r4
 80a5152:	462b      	mov	r3, r5
 80a5154:	f000 fcf8 	bl	80a5b48 <__adddf3>
 80a5158:	4622      	mov	r2, r4
 80a515a:	2400      	movs	r4, #0
 80a515c:	462b      	mov	r3, r5
 80a515e:	4620      	mov	r0, r4
 80a5160:	460d      	mov	r5, r1
 80a5162:	f000 fcef 	bl	80a5b44 <__aeabi_dsub>
 80a5166:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80a516a:	f000 fceb 	bl	80a5b44 <__aeabi_dsub>
 80a516e:	4652      	mov	r2, sl
 80a5170:	465b      	mov	r3, fp
 80a5172:	e031      	b.n	80a51d8 <__ieee754_pow+0x550>
 80a5174:	f3af 8000 	nop.w
 80a5178:	4a454eef 	.word	0x4a454eef
 80a517c:	3fca7e28 	.word	0x3fca7e28
 80a5180:	93c9db65 	.word	0x93c9db65
 80a5184:	3fcd864a 	.word	0x3fcd864a
 80a5188:	a91d4101 	.word	0xa91d4101
 80a518c:	3fd17460 	.word	0x3fd17460
 80a5190:	518f264d 	.word	0x518f264d
 80a5194:	3fd55555 	.word	0x3fd55555
 80a5198:	db6fabff 	.word	0xdb6fabff
 80a519c:	3fdb6db6 	.word	0x3fdb6db6
 80a51a0:	33333303 	.word	0x33333303
 80a51a4:	3fe33333 	.word	0x3fe33333
 80a51a8:	e0000000 	.word	0xe0000000
 80a51ac:	3feec709 	.word	0x3feec709
 80a51b0:	dc3a03fd 	.word	0xdc3a03fd
 80a51b4:	3feec709 	.word	0x3feec709
 80a51b8:	145b01f5 	.word	0x145b01f5
 80a51bc:	be3e2fe0 	.word	0xbe3e2fe0
 80a51c0:	7ff00000 	.word	0x7ff00000
 80a51c4:	43400000 	.word	0x43400000
 80a51c8:	0003988e 	.word	0x0003988e
 80a51cc:	000bb679 	.word	0x000bb679
 80a51d0:	3ff00000 	.word	0x3ff00000
 80a51d4:	40080000 	.word	0x40080000
 80a51d8:	f000 fcb4 	bl	80a5b44 <__aeabi_dsub>
 80a51dc:	4602      	mov	r2, r0
 80a51de:	460b      	mov	r3, r1
 80a51e0:	4630      	mov	r0, r6
 80a51e2:	4639      	mov	r1, r7
 80a51e4:	f000 fcae 	bl	80a5b44 <__aeabi_dsub>
 80a51e8:	9b02      	ldr	r3, [sp, #8]
 80a51ea:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80a51ec:	3b01      	subs	r3, #1
 80a51ee:	4313      	orrs	r3, r2
 80a51f0:	f04f 0200 	mov.w	r2, #0
 80a51f4:	bf0c      	ite	eq
 80a51f6:	4bd2      	ldreq	r3, [pc, #840]	; (80a5540 <__ieee754_pow+0x8b8>)
 80a51f8:	4bd2      	ldrne	r3, [pc, #840]	; (80a5544 <__ieee754_pow+0x8bc>)
 80a51fa:	e9cd 8900 	strd	r8, r9, [sp]
 80a51fe:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80a5202:	2300      	movs	r3, #0
 80a5204:	9300      	str	r3, [sp, #0]
 80a5206:	e9dd ab00 	ldrd	sl, fp, [sp]
 80a520a:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80a520e:	4652      	mov	r2, sl
 80a5210:	4640      	mov	r0, r8
 80a5212:	4649      	mov	r1, r9
 80a5214:	465b      	mov	r3, fp
 80a5216:	f000 fc95 	bl	80a5b44 <__aeabi_dsub>
 80a521a:	4622      	mov	r2, r4
 80a521c:	462b      	mov	r3, r5
 80a521e:	f000 fe49 	bl	80a5eb4 <__aeabi_dmul>
 80a5222:	4642      	mov	r2, r8
 80a5224:	4606      	mov	r6, r0
 80a5226:	460f      	mov	r7, r1
 80a5228:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80a522c:	464b      	mov	r3, r9
 80a522e:	f000 fe41 	bl	80a5eb4 <__aeabi_dmul>
 80a5232:	4602      	mov	r2, r0
 80a5234:	460b      	mov	r3, r1
 80a5236:	4630      	mov	r0, r6
 80a5238:	4639      	mov	r1, r7
 80a523a:	f000 fc85 	bl	80a5b48 <__adddf3>
 80a523e:	4652      	mov	r2, sl
 80a5240:	4606      	mov	r6, r0
 80a5242:	460f      	mov	r7, r1
 80a5244:	465b      	mov	r3, fp
 80a5246:	4620      	mov	r0, r4
 80a5248:	4629      	mov	r1, r5
 80a524a:	f000 fe33 	bl	80a5eb4 <__aeabi_dmul>
 80a524e:	4604      	mov	r4, r0
 80a5250:	460d      	mov	r5, r1
 80a5252:	4630      	mov	r0, r6
 80a5254:	462b      	mov	r3, r5
 80a5256:	4639      	mov	r1, r7
 80a5258:	4622      	mov	r2, r4
 80a525a:	f000 fc75 	bl	80a5b48 <__adddf3>
 80a525e:	4bba      	ldr	r3, [pc, #744]	; (80a5548 <__ieee754_pow+0x8c0>)
 80a5260:	4680      	mov	r8, r0
 80a5262:	4299      	cmp	r1, r3
 80a5264:	4689      	mov	r9, r1
 80a5266:	468a      	mov	sl, r1
 80a5268:	f340 8114 	ble.w	80a5494 <__ieee754_pow+0x80c>
 80a526c:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
 80a5270:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
 80a5274:	4303      	orrs	r3, r0
 80a5276:	f040 81f6 	bne.w	80a5666 <__ieee754_pow+0x9de>
 80a527a:	a39d      	add	r3, pc, #628	; (adr r3, 80a54f0 <__ieee754_pow+0x868>)
 80a527c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a5280:	4630      	mov	r0, r6
 80a5282:	4639      	mov	r1, r7
 80a5284:	f000 fc60 	bl	80a5b48 <__adddf3>
 80a5288:	4602      	mov	r2, r0
 80a528a:	460b      	mov	r3, r1
 80a528c:	4640      	mov	r0, r8
 80a528e:	4649      	mov	r1, r9
 80a5290:	4690      	mov	r8, r2
 80a5292:	4699      	mov	r9, r3
 80a5294:	4622      	mov	r2, r4
 80a5296:	462b      	mov	r3, r5
 80a5298:	f000 fc54 	bl	80a5b44 <__aeabi_dsub>
 80a529c:	4602      	mov	r2, r0
 80a529e:	460b      	mov	r3, r1
 80a52a0:	4640      	mov	r0, r8
 80a52a2:	4649      	mov	r1, r9
 80a52a4:	f001 f896 	bl	80a63d4 <__aeabi_dcmpgt>
 80a52a8:	2800      	cmp	r0, #0
 80a52aa:	f040 81dc 	bne.w	80a5666 <__ieee754_pow+0x9de>
 80a52ae:	f3ca 530a 	ubfx	r3, sl, #20, #11
 80a52b2:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 80a52b6:	2000      	movs	r0, #0
 80a52b8:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
 80a52bc:	fa42 f303 	asr.w	r3, r2, r3
 80a52c0:	4453      	add	r3, sl
 80a52c2:	49a2      	ldr	r1, [pc, #648]	; (80a554c <__ieee754_pow+0x8c4>)
 80a52c4:	f3c3 520a 	ubfx	r2, r3, #20, #11
 80a52c8:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
 80a52cc:	fa41 fc02 	asr.w	ip, r1, r2
 80a52d0:	f3c3 0b13 	ubfx	fp, r3, #0, #20
 80a52d4:	ea23 010c 	bic.w	r1, r3, ip
 80a52d8:	f1c2 0214 	rsb	r2, r2, #20
 80a52dc:	f44b 1b80 	orr.w	fp, fp, #1048576	; 0x100000
 80a52e0:	f1ba 0f00 	cmp.w	sl, #0
 80a52e4:	460b      	mov	r3, r1
 80a52e6:	fa4b fb02 	asr.w	fp, fp, r2
 80a52ea:	4629      	mov	r1, r5
 80a52ec:	4602      	mov	r2, r0
 80a52ee:	4620      	mov	r0, r4
 80a52f0:	bfb8      	it	lt
 80a52f2:	f1cb 0b00 	rsblt	fp, fp, #0
 80a52f6:	f000 fc25 	bl	80a5b44 <__aeabi_dsub>
 80a52fa:	4604      	mov	r4, r0
 80a52fc:	460d      	mov	r5, r1
 80a52fe:	4630      	mov	r0, r6
 80a5300:	4639      	mov	r1, r7
 80a5302:	4622      	mov	r2, r4
 80a5304:	462b      	mov	r3, r5
 80a5306:	f000 fc1f 	bl	80a5b48 <__adddf3>
 80a530a:	4689      	mov	r9, r1
 80a530c:	ea4f 5a0b 	mov.w	sl, fp, lsl #20
 80a5310:	f04f 0800 	mov.w	r8, #0
 80a5314:	a378      	add	r3, pc, #480	; (adr r3, 80a54f8 <__ieee754_pow+0x870>)
 80a5316:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a531a:	4640      	mov	r0, r8
 80a531c:	4649      	mov	r1, r9
 80a531e:	f000 fdc9 	bl	80a5eb4 <__aeabi_dmul>
 80a5322:	4622      	mov	r2, r4
 80a5324:	462b      	mov	r3, r5
 80a5326:	4604      	mov	r4, r0
 80a5328:	460d      	mov	r5, r1
 80a532a:	4640      	mov	r0, r8
 80a532c:	4649      	mov	r1, r9
 80a532e:	f000 fc09 	bl	80a5b44 <__aeabi_dsub>
 80a5332:	4602      	mov	r2, r0
 80a5334:	460b      	mov	r3, r1
 80a5336:	4630      	mov	r0, r6
 80a5338:	4639      	mov	r1, r7
 80a533a:	f000 fc03 	bl	80a5b44 <__aeabi_dsub>
 80a533e:	a370      	add	r3, pc, #448	; (adr r3, 80a5500 <__ieee754_pow+0x878>)
 80a5340:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a5344:	f000 fdb6 	bl	80a5eb4 <__aeabi_dmul>
 80a5348:	a36f      	add	r3, pc, #444	; (adr r3, 80a5508 <__ieee754_pow+0x880>)
 80a534a:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a534e:	4606      	mov	r6, r0
 80a5350:	460f      	mov	r7, r1
 80a5352:	4640      	mov	r0, r8
 80a5354:	4649      	mov	r1, r9
 80a5356:	f000 fdad 	bl	80a5eb4 <__aeabi_dmul>
 80a535a:	4602      	mov	r2, r0
 80a535c:	460b      	mov	r3, r1
 80a535e:	4630      	mov	r0, r6
 80a5360:	4639      	mov	r1, r7
 80a5362:	f000 fbf1 	bl	80a5b48 <__adddf3>
 80a5366:	4680      	mov	r8, r0
 80a5368:	4689      	mov	r9, r1
 80a536a:	4642      	mov	r2, r8
 80a536c:	464b      	mov	r3, r9
 80a536e:	4620      	mov	r0, r4
 80a5370:	4629      	mov	r1, r5
 80a5372:	f000 fbe9 	bl	80a5b48 <__adddf3>
 80a5376:	4622      	mov	r2, r4
 80a5378:	462b      	mov	r3, r5
 80a537a:	4606      	mov	r6, r0
 80a537c:	460f      	mov	r7, r1
 80a537e:	f000 fbe1 	bl	80a5b44 <__aeabi_dsub>
 80a5382:	4602      	mov	r2, r0
 80a5384:	460b      	mov	r3, r1
 80a5386:	4640      	mov	r0, r8
 80a5388:	4649      	mov	r1, r9
 80a538a:	f000 fbdb 	bl	80a5b44 <__aeabi_dsub>
 80a538e:	4632      	mov	r2, r6
 80a5390:	4680      	mov	r8, r0
 80a5392:	4689      	mov	r9, r1
 80a5394:	463b      	mov	r3, r7
 80a5396:	4630      	mov	r0, r6
 80a5398:	4639      	mov	r1, r7
 80a539a:	f000 fd8b 	bl	80a5eb4 <__aeabi_dmul>
 80a539e:	a35c      	add	r3, pc, #368	; (adr r3, 80a5510 <__ieee754_pow+0x888>)
 80a53a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a53a4:	4604      	mov	r4, r0
 80a53a6:	460d      	mov	r5, r1
 80a53a8:	f000 fd84 	bl	80a5eb4 <__aeabi_dmul>
 80a53ac:	a35a      	add	r3, pc, #360	; (adr r3, 80a5518 <__ieee754_pow+0x890>)
 80a53ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a53b2:	f000 fbc7 	bl	80a5b44 <__aeabi_dsub>
 80a53b6:	4622      	mov	r2, r4
 80a53b8:	462b      	mov	r3, r5
 80a53ba:	f000 fd7b 	bl	80a5eb4 <__aeabi_dmul>
 80a53be:	a358      	add	r3, pc, #352	; (adr r3, 80a5520 <__ieee754_pow+0x898>)
 80a53c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a53c4:	f000 fbc0 	bl	80a5b48 <__adddf3>
 80a53c8:	4622      	mov	r2, r4
 80a53ca:	462b      	mov	r3, r5
 80a53cc:	f000 fd72 	bl	80a5eb4 <__aeabi_dmul>
 80a53d0:	a355      	add	r3, pc, #340	; (adr r3, 80a5528 <__ieee754_pow+0x8a0>)
 80a53d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a53d6:	f000 fbb5 	bl	80a5b44 <__aeabi_dsub>
 80a53da:	4622      	mov	r2, r4
 80a53dc:	462b      	mov	r3, r5
 80a53de:	f000 fd69 	bl	80a5eb4 <__aeabi_dmul>
 80a53e2:	a353      	add	r3, pc, #332	; (adr r3, 80a5530 <__ieee754_pow+0x8a8>)
 80a53e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a53e8:	f000 fbae 	bl	80a5b48 <__adddf3>
 80a53ec:	4622      	mov	r2, r4
 80a53ee:	462b      	mov	r3, r5
 80a53f0:	f000 fd60 	bl	80a5eb4 <__aeabi_dmul>
 80a53f4:	4602      	mov	r2, r0
 80a53f6:	460b      	mov	r3, r1
 80a53f8:	4630      	mov	r0, r6
 80a53fa:	4639      	mov	r1, r7
 80a53fc:	f000 fba2 	bl	80a5b44 <__aeabi_dsub>
 80a5400:	4604      	mov	r4, r0
 80a5402:	460d      	mov	r5, r1
 80a5404:	4622      	mov	r2, r4
 80a5406:	462b      	mov	r3, r5
 80a5408:	4630      	mov	r0, r6
 80a540a:	4639      	mov	r1, r7
 80a540c:	f000 fd52 	bl	80a5eb4 <__aeabi_dmul>
 80a5410:	4602      	mov	r2, r0
 80a5412:	460b      	mov	r3, r1
 80a5414:	4620      	mov	r0, r4
 80a5416:	4629      	mov	r1, r5
 80a5418:	4614      	mov	r4, r2
 80a541a:	461d      	mov	r5, r3
 80a541c:	2200      	movs	r2, #0
 80a541e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80a5422:	f000 fb8f 	bl	80a5b44 <__aeabi_dsub>
 80a5426:	4602      	mov	r2, r0
 80a5428:	460b      	mov	r3, r1
 80a542a:	4620      	mov	r0, r4
 80a542c:	4629      	mov	r1, r5
 80a542e:	f000 fe6b 	bl	80a6108 <__aeabi_ddiv>
 80a5432:	4642      	mov	r2, r8
 80a5434:	4604      	mov	r4, r0
 80a5436:	460d      	mov	r5, r1
 80a5438:	464b      	mov	r3, r9
 80a543a:	4630      	mov	r0, r6
 80a543c:	4639      	mov	r1, r7
 80a543e:	f000 fd39 	bl	80a5eb4 <__aeabi_dmul>
 80a5442:	4642      	mov	r2, r8
 80a5444:	464b      	mov	r3, r9
 80a5446:	f000 fb7f 	bl	80a5b48 <__adddf3>
 80a544a:	4602      	mov	r2, r0
 80a544c:	460b      	mov	r3, r1
 80a544e:	4620      	mov	r0, r4
 80a5450:	4629      	mov	r1, r5
 80a5452:	f000 fb77 	bl	80a5b44 <__aeabi_dsub>
 80a5456:	4632      	mov	r2, r6
 80a5458:	463b      	mov	r3, r7
 80a545a:	f000 fb73 	bl	80a5b44 <__aeabi_dsub>
 80a545e:	4602      	mov	r2, r0
 80a5460:	460b      	mov	r3, r1
 80a5462:	2000      	movs	r0, #0
 80a5464:	4937      	ldr	r1, [pc, #220]	; (80a5544 <__ieee754_pow+0x8bc>)
 80a5466:	f000 fb6d 	bl	80a5b44 <__aeabi_dsub>
 80a546a:	448a      	add	sl, r1
 80a546c:	f5ba 1f80 	cmp.w	sl, #1048576	; 0x100000
 80a5470:	f2c0 8135 	blt.w	80a56de <__ieee754_pow+0xa56>
 80a5474:	4651      	mov	r1, sl
 80a5476:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80a547a:	f000 fd1b 	bl	80a5eb4 <__aeabi_dmul>
 80a547e:	e9cd 0100 	strd	r0, r1, [sp]
 80a5482:	e447      	b.n	80a4d14 <__ieee754_pow+0x8c>
 80a5484:	2e00      	cmp	r6, #0
 80a5486:	f6ff acb1 	blt.w	80a4dec <__ieee754_pow+0x164>
 80a548a:	2300      	movs	r3, #0
 80a548c:	2400      	movs	r4, #0
 80a548e:	e9cd 3400 	strd	r3, r4, [sp]
 80a5492:	e43f      	b.n	80a4d14 <__ieee754_pow+0x8c>
 80a5494:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 80a5550 <__ieee754_pow+0x8c8>
 80a5498:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 80a549c:	4563      	cmp	r3, ip
 80a549e:	f340 80da 	ble.w	80a5656 <__ieee754_pow+0x9ce>
 80a54a2:	4b2c      	ldr	r3, [pc, #176]	; (80a5554 <__ieee754_pow+0x8cc>)
 80a54a4:	440b      	add	r3, r1
 80a54a6:	4303      	orrs	r3, r0
 80a54a8:	d10a      	bne.n	80a54c0 <__ieee754_pow+0x838>
 80a54aa:	4622      	mov	r2, r4
 80a54ac:	462b      	mov	r3, r5
 80a54ae:	f000 fb49 	bl	80a5b44 <__aeabi_dsub>
 80a54b2:	4632      	mov	r2, r6
 80a54b4:	463b      	mov	r3, r7
 80a54b6:	f000 ff83 	bl	80a63c0 <__aeabi_dcmpge>
 80a54ba:	2800      	cmp	r0, #0
 80a54bc:	f43f aef7 	beq.w	80a52ae <__ieee754_pow+0x626>
 80a54c0:	a31d      	add	r3, pc, #116	; (adr r3, 80a5538 <__ieee754_pow+0x8b0>)
 80a54c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a54c6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80a54ca:	f000 fcf3 	bl	80a5eb4 <__aeabi_dmul>
 80a54ce:	a31a      	add	r3, pc, #104	; (adr r3, 80a5538 <__ieee754_pow+0x8b0>)
 80a54d0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a54d4:	f000 fcee 	bl	80a5eb4 <__aeabi_dmul>
 80a54d8:	e9cd 0100 	strd	r0, r1, [sp]
 80a54dc:	e41a      	b.n	80a4d14 <__ieee754_pow+0x8c>
 80a54de:	2e00      	cmp	r6, #0
 80a54e0:	dad3      	bge.n	80a548a <__ieee754_pow+0x802>
 80a54e2:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
 80a54e6:	f8cd 8000 	str.w	r8, [sp]
 80a54ea:	9301      	str	r3, [sp, #4]
 80a54ec:	e412      	b.n	80a4d14 <__ieee754_pow+0x8c>
 80a54ee:	bf00      	nop
 80a54f0:	652b82fe 	.word	0x652b82fe
 80a54f4:	3c971547 	.word	0x3c971547
 80a54f8:	00000000 	.word	0x00000000
 80a54fc:	3fe62e43 	.word	0x3fe62e43
 80a5500:	fefa39ef 	.word	0xfefa39ef
 80a5504:	3fe62e42 	.word	0x3fe62e42
 80a5508:	0ca86c39 	.word	0x0ca86c39
 80a550c:	be205c61 	.word	0xbe205c61
 80a5510:	72bea4d0 	.word	0x72bea4d0
 80a5514:	3e663769 	.word	0x3e663769
 80a5518:	c5d26bf1 	.word	0xc5d26bf1
 80a551c:	3ebbbd41 	.word	0x3ebbbd41
 80a5520:	af25de2c 	.word	0xaf25de2c
 80a5524:	3f11566a 	.word	0x3f11566a
 80a5528:	16bebd93 	.word	0x16bebd93
 80a552c:	3f66c16c 	.word	0x3f66c16c
 80a5530:	5555553e 	.word	0x5555553e
 80a5534:	3fc55555 	.word	0x3fc55555
 80a5538:	c2f8f359 	.word	0xc2f8f359
 80a553c:	01a56e1f 	.word	0x01a56e1f
 80a5540:	bff00000 	.word	0xbff00000
 80a5544:	3ff00000 	.word	0x3ff00000
 80a5548:	408fffff 	.word	0x408fffff
 80a554c:	000fffff 	.word	0x000fffff
 80a5550:	4090cbff 	.word	0x4090cbff
 80a5554:	3f6f3400 	.word	0x3f6f3400
 80a5558:	429c      	cmp	r4, r3
 80a555a:	db93      	blt.n	80a5484 <__ieee754_pow+0x7fc>
 80a555c:	4b7a      	ldr	r3, [pc, #488]	; (80a5748 <__ieee754_pow+0xac0>)
 80a555e:	429c      	cmp	r4, r3
 80a5560:	f73f ac41 	bgt.w	80a4de6 <__ieee754_pow+0x15e>
 80a5564:	e9dd 0100 	ldrd	r0, r1, [sp]
 80a5568:	2200      	movs	r2, #0
 80a556a:	4b77      	ldr	r3, [pc, #476]	; (80a5748 <__ieee754_pow+0xac0>)
 80a556c:	f000 faea 	bl	80a5b44 <__aeabi_dsub>
 80a5570:	a367      	add	r3, pc, #412	; (adr r3, 80a5710 <__ieee754_pow+0xa88>)
 80a5572:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a5576:	4604      	mov	r4, r0
 80a5578:	460d      	mov	r5, r1
 80a557a:	f000 fc9b 	bl	80a5eb4 <__aeabi_dmul>
 80a557e:	a366      	add	r3, pc, #408	; (adr r3, 80a5718 <__ieee754_pow+0xa90>)
 80a5580:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a5584:	4682      	mov	sl, r0
 80a5586:	468b      	mov	fp, r1
 80a5588:	4620      	mov	r0, r4
 80a558a:	4629      	mov	r1, r5
 80a558c:	f000 fc92 	bl	80a5eb4 <__aeabi_dmul>
 80a5590:	2200      	movs	r2, #0
 80a5592:	e9cd 0100 	strd	r0, r1, [sp]
 80a5596:	4b6d      	ldr	r3, [pc, #436]	; (80a574c <__ieee754_pow+0xac4>)
 80a5598:	4620      	mov	r0, r4
 80a559a:	4629      	mov	r1, r5
 80a559c:	f000 fc8a 	bl	80a5eb4 <__aeabi_dmul>
 80a55a0:	4602      	mov	r2, r0
 80a55a2:	460b      	mov	r3, r1
 80a55a4:	a15e      	add	r1, pc, #376	; (adr r1, 80a5720 <__ieee754_pow+0xa98>)
 80a55a6:	e9d1 0100 	ldrd	r0, r1, [r1]
 80a55aa:	f000 facb 	bl	80a5b44 <__aeabi_dsub>
 80a55ae:	4622      	mov	r2, r4
 80a55b0:	462b      	mov	r3, r5
 80a55b2:	f000 fc7f 	bl	80a5eb4 <__aeabi_dmul>
 80a55b6:	4602      	mov	r2, r0
 80a55b8:	460b      	mov	r3, r1
 80a55ba:	2000      	movs	r0, #0
 80a55bc:	4964      	ldr	r1, [pc, #400]	; (80a5750 <__ieee754_pow+0xac8>)
 80a55be:	f000 fac1 	bl	80a5b44 <__aeabi_dsub>
 80a55c2:	4622      	mov	r2, r4
 80a55c4:	4606      	mov	r6, r0
 80a55c6:	460f      	mov	r7, r1
 80a55c8:	462b      	mov	r3, r5
 80a55ca:	4620      	mov	r0, r4
 80a55cc:	4629      	mov	r1, r5
 80a55ce:	f000 fc71 	bl	80a5eb4 <__aeabi_dmul>
 80a55d2:	4602      	mov	r2, r0
 80a55d4:	460b      	mov	r3, r1
 80a55d6:	4630      	mov	r0, r6
 80a55d8:	4639      	mov	r1, r7
 80a55da:	f000 fc6b 	bl	80a5eb4 <__aeabi_dmul>
 80a55de:	a352      	add	r3, pc, #328	; (adr r3, 80a5728 <__ieee754_pow+0xaa0>)
 80a55e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a55e4:	f000 fc66 	bl	80a5eb4 <__aeabi_dmul>
 80a55e8:	4602      	mov	r2, r0
 80a55ea:	460b      	mov	r3, r1
 80a55ec:	e9dd 0100 	ldrd	r0, r1, [sp]
 80a55f0:	f000 faa8 	bl	80a5b44 <__aeabi_dsub>
 80a55f4:	4606      	mov	r6, r0
 80a55f6:	460f      	mov	r7, r1
 80a55f8:	4632      	mov	r2, r6
 80a55fa:	463b      	mov	r3, r7
 80a55fc:	4650      	mov	r0, sl
 80a55fe:	4659      	mov	r1, fp
 80a5600:	f000 faa2 	bl	80a5b48 <__adddf3>
 80a5604:	2400      	movs	r4, #0
 80a5606:	4652      	mov	r2, sl
 80a5608:	465b      	mov	r3, fp
 80a560a:	460d      	mov	r5, r1
 80a560c:	4620      	mov	r0, r4
 80a560e:	e5e3      	b.n	80a51d8 <__ieee754_pow+0x550>
 80a5610:	2500      	movs	r5, #0
 80a5612:	e43b      	b.n	80a4e8c <__ieee754_pow+0x204>
 80a5614:	465a      	mov	r2, fp
 80a5616:	2000      	movs	r0, #0
 80a5618:	4653      	mov	r3, sl
 80a561a:	494b      	ldr	r1, [pc, #300]	; (80a5748 <__ieee754_pow+0xac0>)
 80a561c:	f000 fd74 	bl	80a6108 <__aeabi_ddiv>
 80a5620:	e9cd 0100 	strd	r0, r1, [sp]
 80a5624:	f7ff bb76 	b.w	80a4d14 <__ieee754_pow+0x8c>
 80a5628:	465a      	mov	r2, fp
 80a562a:	4658      	mov	r0, fp
 80a562c:	4653      	mov	r3, sl
 80a562e:	4651      	mov	r1, sl
 80a5630:	f000 fc40 	bl	80a5eb4 <__aeabi_dmul>
 80a5634:	e9cd 0100 	strd	r0, r1, [sp]
 80a5638:	f7ff bb6c 	b.w	80a4d14 <__ieee754_pow+0x8c>
 80a563c:	2b00      	cmp	r3, #0
 80a563e:	d140      	bne.n	80a56c2 <__ieee754_pow+0xa3a>
 80a5640:	f1c2 0214 	rsb	r2, r2, #20
 80a5644:	fa45 f102 	asr.w	r1, r5, r2
 80a5648:	fa01 f202 	lsl.w	r2, r1, r2
 80a564c:	42aa      	cmp	r2, r5
 80a564e:	d054      	beq.n	80a56fa <__ieee754_pow+0xa72>
 80a5650:	9302      	str	r3, [sp, #8]
 80a5652:	f7ff bb3e 	b.w	80a4cd2 <__ieee754_pow+0x4a>
 80a5656:	4a3e      	ldr	r2, [pc, #248]	; (80a5750 <__ieee754_pow+0xac8>)
 80a5658:	4293      	cmp	r3, r2
 80a565a:	dc55      	bgt.n	80a5708 <__ieee754_pow+0xa80>
 80a565c:	e9dd 2300 	ldrd	r2, r3, [sp]
 80a5660:	4692      	mov	sl, r2
 80a5662:	4693      	mov	fp, r2
 80a5664:	e654      	b.n	80a5310 <__ieee754_pow+0x688>
 80a5666:	a332      	add	r3, pc, #200	; (adr r3, 80a5730 <__ieee754_pow+0xaa8>)
 80a5668:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a566c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80a5670:	f000 fc20 	bl	80a5eb4 <__aeabi_dmul>
 80a5674:	a32e      	add	r3, pc, #184	; (adr r3, 80a5730 <__ieee754_pow+0xaa8>)
 80a5676:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a567a:	f000 fc1b 	bl	80a5eb4 <__aeabi_dmul>
 80a567e:	e9cd 0100 	strd	r0, r1, [sp]
 80a5682:	f7ff bb47 	b.w	80a4d14 <__ieee754_pow+0x8c>
 80a5686:	9b02      	ldr	r3, [sp, #8]
 80a5688:	2b01      	cmp	r3, #1
 80a568a:	f47f ab43 	bne.w	80a4d14 <__ieee754_pow+0x8c>
 80a568e:	e9dd 4500 	ldrd	r4, r5, [sp]
 80a5692:	4622      	mov	r2, r4
 80a5694:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
 80a5698:	e9cd 2300 	strd	r2, r3, [sp]
 80a569c:	f7ff bb3a 	b.w	80a4d14 <__ieee754_pow+0x8c>
 80a56a0:	2200      	movs	r2, #0
 80a56a2:	4b2c      	ldr	r3, [pc, #176]	; (80a5754 <__ieee754_pow+0xacc>)
 80a56a4:	f44f 2580 	mov.w	r5, #262144	; 0x40000
 80a56a8:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80a56ac:	a322      	add	r3, pc, #136	; (adr r3, 80a5738 <__ieee754_pow+0xab0>)
 80a56ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a56b2:	e9cd 2308 	strd	r2, r3, [sp, #32]
 80a56b6:	a322      	add	r3, pc, #136	; (adr r3, 80a5740 <__ieee754_pow+0xab8>)
 80a56b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a56bc:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
 80a56c0:	e405      	b.n	80a4ece <__ieee754_pow+0x246>
 80a56c2:	4658      	mov	r0, fp
 80a56c4:	4651      	mov	r1, sl
 80a56c6:	f000 f90d 	bl	80a58e4 <fabs>
 80a56ca:	465b      	mov	r3, fp
 80a56cc:	e9cd 0100 	strd	r0, r1, [sp]
 80a56d0:	2b00      	cmp	r3, #0
 80a56d2:	f47f abb2 	bne.w	80a4e3a <__ieee754_pow+0x1b2>
 80a56d6:	f8cd b008 	str.w	fp, [sp, #8]
 80a56da:	f7ff bb4b 	b.w	80a4d74 <__ieee754_pow+0xec>
 80a56de:	465a      	mov	r2, fp
 80a56e0:	f000 f9ae 	bl	80a5a40 <scalbn>
 80a56e4:	e6c7      	b.n	80a5476 <__ieee754_pow+0x7ee>
 80a56e6:	f001 0101 	and.w	r1, r1, #1
 80a56ea:	f1c1 0202 	rsb	r2, r1, #2
 80a56ee:	9202      	str	r2, [sp, #8]
 80a56f0:	2b00      	cmp	r3, #0
 80a56f2:	f43f aaee 	beq.w	80a4cd2 <__ieee754_pow+0x4a>
 80a56f6:	f7ff bb35 	b.w	80a4d64 <__ieee754_pow+0xdc>
 80a56fa:	f001 0101 	and.w	r1, r1, #1
 80a56fe:	f1c1 0302 	rsb	r3, r1, #2
 80a5702:	9302      	str	r3, [sp, #8]
 80a5704:	f7ff bae5 	b.w	80a4cd2 <__ieee754_pow+0x4a>
 80a5708:	151b      	asrs	r3, r3, #20
 80a570a:	e5d2      	b.n	80a52b2 <__ieee754_pow+0x62a>
 80a570c:	f3af 8000 	nop.w
 80a5710:	60000000 	.word	0x60000000
 80a5714:	3ff71547 	.word	0x3ff71547
 80a5718:	f85ddf44 	.word	0xf85ddf44
 80a571c:	3e54ae0b 	.word	0x3e54ae0b
 80a5720:	55555555 	.word	0x55555555
 80a5724:	3fd55555 	.word	0x3fd55555
 80a5728:	652b82fe 	.word	0x652b82fe
 80a572c:	3ff71547 	.word	0x3ff71547
 80a5730:	8800759c 	.word	0x8800759c
 80a5734:	7e37e43c 	.word	0x7e37e43c
 80a5738:	40000000 	.word	0x40000000
 80a573c:	3fe2b803 	.word	0x3fe2b803
 80a5740:	43cfd006 	.word	0x43cfd006
 80a5744:	3e4cfdeb 	.word	0x3e4cfdeb
 80a5748:	3ff00000 	.word	0x3ff00000
 80a574c:	3fd00000 	.word	0x3fd00000
 80a5750:	3fe00000 	.word	0x3fe00000
 80a5754:	3ff80000 	.word	0x3ff80000

080a5758 <__ieee754_sqrt>:
 80a5758:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a575c:	4e60      	ldr	r6, [pc, #384]	; (80a58e0 <__ieee754_sqrt+0x188>)
 80a575e:	4605      	mov	r5, r0
 80a5760:	ea36 0201 	bics.w	r2, r6, r1
 80a5764:	460c      	mov	r4, r1
 80a5766:	f000 809e 	beq.w	80a58a6 <__ieee754_sqrt+0x14e>
 80a576a:	2900      	cmp	r1, #0
 80a576c:	460b      	mov	r3, r1
 80a576e:	4684      	mov	ip, r0
 80a5770:	dd54      	ble.n	80a581c <__ieee754_sqrt+0xc4>
 80a5772:	1509      	asrs	r1, r1, #20
 80a5774:	d062      	beq.n	80a583c <__ieee754_sqrt+0xe4>
 80a5776:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80a577a:	07c8      	lsls	r0, r1, #31
 80a577c:	f2a1 37ff 	subw	r7, r1, #1023	; 0x3ff
 80a5780:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80a5784:	d404      	bmi.n	80a5790 <__ieee754_sqrt+0x38>
 80a5786:	005b      	lsls	r3, r3, #1
 80a5788:	eb03 73dc 	add.w	r3, r3, ip, lsr #31
 80a578c:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 80a5790:	2600      	movs	r6, #0
 80a5792:	ea4f 72dc 	mov.w	r2, ip, lsr #31
 80a5796:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80a579a:	f04f 0e16 	mov.w	lr, #22
 80a579e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 80a57a2:	4634      	mov	r4, r6
 80a57a4:	107f      	asrs	r7, r7, #1
 80a57a6:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 80a57aa:	18a1      	adds	r1, r4, r2
 80a57ac:	4299      	cmp	r1, r3
 80a57ae:	dc02      	bgt.n	80a57b6 <__ieee754_sqrt+0x5e>
 80a57b0:	1a5b      	subs	r3, r3, r1
 80a57b2:	188c      	adds	r4, r1, r2
 80a57b4:	4416      	add	r6, r2
 80a57b6:	005b      	lsls	r3, r3, #1
 80a57b8:	f1be 0e01 	subs.w	lr, lr, #1
 80a57bc:	eb03 73dc 	add.w	r3, r3, ip, lsr #31
 80a57c0:	ea4f 0252 	mov.w	r2, r2, lsr #1
 80a57c4:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 80a57c8:	d1ef      	bne.n	80a57aa <__ieee754_sqrt+0x52>
 80a57ca:	4675      	mov	r5, lr
 80a57cc:	2020      	movs	r0, #32
 80a57ce:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 80a57d2:	e00a      	b.n	80a57ea <__ieee754_sqrt+0x92>
 80a57d4:	d043      	beq.n	80a585e <__ieee754_sqrt+0x106>
 80a57d6:	ea4f 71dc 	mov.w	r1, ip, lsr #31
 80a57da:	3801      	subs	r0, #1
 80a57dc:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 80a57e0:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 80a57e4:	ea4f 0252 	mov.w	r2, r2, lsr #1
 80a57e8:	d042      	beq.n	80a5870 <__ieee754_sqrt+0x118>
 80a57ea:	42a3      	cmp	r3, r4
 80a57ec:	eb02 010e 	add.w	r1, r2, lr
 80a57f0:	ddf0      	ble.n	80a57d4 <__ieee754_sqrt+0x7c>
 80a57f2:	2900      	cmp	r1, #0
 80a57f4:	eb01 0e02 	add.w	lr, r1, r2
 80a57f8:	db0a      	blt.n	80a5810 <__ieee754_sqrt+0xb8>
 80a57fa:	46a0      	mov	r8, r4
 80a57fc:	1b1b      	subs	r3, r3, r4
 80a57fe:	4561      	cmp	r1, ip
 80a5800:	bf88      	it	hi
 80a5802:	f103 33ff 	addhi.w	r3, r3, #4294967295
 80a5806:	4644      	mov	r4, r8
 80a5808:	ebac 0c01 	sub.w	ip, ip, r1
 80a580c:	4415      	add	r5, r2
 80a580e:	e7e2      	b.n	80a57d6 <__ieee754_sqrt+0x7e>
 80a5810:	f1be 0f00 	cmp.w	lr, #0
 80a5814:	dbf1      	blt.n	80a57fa <__ieee754_sqrt+0xa2>
 80a5816:	f104 0801 	add.w	r8, r4, #1
 80a581a:	e7ef      	b.n	80a57fc <__ieee754_sqrt+0xa4>
 80a581c:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 80a5820:	4302      	orrs	r2, r0
 80a5822:	d036      	beq.n	80a5892 <__ieee754_sqrt+0x13a>
 80a5824:	2900      	cmp	r1, #0
 80a5826:	d14c      	bne.n	80a58c2 <__ieee754_sqrt+0x16a>
 80a5828:	ea4f 22dc 	mov.w	r2, ip, lsr #11
 80a582c:	4613      	mov	r3, r2
 80a582e:	3915      	subs	r1, #21
 80a5830:	ea4f 5c4c 	mov.w	ip, ip, lsl #21
 80a5834:	2a00      	cmp	r2, #0
 80a5836:	d0f7      	beq.n	80a5828 <__ieee754_sqrt+0xd0>
 80a5838:	02d6      	lsls	r6, r2, #11
 80a583a:	d44c      	bmi.n	80a58d6 <__ieee754_sqrt+0x17e>
 80a583c:	2000      	movs	r0, #0
 80a583e:	005b      	lsls	r3, r3, #1
 80a5840:	02dd      	lsls	r5, r3, #11
 80a5842:	4604      	mov	r4, r0
 80a5844:	f100 0001 	add.w	r0, r0, #1
 80a5848:	d5f9      	bpl.n	80a583e <__ieee754_sqrt+0xe6>
 80a584a:	461a      	mov	r2, r3
 80a584c:	4663      	mov	r3, ip
 80a584e:	fa0c fc00 	lsl.w	ip, ip, r0
 80a5852:	f1c0 0020 	rsb	r0, r0, #32
 80a5856:	40c3      	lsrs	r3, r0
 80a5858:	1b09      	subs	r1, r1, r4
 80a585a:	4313      	orrs	r3, r2
 80a585c:	e78b      	b.n	80a5776 <__ieee754_sqrt+0x1e>
 80a585e:	4561      	cmp	r1, ip
 80a5860:	d8b9      	bhi.n	80a57d6 <__ieee754_sqrt+0x7e>
 80a5862:	2900      	cmp	r1, #0
 80a5864:	eb01 0e02 	add.w	lr, r1, r2
 80a5868:	dbd2      	blt.n	80a5810 <__ieee754_sqrt+0xb8>
 80a586a:	4698      	mov	r8, r3
 80a586c:	2300      	movs	r3, #0
 80a586e:	e7ca      	b.n	80a5806 <__ieee754_sqrt+0xae>
 80a5870:	ea53 030c 	orrs.w	r3, r3, ip
 80a5874:	d111      	bne.n	80a589a <__ieee754_sqrt+0x142>
 80a5876:	0868      	lsrs	r0, r5, #1
 80a5878:	1073      	asrs	r3, r6, #1
 80a587a:	f103 537f 	add.w	r3, r3, #1069547520	; 0x3fc00000
 80a587e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
 80a5882:	07f2      	lsls	r2, r6, #31
 80a5884:	bf48      	it	mi
 80a5886:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
 80a588a:	eb03 5907 	add.w	r9, r3, r7, lsl #20
 80a588e:	4605      	mov	r5, r0
 80a5890:	464c      	mov	r4, r9
 80a5892:	4628      	mov	r0, r5
 80a5894:	4621      	mov	r1, r4
 80a5896:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a589a:	1c69      	adds	r1, r5, #1
 80a589c:	bf16      	itet	ne
 80a589e:	1c68      	addne	r0, r5, #1
 80a58a0:	3601      	addeq	r6, #1
 80a58a2:	0840      	lsrne	r0, r0, #1
 80a58a4:	e7e8      	b.n	80a5878 <__ieee754_sqrt+0x120>
 80a58a6:	4602      	mov	r2, r0
 80a58a8:	460b      	mov	r3, r1
 80a58aa:	f000 fb03 	bl	80a5eb4 <__aeabi_dmul>
 80a58ae:	462a      	mov	r2, r5
 80a58b0:	4623      	mov	r3, r4
 80a58b2:	f000 f949 	bl	80a5b48 <__adddf3>
 80a58b6:	4605      	mov	r5, r0
 80a58b8:	460c      	mov	r4, r1
 80a58ba:	4628      	mov	r0, r5
 80a58bc:	4621      	mov	r1, r4
 80a58be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a58c2:	4602      	mov	r2, r0
 80a58c4:	f000 f93e 	bl	80a5b44 <__aeabi_dsub>
 80a58c8:	4602      	mov	r2, r0
 80a58ca:	460b      	mov	r3, r1
 80a58cc:	f000 fc1c 	bl	80a6108 <__aeabi_ddiv>
 80a58d0:	4605      	mov	r5, r0
 80a58d2:	460c      	mov	r4, r1
 80a58d4:	e7dd      	b.n	80a5892 <__ieee754_sqrt+0x13a>
 80a58d6:	4663      	mov	r3, ip
 80a58d8:	2020      	movs	r0, #32
 80a58da:	f04f 34ff 	mov.w	r4, #4294967295
 80a58de:	e7ba      	b.n	80a5856 <__ieee754_sqrt+0xfe>
 80a58e0:	7ff00000 	.word	0x7ff00000

080a58e4 <fabs>:
 80a58e4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a58e8:	4770      	bx	lr
 80a58ea:	bf00      	nop

080a58ec <finite>:
 80a58ec:	f041 4000 	orr.w	r0, r1, #2147483648	; 0x80000000
 80a58f0:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
 80a58f4:	0fc0      	lsrs	r0, r0, #31
 80a58f6:	4770      	bx	lr

080a58f8 <nan>:
 80a58f8:	2000      	movs	r0, #0
 80a58fa:	4901      	ldr	r1, [pc, #4]	; (80a5900 <nan+0x8>)
 80a58fc:	4770      	bx	lr
 80a58fe:	bf00      	nop
 80a5900:	7ff80000 	.word	0x7ff80000

080a5904 <rint>:
 80a5904:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a5906:	f3c1 550a 	ubfx	r5, r1, #20, #11
 80a590a:	f2a5 3cff 	subw	ip, r5, #1023	; 0x3ff
 80a590e:	f1bc 0f13 	cmp.w	ip, #19
 80a5912:	4602      	mov	r2, r0
 80a5914:	460b      	mov	r3, r1
 80a5916:	460c      	mov	r4, r1
 80a5918:	4686      	mov	lr, r0
 80a591a:	b083      	sub	sp, #12
 80a591c:	ea4f 76d1 	mov.w	r6, r1, lsr #31
 80a5920:	dc65      	bgt.n	80a59ee <rint+0xea>
 80a5922:	f1bc 0f00 	cmp.w	ip, #0
 80a5926:	db30      	blt.n	80a598a <rint+0x86>
 80a5928:	4942      	ldr	r1, [pc, #264]	; (80a5a34 <rint+0x130>)
 80a592a:	fa41 f10c 	asr.w	r1, r1, ip
 80a592e:	ea03 0001 	and.w	r0, r3, r1
 80a5932:	4310      	orrs	r0, r2
 80a5934:	d061      	beq.n	80a59fa <rint+0xf6>
 80a5936:	ea03 0351 	and.w	r3, r3, r1, lsr #1
 80a593a:	ea52 0e03 	orrs.w	lr, r2, r3
 80a593e:	ea4f 0151 	mov.w	r1, r1, lsr #1
 80a5942:	d00d      	beq.n	80a5960 <rint+0x5c>
 80a5944:	ea24 0101 	bic.w	r1, r4, r1
 80a5948:	f44f 2480 	mov.w	r4, #262144	; 0x40000
 80a594c:	f1bc 0f13 	cmp.w	ip, #19
 80a5950:	bf0c      	ite	eq
 80a5952:	f04f 4e00 	moveq.w	lr, #2147483648	; 0x80000000
 80a5956:	f04f 0e00 	movne.w	lr, #0
 80a595a:	fa44 f40c 	asr.w	r4, r4, ip
 80a595e:	430c      	orrs	r4, r1
 80a5960:	4935      	ldr	r1, [pc, #212]	; (80a5a38 <rint+0x134>)
 80a5962:	4623      	mov	r3, r4
 80a5964:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
 80a5968:	e9d6 6700 	ldrd	r6, r7, [r6]
 80a596c:	4672      	mov	r2, lr
 80a596e:	4630      	mov	r0, r6
 80a5970:	4639      	mov	r1, r7
 80a5972:	f000 f8e9 	bl	80a5b48 <__adddf3>
 80a5976:	e9cd 0100 	strd	r0, r1, [sp]
 80a597a:	e9dd 0100 	ldrd	r0, r1, [sp]
 80a597e:	4632      	mov	r2, r6
 80a5980:	463b      	mov	r3, r7
 80a5982:	f000 f8df 	bl	80a5b44 <__aeabi_dsub>
 80a5986:	b003      	add	sp, #12
 80a5988:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a598a:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a598e:	4301      	orrs	r1, r0
 80a5990:	4619      	mov	r1, r3
 80a5992:	d0f8      	beq.n	80a5986 <rint+0x82>
 80a5994:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80a5998:	ea43 0e00 	orr.w	lr, r3, r0
 80a599c:	f1ce 0300 	rsb	r3, lr, #0
 80a59a0:	ea43 030e 	orr.w	r3, r3, lr
 80a59a4:	0c62      	lsrs	r2, r4, #17
 80a59a6:	0b1b      	lsrs	r3, r3, #12
 80a59a8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80a59ac:	0452      	lsls	r2, r2, #17
 80a59ae:	ea43 0102 	orr.w	r1, r3, r2
 80a59b2:	460b      	mov	r3, r1
 80a59b4:	4920      	ldr	r1, [pc, #128]	; (80a5a38 <rint+0x134>)
 80a59b6:	4602      	mov	r2, r0
 80a59b8:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
 80a59bc:	e9d6 6700 	ldrd	r6, r7, [r6]
 80a59c0:	4630      	mov	r0, r6
 80a59c2:	4639      	mov	r1, r7
 80a59c4:	f000 f8c0 	bl	80a5b48 <__adddf3>
 80a59c8:	e9cd 0100 	strd	r0, r1, [sp]
 80a59cc:	e9dd 0100 	ldrd	r0, r1, [sp]
 80a59d0:	4632      	mov	r2, r6
 80a59d2:	463b      	mov	r3, r7
 80a59d4:	f000 f8b6 	bl	80a5b44 <__aeabi_dsub>
 80a59d8:	4602      	mov	r2, r0
 80a59da:	f004 4400 	and.w	r4, r4, #2147483648	; 0x80000000
 80a59de:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a59e2:	ea41 0304 	orr.w	r3, r1, r4
 80a59e6:	4610      	mov	r0, r2
 80a59e8:	4619      	mov	r1, r3
 80a59ea:	b003      	add	sp, #12
 80a59ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a59ee:	f1bc 0f33 	cmp.w	ip, #51	; 0x33
 80a59f2:	dd06      	ble.n	80a5a02 <rint+0xfe>
 80a59f4:	f5bc 6f80 	cmp.w	ip, #1024	; 0x400
 80a59f8:	d018      	beq.n	80a5a2c <rint+0x128>
 80a59fa:	4610      	mov	r0, r2
 80a59fc:	4619      	mov	r1, r3
 80a59fe:	b003      	add	sp, #12
 80a5a00:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5a02:	f04f 31ff 	mov.w	r1, #4294967295
 80a5a06:	f2a5 4513 	subw	r5, r5, #1043	; 0x413
 80a5a0a:	40e9      	lsrs	r1, r5
 80a5a0c:	4208      	tst	r0, r1
 80a5a0e:	d0f4      	beq.n	80a59fa <rint+0xf6>
 80a5a10:	ea10 0251 	ands.w	r2, r0, r1, lsr #1
 80a5a14:	ea4f 0351 	mov.w	r3, r1, lsr #1
 80a5a18:	d0a2      	beq.n	80a5960 <rint+0x5c>
 80a5a1a:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
 80a5a1e:	ea20 0303 	bic.w	r3, r0, r3
 80a5a22:	fa4e f505 	asr.w	r5, lr, r5
 80a5a26:	ea43 0e05 	orr.w	lr, r3, r5
 80a5a2a:	e799      	b.n	80a5960 <rint+0x5c>
 80a5a2c:	f000 f88c 	bl	80a5b48 <__adddf3>
 80a5a30:	e7a9      	b.n	80a5986 <rint+0x82>
 80a5a32:	bf00      	nop
 80a5a34:	000fffff 	.word	0x000fffff
 80a5a38:	080a7440 	.word	0x080a7440
 80a5a3c:	00000000 	.word	0x00000000

080a5a40 <scalbn>:
 80a5a40:	f3c1 530a 	ubfx	r3, r1, #20, #11
 80a5a44:	b570      	push	{r4, r5, r6, lr}
 80a5a46:	468c      	mov	ip, r1
 80a5a48:	4604      	mov	r4, r0
 80a5a4a:	460d      	mov	r5, r1
 80a5a4c:	4616      	mov	r6, r2
 80a5a4e:	bb7b      	cbnz	r3, 80a5ab0 <scalbn+0x70>
 80a5a50:	4603      	mov	r3, r0
 80a5a52:	f021 4c00 	bic.w	ip, r1, #2147483648	; 0x80000000
 80a5a56:	ea5c 0303 	orrs.w	r3, ip, r3
 80a5a5a:	d028      	beq.n	80a5aae <scalbn+0x6e>
 80a5a5c:	4b32      	ldr	r3, [pc, #200]	; (80a5b28 <scalbn+0xe8>)
 80a5a5e:	2200      	movs	r2, #0
 80a5a60:	f000 fa28 	bl	80a5eb4 <__aeabi_dmul>
 80a5a64:	4b31      	ldr	r3, [pc, #196]	; (80a5b2c <scalbn+0xec>)
 80a5a66:	4604      	mov	r4, r0
 80a5a68:	429e      	cmp	r6, r3
 80a5a6a:	460d      	mov	r5, r1
 80a5a6c:	db1a      	blt.n	80a5aa4 <scalbn+0x64>
 80a5a6e:	468c      	mov	ip, r1
 80a5a70:	f3c1 530a 	ubfx	r3, r1, #20, #11
 80a5a74:	3b36      	subs	r3, #54	; 0x36
 80a5a76:	f240 72fe 	movw	r2, #2046	; 0x7fe
 80a5a7a:	4433      	add	r3, r6
 80a5a7c:	4293      	cmp	r3, r2
 80a5a7e:	dc20      	bgt.n	80a5ac2 <scalbn+0x82>
 80a5a80:	2b00      	cmp	r3, #0
 80a5a82:	dc3e      	bgt.n	80a5b02 <scalbn+0xc2>
 80a5a84:	f113 0f35 	cmn.w	r3, #53	; 0x35
 80a5a88:	da2c      	bge.n	80a5ae4 <scalbn+0xa4>
 80a5a8a:	f24c 3350 	movw	r3, #50000	; 0xc350
 80a5a8e:	429e      	cmp	r6, r3
 80a5a90:	dc17      	bgt.n	80a5ac2 <scalbn+0x82>
 80a5a92:	f005 4300 	and.w	r3, r5, #2147483648	; 0x80000000
 80a5a96:	f043 71d2 	orr.w	r1, r3, #27525120	; 0x1a40000
 80a5a9a:	f441 31b7 	orr.w	r1, r1, #93696	; 0x16e00
 80a5a9e:	4824      	ldr	r0, [pc, #144]	; (80a5b30 <scalbn+0xf0>)
 80a5aa0:	f041 011f 	orr.w	r1, r1, #31
 80a5aa4:	a31c      	add	r3, pc, #112	; (adr r3, 80a5b18 <scalbn+0xd8>)
 80a5aa6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a5aaa:	f000 fa03 	bl	80a5eb4 <__aeabi_dmul>
 80a5aae:	bd70      	pop	{r4, r5, r6, pc}
 80a5ab0:	f240 7eff 	movw	lr, #2047	; 0x7ff
 80a5ab4:	4573      	cmp	r3, lr
 80a5ab6:	d1de      	bne.n	80a5a76 <scalbn+0x36>
 80a5ab8:	4602      	mov	r2, r0
 80a5aba:	460b      	mov	r3, r1
 80a5abc:	f000 f844 	bl	80a5b48 <__adddf3>
 80a5ac0:	bd70      	pop	{r4, r5, r6, pc}
 80a5ac2:	f005 4300 	and.w	r3, r5, #2147483648	; 0x80000000
 80a5ac6:	f043 41fc 	orr.w	r1, r3, #2113929216	; 0x7e000000
 80a5aca:	f441 115f 	orr.w	r1, r1, #3653632	; 0x37c000
 80a5ace:	f441 5110 	orr.w	r1, r1, #9216	; 0x2400
 80a5ad2:	a313      	add	r3, pc, #76	; (adr r3, 80a5b20 <scalbn+0xe0>)
 80a5ad4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a5ad8:	4816      	ldr	r0, [pc, #88]	; (80a5b34 <scalbn+0xf4>)
 80a5ada:	f041 013c 	orr.w	r1, r1, #60	; 0x3c
 80a5ade:	f000 f9e9 	bl	80a5eb4 <__aeabi_dmul>
 80a5ae2:	bd70      	pop	{r4, r5, r6, pc}
 80a5ae4:	f02c 4cff 	bic.w	ip, ip, #2139095040	; 0x7f800000
 80a5ae8:	f103 0136 	add.w	r1, r3, #54	; 0x36
 80a5aec:	f42c 0ce0 	bic.w	ip, ip, #7340032	; 0x700000
 80a5af0:	ea4c 5501 	orr.w	r5, ip, r1, lsl #20
 80a5af4:	2200      	movs	r2, #0
 80a5af6:	4620      	mov	r0, r4
 80a5af8:	4629      	mov	r1, r5
 80a5afa:	4b0f      	ldr	r3, [pc, #60]	; (80a5b38 <scalbn+0xf8>)
 80a5afc:	f000 f9da 	bl	80a5eb4 <__aeabi_dmul>
 80a5b00:	bd70      	pop	{r4, r5, r6, pc}
 80a5b02:	f02c 4cff 	bic.w	ip, ip, #2139095040	; 0x7f800000
 80a5b06:	f42c 0ce0 	bic.w	ip, ip, #7340032	; 0x700000
 80a5b0a:	4620      	mov	r0, r4
 80a5b0c:	ea4c 5103 	orr.w	r1, ip, r3, lsl #20
 80a5b10:	bd70      	pop	{r4, r5, r6, pc}
 80a5b12:	bf00      	nop
 80a5b14:	f3af 8000 	nop.w
 80a5b18:	c2f8f359 	.word	0xc2f8f359
 80a5b1c:	01a56e1f 	.word	0x01a56e1f
 80a5b20:	8800759c 	.word	0x8800759c
 80a5b24:	7e37e43c 	.word	0x7e37e43c
 80a5b28:	43500000 	.word	0x43500000
 80a5b2c:	ffff3cb0 	.word	0xffff3cb0
 80a5b30:	c2f8f359 	.word	0xc2f8f359
 80a5b34:	8800759c 	.word	0x8800759c
 80a5b38:	3c900000 	.word	0x3c900000

080a5b3c <__aeabi_drsub>:
 80a5b3c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80a5b40:	e002      	b.n	80a5b48 <__adddf3>
 80a5b42:	bf00      	nop

080a5b44 <__aeabi_dsub>:
 80a5b44:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080a5b48 <__adddf3>:
 80a5b48:	b530      	push	{r4, r5, lr}
 80a5b4a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80a5b4e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80a5b52:	ea94 0f05 	teq	r4, r5
 80a5b56:	bf08      	it	eq
 80a5b58:	ea90 0f02 	teqeq	r0, r2
 80a5b5c:	bf1f      	itttt	ne
 80a5b5e:	ea54 0c00 	orrsne.w	ip, r4, r0
 80a5b62:	ea55 0c02 	orrsne.w	ip, r5, r2
 80a5b66:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80a5b6a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a5b6e:	f000 80e2 	beq.w	80a5d36 <__adddf3+0x1ee>
 80a5b72:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80a5b76:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80a5b7a:	bfb8      	it	lt
 80a5b7c:	426d      	neglt	r5, r5
 80a5b7e:	dd0c      	ble.n	80a5b9a <__adddf3+0x52>
 80a5b80:	442c      	add	r4, r5
 80a5b82:	ea80 0202 	eor.w	r2, r0, r2
 80a5b86:	ea81 0303 	eor.w	r3, r1, r3
 80a5b8a:	ea82 0000 	eor.w	r0, r2, r0
 80a5b8e:	ea83 0101 	eor.w	r1, r3, r1
 80a5b92:	ea80 0202 	eor.w	r2, r0, r2
 80a5b96:	ea81 0303 	eor.w	r3, r1, r3
 80a5b9a:	2d36      	cmp	r5, #54	; 0x36
 80a5b9c:	bf88      	it	hi
 80a5b9e:	bd30      	pophi	{r4, r5, pc}
 80a5ba0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a5ba4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a5ba8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80a5bac:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80a5bb0:	d002      	beq.n	80a5bb8 <__adddf3+0x70>
 80a5bb2:	4240      	negs	r0, r0
 80a5bb4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a5bb8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80a5bbc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a5bc0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80a5bc4:	d002      	beq.n	80a5bcc <__adddf3+0x84>
 80a5bc6:	4252      	negs	r2, r2
 80a5bc8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a5bcc:	ea94 0f05 	teq	r4, r5
 80a5bd0:	f000 80a7 	beq.w	80a5d22 <__adddf3+0x1da>
 80a5bd4:	f1a4 0401 	sub.w	r4, r4, #1
 80a5bd8:	f1d5 0e20 	rsbs	lr, r5, #32
 80a5bdc:	db0d      	blt.n	80a5bfa <__adddf3+0xb2>
 80a5bde:	fa02 fc0e 	lsl.w	ip, r2, lr
 80a5be2:	fa22 f205 	lsr.w	r2, r2, r5
 80a5be6:	1880      	adds	r0, r0, r2
 80a5be8:	f141 0100 	adc.w	r1, r1, #0
 80a5bec:	fa03 f20e 	lsl.w	r2, r3, lr
 80a5bf0:	1880      	adds	r0, r0, r2
 80a5bf2:	fa43 f305 	asr.w	r3, r3, r5
 80a5bf6:	4159      	adcs	r1, r3
 80a5bf8:	e00e      	b.n	80a5c18 <__adddf3+0xd0>
 80a5bfa:	f1a5 0520 	sub.w	r5, r5, #32
 80a5bfe:	f10e 0e20 	add.w	lr, lr, #32
 80a5c02:	2a01      	cmp	r2, #1
 80a5c04:	fa03 fc0e 	lsl.w	ip, r3, lr
 80a5c08:	bf28      	it	cs
 80a5c0a:	f04c 0c02 	orrcs.w	ip, ip, #2
 80a5c0e:	fa43 f305 	asr.w	r3, r3, r5
 80a5c12:	18c0      	adds	r0, r0, r3
 80a5c14:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80a5c18:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a5c1c:	d507      	bpl.n	80a5c2e <__adddf3+0xe6>
 80a5c1e:	f04f 0e00 	mov.w	lr, #0
 80a5c22:	f1dc 0c00 	rsbs	ip, ip, #0
 80a5c26:	eb7e 0000 	sbcs.w	r0, lr, r0
 80a5c2a:	eb6e 0101 	sbc.w	r1, lr, r1
 80a5c2e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80a5c32:	d31b      	bcc.n	80a5c6c <__adddf3+0x124>
 80a5c34:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80a5c38:	d30c      	bcc.n	80a5c54 <__adddf3+0x10c>
 80a5c3a:	0849      	lsrs	r1, r1, #1
 80a5c3c:	ea5f 0030 	movs.w	r0, r0, rrx
 80a5c40:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80a5c44:	f104 0401 	add.w	r4, r4, #1
 80a5c48:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80a5c4c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80a5c50:	f080 809a 	bcs.w	80a5d88 <__adddf3+0x240>
 80a5c54:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a5c58:	bf08      	it	eq
 80a5c5a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a5c5e:	f150 0000 	adcs.w	r0, r0, #0
 80a5c62:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a5c66:	ea41 0105 	orr.w	r1, r1, r5
 80a5c6a:	bd30      	pop	{r4, r5, pc}
 80a5c6c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80a5c70:	4140      	adcs	r0, r0
 80a5c72:	eb41 0101 	adc.w	r1, r1, r1
 80a5c76:	3c01      	subs	r4, #1
 80a5c78:	bf28      	it	cs
 80a5c7a:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 80a5c7e:	d2e9      	bcs.n	80a5c54 <__adddf3+0x10c>
 80a5c80:	f091 0f00 	teq	r1, #0
 80a5c84:	bf04      	itt	eq
 80a5c86:	4601      	moveq	r1, r0
 80a5c88:	2000      	moveq	r0, #0
 80a5c8a:	fab1 f381 	clz	r3, r1
 80a5c8e:	bf08      	it	eq
 80a5c90:	3320      	addeq	r3, #32
 80a5c92:	f1a3 030b 	sub.w	r3, r3, #11
 80a5c96:	f1b3 0220 	subs.w	r2, r3, #32
 80a5c9a:	da0c      	bge.n	80a5cb6 <__adddf3+0x16e>
 80a5c9c:	320c      	adds	r2, #12
 80a5c9e:	dd08      	ble.n	80a5cb2 <__adddf3+0x16a>
 80a5ca0:	f102 0c14 	add.w	ip, r2, #20
 80a5ca4:	f1c2 020c 	rsb	r2, r2, #12
 80a5ca8:	fa01 f00c 	lsl.w	r0, r1, ip
 80a5cac:	fa21 f102 	lsr.w	r1, r1, r2
 80a5cb0:	e00c      	b.n	80a5ccc <__adddf3+0x184>
 80a5cb2:	f102 0214 	add.w	r2, r2, #20
 80a5cb6:	bfd8      	it	le
 80a5cb8:	f1c2 0c20 	rsble	ip, r2, #32
 80a5cbc:	fa01 f102 	lsl.w	r1, r1, r2
 80a5cc0:	fa20 fc0c 	lsr.w	ip, r0, ip
 80a5cc4:	bfdc      	itt	le
 80a5cc6:	ea41 010c 	orrle.w	r1, r1, ip
 80a5cca:	4090      	lslle	r0, r2
 80a5ccc:	1ae4      	subs	r4, r4, r3
 80a5cce:	bfa2      	ittt	ge
 80a5cd0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80a5cd4:	4329      	orrge	r1, r5
 80a5cd6:	bd30      	popge	{r4, r5, pc}
 80a5cd8:	ea6f 0404 	mvn.w	r4, r4
 80a5cdc:	3c1f      	subs	r4, #31
 80a5cde:	da1c      	bge.n	80a5d1a <__adddf3+0x1d2>
 80a5ce0:	340c      	adds	r4, #12
 80a5ce2:	dc0e      	bgt.n	80a5d02 <__adddf3+0x1ba>
 80a5ce4:	f104 0414 	add.w	r4, r4, #20
 80a5ce8:	f1c4 0220 	rsb	r2, r4, #32
 80a5cec:	fa20 f004 	lsr.w	r0, r0, r4
 80a5cf0:	fa01 f302 	lsl.w	r3, r1, r2
 80a5cf4:	ea40 0003 	orr.w	r0, r0, r3
 80a5cf8:	fa21 f304 	lsr.w	r3, r1, r4
 80a5cfc:	ea45 0103 	orr.w	r1, r5, r3
 80a5d00:	bd30      	pop	{r4, r5, pc}
 80a5d02:	f1c4 040c 	rsb	r4, r4, #12
 80a5d06:	f1c4 0220 	rsb	r2, r4, #32
 80a5d0a:	fa20 f002 	lsr.w	r0, r0, r2
 80a5d0e:	fa01 f304 	lsl.w	r3, r1, r4
 80a5d12:	ea40 0003 	orr.w	r0, r0, r3
 80a5d16:	4629      	mov	r1, r5
 80a5d18:	bd30      	pop	{r4, r5, pc}
 80a5d1a:	fa21 f004 	lsr.w	r0, r1, r4
 80a5d1e:	4629      	mov	r1, r5
 80a5d20:	bd30      	pop	{r4, r5, pc}
 80a5d22:	f094 0f00 	teq	r4, #0
 80a5d26:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80a5d2a:	bf06      	itte	eq
 80a5d2c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80a5d30:	3401      	addeq	r4, #1
 80a5d32:	3d01      	subne	r5, #1
 80a5d34:	e74e      	b.n	80a5bd4 <__adddf3+0x8c>
 80a5d36:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a5d3a:	bf18      	it	ne
 80a5d3c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a5d40:	d029      	beq.n	80a5d96 <__adddf3+0x24e>
 80a5d42:	ea94 0f05 	teq	r4, r5
 80a5d46:	bf08      	it	eq
 80a5d48:	ea90 0f02 	teqeq	r0, r2
 80a5d4c:	d005      	beq.n	80a5d5a <__adddf3+0x212>
 80a5d4e:	ea54 0c00 	orrs.w	ip, r4, r0
 80a5d52:	bf04      	itt	eq
 80a5d54:	4619      	moveq	r1, r3
 80a5d56:	4610      	moveq	r0, r2
 80a5d58:	bd30      	pop	{r4, r5, pc}
 80a5d5a:	ea91 0f03 	teq	r1, r3
 80a5d5e:	bf1e      	ittt	ne
 80a5d60:	2100      	movne	r1, #0
 80a5d62:	2000      	movne	r0, #0
 80a5d64:	bd30      	popne	{r4, r5, pc}
 80a5d66:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80a5d6a:	d105      	bne.n	80a5d78 <__adddf3+0x230>
 80a5d6c:	0040      	lsls	r0, r0, #1
 80a5d6e:	4149      	adcs	r1, r1
 80a5d70:	bf28      	it	cs
 80a5d72:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80a5d76:	bd30      	pop	{r4, r5, pc}
 80a5d78:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80a5d7c:	bf3c      	itt	cc
 80a5d7e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80a5d82:	bd30      	popcc	{r4, r5, pc}
 80a5d84:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a5d88:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80a5d8c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a5d90:	f04f 0000 	mov.w	r0, #0
 80a5d94:	bd30      	pop	{r4, r5, pc}
 80a5d96:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a5d9a:	bf1a      	itte	ne
 80a5d9c:	4619      	movne	r1, r3
 80a5d9e:	4610      	movne	r0, r2
 80a5da0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80a5da4:	bf1c      	itt	ne
 80a5da6:	460b      	movne	r3, r1
 80a5da8:	4602      	movne	r2, r0
 80a5daa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a5dae:	bf06      	itte	eq
 80a5db0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80a5db4:	ea91 0f03 	teqeq	r1, r3
 80a5db8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80a5dbc:	bd30      	pop	{r4, r5, pc}
 80a5dbe:	bf00      	nop

080a5dc0 <__aeabi_ui2d>:
 80a5dc0:	f090 0f00 	teq	r0, #0
 80a5dc4:	bf04      	itt	eq
 80a5dc6:	2100      	moveq	r1, #0
 80a5dc8:	4770      	bxeq	lr
 80a5dca:	b530      	push	{r4, r5, lr}
 80a5dcc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a5dd0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a5dd4:	f04f 0500 	mov.w	r5, #0
 80a5dd8:	f04f 0100 	mov.w	r1, #0
 80a5ddc:	e750      	b.n	80a5c80 <__adddf3+0x138>
 80a5dde:	bf00      	nop

080a5de0 <__aeabi_i2d>:
 80a5de0:	f090 0f00 	teq	r0, #0
 80a5de4:	bf04      	itt	eq
 80a5de6:	2100      	moveq	r1, #0
 80a5de8:	4770      	bxeq	lr
 80a5dea:	b530      	push	{r4, r5, lr}
 80a5dec:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a5df0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a5df4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80a5df8:	bf48      	it	mi
 80a5dfa:	4240      	negmi	r0, r0
 80a5dfc:	f04f 0100 	mov.w	r1, #0
 80a5e00:	e73e      	b.n	80a5c80 <__adddf3+0x138>
 80a5e02:	bf00      	nop

080a5e04 <__aeabi_f2d>:
 80a5e04:	0042      	lsls	r2, r0, #1
 80a5e06:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80a5e0a:	ea4f 0131 	mov.w	r1, r1, rrx
 80a5e0e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80a5e12:	bf1f      	itttt	ne
 80a5e14:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80a5e18:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a5e1c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80a5e20:	4770      	bxne	lr
 80a5e22:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80a5e26:	bf08      	it	eq
 80a5e28:	4770      	bxeq	lr
 80a5e2a:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80a5e2e:	bf04      	itt	eq
 80a5e30:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80a5e34:	4770      	bxeq	lr
 80a5e36:	b530      	push	{r4, r5, lr}
 80a5e38:	f44f 7460 	mov.w	r4, #896	; 0x380
 80a5e3c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a5e40:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a5e44:	e71c      	b.n	80a5c80 <__adddf3+0x138>
 80a5e46:	bf00      	nop

080a5e48 <__aeabi_ul2d>:
 80a5e48:	ea50 0201 	orrs.w	r2, r0, r1
 80a5e4c:	bf08      	it	eq
 80a5e4e:	4770      	bxeq	lr
 80a5e50:	b530      	push	{r4, r5, lr}
 80a5e52:	f04f 0500 	mov.w	r5, #0
 80a5e56:	e00a      	b.n	80a5e6e <__aeabi_l2d+0x16>

080a5e58 <__aeabi_l2d>:
 80a5e58:	ea50 0201 	orrs.w	r2, r0, r1
 80a5e5c:	bf08      	it	eq
 80a5e5e:	4770      	bxeq	lr
 80a5e60:	b530      	push	{r4, r5, lr}
 80a5e62:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80a5e66:	d502      	bpl.n	80a5e6e <__aeabi_l2d+0x16>
 80a5e68:	4240      	negs	r0, r0
 80a5e6a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a5e6e:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a5e72:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a5e76:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80a5e7a:	f43f aed8 	beq.w	80a5c2e <__adddf3+0xe6>
 80a5e7e:	f04f 0203 	mov.w	r2, #3
 80a5e82:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a5e86:	bf18      	it	ne
 80a5e88:	3203      	addne	r2, #3
 80a5e8a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a5e8e:	bf18      	it	ne
 80a5e90:	3203      	addne	r2, #3
 80a5e92:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80a5e96:	f1c2 0320 	rsb	r3, r2, #32
 80a5e9a:	fa00 fc03 	lsl.w	ip, r0, r3
 80a5e9e:	fa20 f002 	lsr.w	r0, r0, r2
 80a5ea2:	fa01 fe03 	lsl.w	lr, r1, r3
 80a5ea6:	ea40 000e 	orr.w	r0, r0, lr
 80a5eaa:	fa21 f102 	lsr.w	r1, r1, r2
 80a5eae:	4414      	add	r4, r2
 80a5eb0:	e6bd      	b.n	80a5c2e <__adddf3+0xe6>
 80a5eb2:	bf00      	nop

080a5eb4 <__aeabi_dmul>:
 80a5eb4:	b570      	push	{r4, r5, r6, lr}
 80a5eb6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a5eba:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a5ebe:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a5ec2:	bf1d      	ittte	ne
 80a5ec4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a5ec8:	ea94 0f0c 	teqne	r4, ip
 80a5ecc:	ea95 0f0c 	teqne	r5, ip
 80a5ed0:	f000 f8de 	bleq	80a6090 <__aeabi_dmul+0x1dc>
 80a5ed4:	442c      	add	r4, r5
 80a5ed6:	ea81 0603 	eor.w	r6, r1, r3
 80a5eda:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80a5ede:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80a5ee2:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80a5ee6:	bf18      	it	ne
 80a5ee8:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80a5eec:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a5ef0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80a5ef4:	d038      	beq.n	80a5f68 <__aeabi_dmul+0xb4>
 80a5ef6:	fba0 ce02 	umull	ip, lr, r0, r2
 80a5efa:	f04f 0500 	mov.w	r5, #0
 80a5efe:	fbe1 e502 	umlal	lr, r5, r1, r2
 80a5f02:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80a5f06:	fbe0 e503 	umlal	lr, r5, r0, r3
 80a5f0a:	f04f 0600 	mov.w	r6, #0
 80a5f0e:	fbe1 5603 	umlal	r5, r6, r1, r3
 80a5f12:	f09c 0f00 	teq	ip, #0
 80a5f16:	bf18      	it	ne
 80a5f18:	f04e 0e01 	orrne.w	lr, lr, #1
 80a5f1c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80a5f20:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a5f24:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80a5f28:	d204      	bcs.n	80a5f34 <__aeabi_dmul+0x80>
 80a5f2a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80a5f2e:	416d      	adcs	r5, r5
 80a5f30:	eb46 0606 	adc.w	r6, r6, r6
 80a5f34:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80a5f38:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80a5f3c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80a5f40:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80a5f44:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80a5f48:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a5f4c:	bf88      	it	hi
 80a5f4e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a5f52:	d81e      	bhi.n	80a5f92 <__aeabi_dmul+0xde>
 80a5f54:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80a5f58:	bf08      	it	eq
 80a5f5a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80a5f5e:	f150 0000 	adcs.w	r0, r0, #0
 80a5f62:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a5f66:	bd70      	pop	{r4, r5, r6, pc}
 80a5f68:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80a5f6c:	ea46 0101 	orr.w	r1, r6, r1
 80a5f70:	ea40 0002 	orr.w	r0, r0, r2
 80a5f74:	ea81 0103 	eor.w	r1, r1, r3
 80a5f78:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80a5f7c:	bfc2      	ittt	gt
 80a5f7e:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a5f82:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a5f86:	bd70      	popgt	{r4, r5, r6, pc}
 80a5f88:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a5f8c:	f04f 0e00 	mov.w	lr, #0
 80a5f90:	3c01      	subs	r4, #1
 80a5f92:	f300 80ab 	bgt.w	80a60ec <__aeabi_dmul+0x238>
 80a5f96:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80a5f9a:	bfde      	ittt	le
 80a5f9c:	2000      	movle	r0, #0
 80a5f9e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80a5fa2:	bd70      	pople	{r4, r5, r6, pc}
 80a5fa4:	f1c4 0400 	rsb	r4, r4, #0
 80a5fa8:	3c20      	subs	r4, #32
 80a5faa:	da35      	bge.n	80a6018 <__aeabi_dmul+0x164>
 80a5fac:	340c      	adds	r4, #12
 80a5fae:	dc1b      	bgt.n	80a5fe8 <__aeabi_dmul+0x134>
 80a5fb0:	f104 0414 	add.w	r4, r4, #20
 80a5fb4:	f1c4 0520 	rsb	r5, r4, #32
 80a5fb8:	fa00 f305 	lsl.w	r3, r0, r5
 80a5fbc:	fa20 f004 	lsr.w	r0, r0, r4
 80a5fc0:	fa01 f205 	lsl.w	r2, r1, r5
 80a5fc4:	ea40 0002 	orr.w	r0, r0, r2
 80a5fc8:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80a5fcc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a5fd0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a5fd4:	fa21 f604 	lsr.w	r6, r1, r4
 80a5fd8:	eb42 0106 	adc.w	r1, r2, r6
 80a5fdc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a5fe0:	bf08      	it	eq
 80a5fe2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a5fe6:	bd70      	pop	{r4, r5, r6, pc}
 80a5fe8:	f1c4 040c 	rsb	r4, r4, #12
 80a5fec:	f1c4 0520 	rsb	r5, r4, #32
 80a5ff0:	fa00 f304 	lsl.w	r3, r0, r4
 80a5ff4:	fa20 f005 	lsr.w	r0, r0, r5
 80a5ff8:	fa01 f204 	lsl.w	r2, r1, r4
 80a5ffc:	ea40 0002 	orr.w	r0, r0, r2
 80a6000:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a6004:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a6008:	f141 0100 	adc.w	r1, r1, #0
 80a600c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a6010:	bf08      	it	eq
 80a6012:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a6016:	bd70      	pop	{r4, r5, r6, pc}
 80a6018:	f1c4 0520 	rsb	r5, r4, #32
 80a601c:	fa00 f205 	lsl.w	r2, r0, r5
 80a6020:	ea4e 0e02 	orr.w	lr, lr, r2
 80a6024:	fa20 f304 	lsr.w	r3, r0, r4
 80a6028:	fa01 f205 	lsl.w	r2, r1, r5
 80a602c:	ea43 0302 	orr.w	r3, r3, r2
 80a6030:	fa21 f004 	lsr.w	r0, r1, r4
 80a6034:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a6038:	fa21 f204 	lsr.w	r2, r1, r4
 80a603c:	ea20 0002 	bic.w	r0, r0, r2
 80a6040:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80a6044:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a6048:	bf08      	it	eq
 80a604a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a604e:	bd70      	pop	{r4, r5, r6, pc}
 80a6050:	f094 0f00 	teq	r4, #0
 80a6054:	d10f      	bne.n	80a6076 <__aeabi_dmul+0x1c2>
 80a6056:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80a605a:	0040      	lsls	r0, r0, #1
 80a605c:	eb41 0101 	adc.w	r1, r1, r1
 80a6060:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a6064:	bf08      	it	eq
 80a6066:	3c01      	subeq	r4, #1
 80a6068:	d0f7      	beq.n	80a605a <__aeabi_dmul+0x1a6>
 80a606a:	ea41 0106 	orr.w	r1, r1, r6
 80a606e:	f095 0f00 	teq	r5, #0
 80a6072:	bf18      	it	ne
 80a6074:	4770      	bxne	lr
 80a6076:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80a607a:	0052      	lsls	r2, r2, #1
 80a607c:	eb43 0303 	adc.w	r3, r3, r3
 80a6080:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80a6084:	bf08      	it	eq
 80a6086:	3d01      	subeq	r5, #1
 80a6088:	d0f7      	beq.n	80a607a <__aeabi_dmul+0x1c6>
 80a608a:	ea43 0306 	orr.w	r3, r3, r6
 80a608e:	4770      	bx	lr
 80a6090:	ea94 0f0c 	teq	r4, ip
 80a6094:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a6098:	bf18      	it	ne
 80a609a:	ea95 0f0c 	teqne	r5, ip
 80a609e:	d00c      	beq.n	80a60ba <__aeabi_dmul+0x206>
 80a60a0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a60a4:	bf18      	it	ne
 80a60a6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a60aa:	d1d1      	bne.n	80a6050 <__aeabi_dmul+0x19c>
 80a60ac:	ea81 0103 	eor.w	r1, r1, r3
 80a60b0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a60b4:	f04f 0000 	mov.w	r0, #0
 80a60b8:	bd70      	pop	{r4, r5, r6, pc}
 80a60ba:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a60be:	bf06      	itte	eq
 80a60c0:	4610      	moveq	r0, r2
 80a60c2:	4619      	moveq	r1, r3
 80a60c4:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a60c8:	d019      	beq.n	80a60fe <__aeabi_dmul+0x24a>
 80a60ca:	ea94 0f0c 	teq	r4, ip
 80a60ce:	d102      	bne.n	80a60d6 <__aeabi_dmul+0x222>
 80a60d0:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80a60d4:	d113      	bne.n	80a60fe <__aeabi_dmul+0x24a>
 80a60d6:	ea95 0f0c 	teq	r5, ip
 80a60da:	d105      	bne.n	80a60e8 <__aeabi_dmul+0x234>
 80a60dc:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80a60e0:	bf1c      	itt	ne
 80a60e2:	4610      	movne	r0, r2
 80a60e4:	4619      	movne	r1, r3
 80a60e6:	d10a      	bne.n	80a60fe <__aeabi_dmul+0x24a>
 80a60e8:	ea81 0103 	eor.w	r1, r1, r3
 80a60ec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a60f0:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a60f4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a60f8:	f04f 0000 	mov.w	r0, #0
 80a60fc:	bd70      	pop	{r4, r5, r6, pc}
 80a60fe:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a6102:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80a6106:	bd70      	pop	{r4, r5, r6, pc}

080a6108 <__aeabi_ddiv>:
 80a6108:	b570      	push	{r4, r5, r6, lr}
 80a610a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a610e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a6112:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a6116:	bf1d      	ittte	ne
 80a6118:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a611c:	ea94 0f0c 	teqne	r4, ip
 80a6120:	ea95 0f0c 	teqne	r5, ip
 80a6124:	f000 f8a7 	bleq	80a6276 <__aeabi_ddiv+0x16e>
 80a6128:	eba4 0405 	sub.w	r4, r4, r5
 80a612c:	ea81 0e03 	eor.w	lr, r1, r3
 80a6130:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a6134:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a6138:	f000 8088 	beq.w	80a624c <__aeabi_ddiv+0x144>
 80a613c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a6140:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80a6144:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80a6148:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80a614c:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80a6150:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80a6154:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80a6158:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80a615c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80a6160:	429d      	cmp	r5, r3
 80a6162:	bf08      	it	eq
 80a6164:	4296      	cmpeq	r6, r2
 80a6166:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80a616a:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80a616e:	d202      	bcs.n	80a6176 <__aeabi_ddiv+0x6e>
 80a6170:	085b      	lsrs	r3, r3, #1
 80a6172:	ea4f 0232 	mov.w	r2, r2, rrx
 80a6176:	1ab6      	subs	r6, r6, r2
 80a6178:	eb65 0503 	sbc.w	r5, r5, r3
 80a617c:	085b      	lsrs	r3, r3, #1
 80a617e:	ea4f 0232 	mov.w	r2, r2, rrx
 80a6182:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80a6186:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80a618a:	ebb6 0e02 	subs.w	lr, r6, r2
 80a618e:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a6192:	bf22      	ittt	cs
 80a6194:	1ab6      	subcs	r6, r6, r2
 80a6196:	4675      	movcs	r5, lr
 80a6198:	ea40 000c 	orrcs.w	r0, r0, ip
 80a619c:	085b      	lsrs	r3, r3, #1
 80a619e:	ea4f 0232 	mov.w	r2, r2, rrx
 80a61a2:	ebb6 0e02 	subs.w	lr, r6, r2
 80a61a6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a61aa:	bf22      	ittt	cs
 80a61ac:	1ab6      	subcs	r6, r6, r2
 80a61ae:	4675      	movcs	r5, lr
 80a61b0:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a61b4:	085b      	lsrs	r3, r3, #1
 80a61b6:	ea4f 0232 	mov.w	r2, r2, rrx
 80a61ba:	ebb6 0e02 	subs.w	lr, r6, r2
 80a61be:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a61c2:	bf22      	ittt	cs
 80a61c4:	1ab6      	subcs	r6, r6, r2
 80a61c6:	4675      	movcs	r5, lr
 80a61c8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a61cc:	085b      	lsrs	r3, r3, #1
 80a61ce:	ea4f 0232 	mov.w	r2, r2, rrx
 80a61d2:	ebb6 0e02 	subs.w	lr, r6, r2
 80a61d6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a61da:	bf22      	ittt	cs
 80a61dc:	1ab6      	subcs	r6, r6, r2
 80a61de:	4675      	movcs	r5, lr
 80a61e0:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a61e4:	ea55 0e06 	orrs.w	lr, r5, r6
 80a61e8:	d018      	beq.n	80a621c <__aeabi_ddiv+0x114>
 80a61ea:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80a61ee:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80a61f2:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80a61f6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80a61fa:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80a61fe:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80a6202:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80a6206:	d1c0      	bne.n	80a618a <__aeabi_ddiv+0x82>
 80a6208:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a620c:	d10b      	bne.n	80a6226 <__aeabi_ddiv+0x11e>
 80a620e:	ea41 0100 	orr.w	r1, r1, r0
 80a6212:	f04f 0000 	mov.w	r0, #0
 80a6216:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80a621a:	e7b6      	b.n	80a618a <__aeabi_ddiv+0x82>
 80a621c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a6220:	bf04      	itt	eq
 80a6222:	4301      	orreq	r1, r0
 80a6224:	2000      	moveq	r0, #0
 80a6226:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a622a:	bf88      	it	hi
 80a622c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a6230:	f63f aeaf 	bhi.w	80a5f92 <__aeabi_dmul+0xde>
 80a6234:	ebb5 0c03 	subs.w	ip, r5, r3
 80a6238:	bf04      	itt	eq
 80a623a:	ebb6 0c02 	subseq.w	ip, r6, r2
 80a623e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a6242:	f150 0000 	adcs.w	r0, r0, #0
 80a6246:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a624a:	bd70      	pop	{r4, r5, r6, pc}
 80a624c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80a6250:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80a6254:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80a6258:	bfc2      	ittt	gt
 80a625a:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a625e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a6262:	bd70      	popgt	{r4, r5, r6, pc}
 80a6264:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a6268:	f04f 0e00 	mov.w	lr, #0
 80a626c:	3c01      	subs	r4, #1
 80a626e:	e690      	b.n	80a5f92 <__aeabi_dmul+0xde>
 80a6270:	ea45 0e06 	orr.w	lr, r5, r6
 80a6274:	e68d      	b.n	80a5f92 <__aeabi_dmul+0xde>
 80a6276:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a627a:	ea94 0f0c 	teq	r4, ip
 80a627e:	bf08      	it	eq
 80a6280:	ea95 0f0c 	teqeq	r5, ip
 80a6284:	f43f af3b 	beq.w	80a60fe <__aeabi_dmul+0x24a>
 80a6288:	ea94 0f0c 	teq	r4, ip
 80a628c:	d10a      	bne.n	80a62a4 <__aeabi_ddiv+0x19c>
 80a628e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a6292:	f47f af34 	bne.w	80a60fe <__aeabi_dmul+0x24a>
 80a6296:	ea95 0f0c 	teq	r5, ip
 80a629a:	f47f af25 	bne.w	80a60e8 <__aeabi_dmul+0x234>
 80a629e:	4610      	mov	r0, r2
 80a62a0:	4619      	mov	r1, r3
 80a62a2:	e72c      	b.n	80a60fe <__aeabi_dmul+0x24a>
 80a62a4:	ea95 0f0c 	teq	r5, ip
 80a62a8:	d106      	bne.n	80a62b8 <__aeabi_ddiv+0x1b0>
 80a62aa:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a62ae:	f43f aefd 	beq.w	80a60ac <__aeabi_dmul+0x1f8>
 80a62b2:	4610      	mov	r0, r2
 80a62b4:	4619      	mov	r1, r3
 80a62b6:	e722      	b.n	80a60fe <__aeabi_dmul+0x24a>
 80a62b8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a62bc:	bf18      	it	ne
 80a62be:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a62c2:	f47f aec5 	bne.w	80a6050 <__aeabi_dmul+0x19c>
 80a62c6:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80a62ca:	f47f af0d 	bne.w	80a60e8 <__aeabi_dmul+0x234>
 80a62ce:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80a62d2:	f47f aeeb 	bne.w	80a60ac <__aeabi_dmul+0x1f8>
 80a62d6:	e712      	b.n	80a60fe <__aeabi_dmul+0x24a>

080a62d8 <__gedf2>:
 80a62d8:	f04f 3cff 	mov.w	ip, #4294967295
 80a62dc:	e006      	b.n	80a62ec <__cmpdf2+0x4>
 80a62de:	bf00      	nop

080a62e0 <__ledf2>:
 80a62e0:	f04f 0c01 	mov.w	ip, #1
 80a62e4:	e002      	b.n	80a62ec <__cmpdf2+0x4>
 80a62e6:	bf00      	nop

080a62e8 <__cmpdf2>:
 80a62e8:	f04f 0c01 	mov.w	ip, #1
 80a62ec:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a62f0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a62f4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a62f8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a62fc:	bf18      	it	ne
 80a62fe:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80a6302:	d01b      	beq.n	80a633c <__cmpdf2+0x54>
 80a6304:	b001      	add	sp, #4
 80a6306:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80a630a:	bf0c      	ite	eq
 80a630c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80a6310:	ea91 0f03 	teqne	r1, r3
 80a6314:	bf02      	ittt	eq
 80a6316:	ea90 0f02 	teqeq	r0, r2
 80a631a:	2000      	moveq	r0, #0
 80a631c:	4770      	bxeq	lr
 80a631e:	f110 0f00 	cmn.w	r0, #0
 80a6322:	ea91 0f03 	teq	r1, r3
 80a6326:	bf58      	it	pl
 80a6328:	4299      	cmppl	r1, r3
 80a632a:	bf08      	it	eq
 80a632c:	4290      	cmpeq	r0, r2
 80a632e:	bf2c      	ite	cs
 80a6330:	17d8      	asrcs	r0, r3, #31
 80a6332:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80a6336:	f040 0001 	orr.w	r0, r0, #1
 80a633a:	4770      	bx	lr
 80a633c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a6340:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a6344:	d102      	bne.n	80a634c <__cmpdf2+0x64>
 80a6346:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80a634a:	d107      	bne.n	80a635c <__cmpdf2+0x74>
 80a634c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a6350:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a6354:	d1d6      	bne.n	80a6304 <__cmpdf2+0x1c>
 80a6356:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80a635a:	d0d3      	beq.n	80a6304 <__cmpdf2+0x1c>
 80a635c:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a6360:	4770      	bx	lr
 80a6362:	bf00      	nop

080a6364 <__aeabi_cdrcmple>:
 80a6364:	4684      	mov	ip, r0
 80a6366:	4610      	mov	r0, r2
 80a6368:	4662      	mov	r2, ip
 80a636a:	468c      	mov	ip, r1
 80a636c:	4619      	mov	r1, r3
 80a636e:	4663      	mov	r3, ip
 80a6370:	e000      	b.n	80a6374 <__aeabi_cdcmpeq>
 80a6372:	bf00      	nop

080a6374 <__aeabi_cdcmpeq>:
 80a6374:	b501      	push	{r0, lr}
 80a6376:	f7ff ffb7 	bl	80a62e8 <__cmpdf2>
 80a637a:	2800      	cmp	r0, #0
 80a637c:	bf48      	it	mi
 80a637e:	f110 0f00 	cmnmi.w	r0, #0
 80a6382:	bd01      	pop	{r0, pc}

080a6384 <__aeabi_dcmpeq>:
 80a6384:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a6388:	f7ff fff4 	bl	80a6374 <__aeabi_cdcmpeq>
 80a638c:	bf0c      	ite	eq
 80a638e:	2001      	moveq	r0, #1
 80a6390:	2000      	movne	r0, #0
 80a6392:	f85d fb08 	ldr.w	pc, [sp], #8
 80a6396:	bf00      	nop

080a6398 <__aeabi_dcmplt>:
 80a6398:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a639c:	f7ff ffea 	bl	80a6374 <__aeabi_cdcmpeq>
 80a63a0:	bf34      	ite	cc
 80a63a2:	2001      	movcc	r0, #1
 80a63a4:	2000      	movcs	r0, #0
 80a63a6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a63aa:	bf00      	nop

080a63ac <__aeabi_dcmple>:
 80a63ac:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a63b0:	f7ff ffe0 	bl	80a6374 <__aeabi_cdcmpeq>
 80a63b4:	bf94      	ite	ls
 80a63b6:	2001      	movls	r0, #1
 80a63b8:	2000      	movhi	r0, #0
 80a63ba:	f85d fb08 	ldr.w	pc, [sp], #8
 80a63be:	bf00      	nop

080a63c0 <__aeabi_dcmpge>:
 80a63c0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a63c4:	f7ff ffce 	bl	80a6364 <__aeabi_cdrcmple>
 80a63c8:	bf94      	ite	ls
 80a63ca:	2001      	movls	r0, #1
 80a63cc:	2000      	movhi	r0, #0
 80a63ce:	f85d fb08 	ldr.w	pc, [sp], #8
 80a63d2:	bf00      	nop

080a63d4 <__aeabi_dcmpgt>:
 80a63d4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a63d8:	f7ff ffc4 	bl	80a6364 <__aeabi_cdrcmple>
 80a63dc:	bf34      	ite	cc
 80a63de:	2001      	movcc	r0, #1
 80a63e0:	2000      	movcs	r0, #0
 80a63e2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a63e6:	bf00      	nop

080a63e8 <__aeabi_dcmpun>:
 80a63e8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a63ec:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a63f0:	d102      	bne.n	80a63f8 <__aeabi_dcmpun+0x10>
 80a63f2:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80a63f6:	d10a      	bne.n	80a640e <__aeabi_dcmpun+0x26>
 80a63f8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a63fc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a6400:	d102      	bne.n	80a6408 <__aeabi_dcmpun+0x20>
 80a6402:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80a6406:	d102      	bne.n	80a640e <__aeabi_dcmpun+0x26>
 80a6408:	f04f 0000 	mov.w	r0, #0
 80a640c:	4770      	bx	lr
 80a640e:	f04f 0001 	mov.w	r0, #1
 80a6412:	4770      	bx	lr

080a6414 <__aeabi_d2iz>:
 80a6414:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a6418:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a641c:	d215      	bcs.n	80a644a <__aeabi_d2iz+0x36>
 80a641e:	d511      	bpl.n	80a6444 <__aeabi_d2iz+0x30>
 80a6420:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a6424:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a6428:	d912      	bls.n	80a6450 <__aeabi_d2iz+0x3c>
 80a642a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a642e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a6432:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a6436:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a643a:	fa23 f002 	lsr.w	r0, r3, r2
 80a643e:	bf18      	it	ne
 80a6440:	4240      	negne	r0, r0
 80a6442:	4770      	bx	lr
 80a6444:	f04f 0000 	mov.w	r0, #0
 80a6448:	4770      	bx	lr
 80a644a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a644e:	d105      	bne.n	80a645c <__aeabi_d2iz+0x48>
 80a6450:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80a6454:	bf08      	it	eq
 80a6456:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a645a:	4770      	bx	lr
 80a645c:	f04f 0000 	mov.w	r0, #0
 80a6460:	4770      	bx	lr
 80a6462:	bf00      	nop

080a6464 <__aeabi_d2uiz>:
 80a6464:	004a      	lsls	r2, r1, #1
 80a6466:	d211      	bcs.n	80a648c <__aeabi_d2uiz+0x28>
 80a6468:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a646c:	d211      	bcs.n	80a6492 <__aeabi_d2uiz+0x2e>
 80a646e:	d50d      	bpl.n	80a648c <__aeabi_d2uiz+0x28>
 80a6470:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a6474:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a6478:	d40e      	bmi.n	80a6498 <__aeabi_d2uiz+0x34>
 80a647a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a647e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a6482:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a6486:	fa23 f002 	lsr.w	r0, r3, r2
 80a648a:	4770      	bx	lr
 80a648c:	f04f 0000 	mov.w	r0, #0
 80a6490:	4770      	bx	lr
 80a6492:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a6496:	d102      	bne.n	80a649e <__aeabi_d2uiz+0x3a>
 80a6498:	f04f 30ff 	mov.w	r0, #4294967295
 80a649c:	4770      	bx	lr
 80a649e:	f04f 0000 	mov.w	r0, #0
 80a64a2:	4770      	bx	lr

080a64a4 <__aeabi_d2f>:
 80a64a4:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a64a8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80a64ac:	bf24      	itt	cs
 80a64ae:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80a64b2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80a64b6:	d90d      	bls.n	80a64d4 <__aeabi_d2f+0x30>
 80a64b8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a64bc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80a64c0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80a64c4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80a64c8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80a64cc:	bf08      	it	eq
 80a64ce:	f020 0001 	biceq.w	r0, r0, #1
 80a64d2:	4770      	bx	lr
 80a64d4:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80a64d8:	d121      	bne.n	80a651e <__aeabi_d2f+0x7a>
 80a64da:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80a64de:	bfbc      	itt	lt
 80a64e0:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 80a64e4:	4770      	bxlt	lr
 80a64e6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a64ea:	ea4f 5252 	mov.w	r2, r2, lsr #21
 80a64ee:	f1c2 0218 	rsb	r2, r2, #24
 80a64f2:	f1c2 0c20 	rsb	ip, r2, #32
 80a64f6:	fa10 f30c 	lsls.w	r3, r0, ip
 80a64fa:	fa20 f002 	lsr.w	r0, r0, r2
 80a64fe:	bf18      	it	ne
 80a6500:	f040 0001 	orrne.w	r0, r0, #1
 80a6504:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a6508:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 80a650c:	fa03 fc0c 	lsl.w	ip, r3, ip
 80a6510:	ea40 000c 	orr.w	r0, r0, ip
 80a6514:	fa23 f302 	lsr.w	r3, r3, r2
 80a6518:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80a651c:	e7cc      	b.n	80a64b8 <__aeabi_d2f+0x14>
 80a651e:	ea7f 5362 	mvns.w	r3, r2, asr #21
 80a6522:	d107      	bne.n	80a6534 <__aeabi_d2f+0x90>
 80a6524:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 80a6528:	bf1e      	ittt	ne
 80a652a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 80a652e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 80a6532:	4770      	bxne	lr
 80a6534:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 80a6538:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a653c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a6540:	4770      	bx	lr
 80a6542:	bf00      	nop

080a6544 <__aeabi_frsub>:
 80a6544:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80a6548:	e002      	b.n	80a6550 <__addsf3>
 80a654a:	bf00      	nop

080a654c <__aeabi_fsub>:
 80a654c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080a6550 <__addsf3>:
 80a6550:	0042      	lsls	r2, r0, #1
 80a6552:	bf1f      	itttt	ne
 80a6554:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80a6558:	ea92 0f03 	teqne	r2, r3
 80a655c:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80a6560:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a6564:	d06a      	beq.n	80a663c <__addsf3+0xec>
 80a6566:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80a656a:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80a656e:	bfc1      	itttt	gt
 80a6570:	18d2      	addgt	r2, r2, r3
 80a6572:	4041      	eorgt	r1, r0
 80a6574:	4048      	eorgt	r0, r1
 80a6576:	4041      	eorgt	r1, r0
 80a6578:	bfb8      	it	lt
 80a657a:	425b      	neglt	r3, r3
 80a657c:	2b19      	cmp	r3, #25
 80a657e:	bf88      	it	hi
 80a6580:	4770      	bxhi	lr
 80a6582:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a6586:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a658a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80a658e:	bf18      	it	ne
 80a6590:	4240      	negne	r0, r0
 80a6592:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a6596:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80a659a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80a659e:	bf18      	it	ne
 80a65a0:	4249      	negne	r1, r1
 80a65a2:	ea92 0f03 	teq	r2, r3
 80a65a6:	d03f      	beq.n	80a6628 <__addsf3+0xd8>
 80a65a8:	f1a2 0201 	sub.w	r2, r2, #1
 80a65ac:	fa41 fc03 	asr.w	ip, r1, r3
 80a65b0:	eb10 000c 	adds.w	r0, r0, ip
 80a65b4:	f1c3 0320 	rsb	r3, r3, #32
 80a65b8:	fa01 f103 	lsl.w	r1, r1, r3
 80a65bc:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a65c0:	d502      	bpl.n	80a65c8 <__addsf3+0x78>
 80a65c2:	4249      	negs	r1, r1
 80a65c4:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80a65c8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80a65cc:	d313      	bcc.n	80a65f6 <__addsf3+0xa6>
 80a65ce:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80a65d2:	d306      	bcc.n	80a65e2 <__addsf3+0x92>
 80a65d4:	0840      	lsrs	r0, r0, #1
 80a65d6:	ea4f 0131 	mov.w	r1, r1, rrx
 80a65da:	f102 0201 	add.w	r2, r2, #1
 80a65de:	2afe      	cmp	r2, #254	; 0xfe
 80a65e0:	d251      	bcs.n	80a6686 <__addsf3+0x136>
 80a65e2:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80a65e6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a65ea:	bf08      	it	eq
 80a65ec:	f020 0001 	biceq.w	r0, r0, #1
 80a65f0:	ea40 0003 	orr.w	r0, r0, r3
 80a65f4:	4770      	bx	lr
 80a65f6:	0049      	lsls	r1, r1, #1
 80a65f8:	eb40 0000 	adc.w	r0, r0, r0
 80a65fc:	3a01      	subs	r2, #1
 80a65fe:	bf28      	it	cs
 80a6600:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 80a6604:	d2ed      	bcs.n	80a65e2 <__addsf3+0x92>
 80a6606:	fab0 fc80 	clz	ip, r0
 80a660a:	f1ac 0c08 	sub.w	ip, ip, #8
 80a660e:	ebb2 020c 	subs.w	r2, r2, ip
 80a6612:	fa00 f00c 	lsl.w	r0, r0, ip
 80a6616:	bfaa      	itet	ge
 80a6618:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80a661c:	4252      	neglt	r2, r2
 80a661e:	4318      	orrge	r0, r3
 80a6620:	bfbc      	itt	lt
 80a6622:	40d0      	lsrlt	r0, r2
 80a6624:	4318      	orrlt	r0, r3
 80a6626:	4770      	bx	lr
 80a6628:	f092 0f00 	teq	r2, #0
 80a662c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80a6630:	bf06      	itte	eq
 80a6632:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80a6636:	3201      	addeq	r2, #1
 80a6638:	3b01      	subne	r3, #1
 80a663a:	e7b5      	b.n	80a65a8 <__addsf3+0x58>
 80a663c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a6640:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a6644:	bf18      	it	ne
 80a6646:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a664a:	d021      	beq.n	80a6690 <__addsf3+0x140>
 80a664c:	ea92 0f03 	teq	r2, r3
 80a6650:	d004      	beq.n	80a665c <__addsf3+0x10c>
 80a6652:	f092 0f00 	teq	r2, #0
 80a6656:	bf08      	it	eq
 80a6658:	4608      	moveq	r0, r1
 80a665a:	4770      	bx	lr
 80a665c:	ea90 0f01 	teq	r0, r1
 80a6660:	bf1c      	itt	ne
 80a6662:	2000      	movne	r0, #0
 80a6664:	4770      	bxne	lr
 80a6666:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80a666a:	d104      	bne.n	80a6676 <__addsf3+0x126>
 80a666c:	0040      	lsls	r0, r0, #1
 80a666e:	bf28      	it	cs
 80a6670:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80a6674:	4770      	bx	lr
 80a6676:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80a667a:	bf3c      	itt	cc
 80a667c:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80a6680:	4770      	bxcc	lr
 80a6682:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a6686:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80a668a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a668e:	4770      	bx	lr
 80a6690:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80a6694:	bf16      	itet	ne
 80a6696:	4608      	movne	r0, r1
 80a6698:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80a669c:	4601      	movne	r1, r0
 80a669e:	0242      	lsls	r2, r0, #9
 80a66a0:	bf06      	itte	eq
 80a66a2:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80a66a6:	ea90 0f01 	teqeq	r0, r1
 80a66aa:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80a66ae:	4770      	bx	lr

080a66b0 <__aeabi_ui2f>:
 80a66b0:	f04f 0300 	mov.w	r3, #0
 80a66b4:	e004      	b.n	80a66c0 <__aeabi_i2f+0x8>
 80a66b6:	bf00      	nop

080a66b8 <__aeabi_i2f>:
 80a66b8:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80a66bc:	bf48      	it	mi
 80a66be:	4240      	negmi	r0, r0
 80a66c0:	ea5f 0c00 	movs.w	ip, r0
 80a66c4:	bf08      	it	eq
 80a66c6:	4770      	bxeq	lr
 80a66c8:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 80a66cc:	4601      	mov	r1, r0
 80a66ce:	f04f 0000 	mov.w	r0, #0
 80a66d2:	e01c      	b.n	80a670e <__aeabi_l2f+0x2a>

080a66d4 <__aeabi_ul2f>:
 80a66d4:	ea50 0201 	orrs.w	r2, r0, r1
 80a66d8:	bf08      	it	eq
 80a66da:	4770      	bxeq	lr
 80a66dc:	f04f 0300 	mov.w	r3, #0
 80a66e0:	e00a      	b.n	80a66f8 <__aeabi_l2f+0x14>
 80a66e2:	bf00      	nop

080a66e4 <__aeabi_l2f>:
 80a66e4:	ea50 0201 	orrs.w	r2, r0, r1
 80a66e8:	bf08      	it	eq
 80a66ea:	4770      	bxeq	lr
 80a66ec:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80a66f0:	d502      	bpl.n	80a66f8 <__aeabi_l2f+0x14>
 80a66f2:	4240      	negs	r0, r0
 80a66f4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a66f8:	ea5f 0c01 	movs.w	ip, r1
 80a66fc:	bf02      	ittt	eq
 80a66fe:	4684      	moveq	ip, r0
 80a6700:	4601      	moveq	r1, r0
 80a6702:	2000      	moveq	r0, #0
 80a6704:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80a6708:	bf08      	it	eq
 80a670a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80a670e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80a6712:	fabc f28c 	clz	r2, ip
 80a6716:	3a08      	subs	r2, #8
 80a6718:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80a671c:	db10      	blt.n	80a6740 <__aeabi_l2f+0x5c>
 80a671e:	fa01 fc02 	lsl.w	ip, r1, r2
 80a6722:	4463      	add	r3, ip
 80a6724:	fa00 fc02 	lsl.w	ip, r0, r2
 80a6728:	f1c2 0220 	rsb	r2, r2, #32
 80a672c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a6730:	fa20 f202 	lsr.w	r2, r0, r2
 80a6734:	eb43 0002 	adc.w	r0, r3, r2
 80a6738:	bf08      	it	eq
 80a673a:	f020 0001 	biceq.w	r0, r0, #1
 80a673e:	4770      	bx	lr
 80a6740:	f102 0220 	add.w	r2, r2, #32
 80a6744:	fa01 fc02 	lsl.w	ip, r1, r2
 80a6748:	f1c2 0220 	rsb	r2, r2, #32
 80a674c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80a6750:	fa21 f202 	lsr.w	r2, r1, r2
 80a6754:	eb43 0002 	adc.w	r0, r3, r2
 80a6758:	bf08      	it	eq
 80a675a:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a675e:	4770      	bx	lr

080a6760 <__aeabi_fmul>:
 80a6760:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a6764:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a6768:	bf1e      	ittt	ne
 80a676a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a676e:	ea92 0f0c 	teqne	r2, ip
 80a6772:	ea93 0f0c 	teqne	r3, ip
 80a6776:	d06f      	beq.n	80a6858 <__aeabi_fmul+0xf8>
 80a6778:	441a      	add	r2, r3
 80a677a:	ea80 0c01 	eor.w	ip, r0, r1
 80a677e:	0240      	lsls	r0, r0, #9
 80a6780:	bf18      	it	ne
 80a6782:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80a6786:	d01e      	beq.n	80a67c6 <__aeabi_fmul+0x66>
 80a6788:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80a678c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80a6790:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80a6794:	fba0 3101 	umull	r3, r1, r0, r1
 80a6798:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a679c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80a67a0:	bf3e      	ittt	cc
 80a67a2:	0049      	lslcc	r1, r1, #1
 80a67a4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80a67a8:	005b      	lslcc	r3, r3, #1
 80a67aa:	ea40 0001 	orr.w	r0, r0, r1
 80a67ae:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80a67b2:	2afd      	cmp	r2, #253	; 0xfd
 80a67b4:	d81d      	bhi.n	80a67f2 <__aeabi_fmul+0x92>
 80a67b6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a67ba:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a67be:	bf08      	it	eq
 80a67c0:	f020 0001 	biceq.w	r0, r0, #1
 80a67c4:	4770      	bx	lr
 80a67c6:	f090 0f00 	teq	r0, #0
 80a67ca:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a67ce:	bf08      	it	eq
 80a67d0:	0249      	lsleq	r1, r1, #9
 80a67d2:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a67d6:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80a67da:	3a7f      	subs	r2, #127	; 0x7f
 80a67dc:	bfc2      	ittt	gt
 80a67de:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a67e2:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a67e6:	4770      	bxgt	lr
 80a67e8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a67ec:	f04f 0300 	mov.w	r3, #0
 80a67f0:	3a01      	subs	r2, #1
 80a67f2:	dc5d      	bgt.n	80a68b0 <__aeabi_fmul+0x150>
 80a67f4:	f112 0f19 	cmn.w	r2, #25
 80a67f8:	bfdc      	itt	le
 80a67fa:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80a67fe:	4770      	bxle	lr
 80a6800:	f1c2 0200 	rsb	r2, r2, #0
 80a6804:	0041      	lsls	r1, r0, #1
 80a6806:	fa21 f102 	lsr.w	r1, r1, r2
 80a680a:	f1c2 0220 	rsb	r2, r2, #32
 80a680e:	fa00 fc02 	lsl.w	ip, r0, r2
 80a6812:	ea5f 0031 	movs.w	r0, r1, rrx
 80a6816:	f140 0000 	adc.w	r0, r0, #0
 80a681a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80a681e:	bf08      	it	eq
 80a6820:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a6824:	4770      	bx	lr
 80a6826:	f092 0f00 	teq	r2, #0
 80a682a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a682e:	bf02      	ittt	eq
 80a6830:	0040      	lsleq	r0, r0, #1
 80a6832:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a6836:	3a01      	subeq	r2, #1
 80a6838:	d0f9      	beq.n	80a682e <__aeabi_fmul+0xce>
 80a683a:	ea40 000c 	orr.w	r0, r0, ip
 80a683e:	f093 0f00 	teq	r3, #0
 80a6842:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a6846:	bf02      	ittt	eq
 80a6848:	0049      	lsleq	r1, r1, #1
 80a684a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a684e:	3b01      	subeq	r3, #1
 80a6850:	d0f9      	beq.n	80a6846 <__aeabi_fmul+0xe6>
 80a6852:	ea41 010c 	orr.w	r1, r1, ip
 80a6856:	e78f      	b.n	80a6778 <__aeabi_fmul+0x18>
 80a6858:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a685c:	ea92 0f0c 	teq	r2, ip
 80a6860:	bf18      	it	ne
 80a6862:	ea93 0f0c 	teqne	r3, ip
 80a6866:	d00a      	beq.n	80a687e <__aeabi_fmul+0x11e>
 80a6868:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a686c:	bf18      	it	ne
 80a686e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a6872:	d1d8      	bne.n	80a6826 <__aeabi_fmul+0xc6>
 80a6874:	ea80 0001 	eor.w	r0, r0, r1
 80a6878:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a687c:	4770      	bx	lr
 80a687e:	f090 0f00 	teq	r0, #0
 80a6882:	bf17      	itett	ne
 80a6884:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80a6888:	4608      	moveq	r0, r1
 80a688a:	f091 0f00 	teqne	r1, #0
 80a688e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80a6892:	d014      	beq.n	80a68be <__aeabi_fmul+0x15e>
 80a6894:	ea92 0f0c 	teq	r2, ip
 80a6898:	d101      	bne.n	80a689e <__aeabi_fmul+0x13e>
 80a689a:	0242      	lsls	r2, r0, #9
 80a689c:	d10f      	bne.n	80a68be <__aeabi_fmul+0x15e>
 80a689e:	ea93 0f0c 	teq	r3, ip
 80a68a2:	d103      	bne.n	80a68ac <__aeabi_fmul+0x14c>
 80a68a4:	024b      	lsls	r3, r1, #9
 80a68a6:	bf18      	it	ne
 80a68a8:	4608      	movne	r0, r1
 80a68aa:	d108      	bne.n	80a68be <__aeabi_fmul+0x15e>
 80a68ac:	ea80 0001 	eor.w	r0, r0, r1
 80a68b0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a68b4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a68b8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a68bc:	4770      	bx	lr
 80a68be:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a68c2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80a68c6:	4770      	bx	lr

080a68c8 <__aeabi_fdiv>:
 80a68c8:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a68cc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a68d0:	bf1e      	ittt	ne
 80a68d2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a68d6:	ea92 0f0c 	teqne	r2, ip
 80a68da:	ea93 0f0c 	teqne	r3, ip
 80a68de:	d069      	beq.n	80a69b4 <__aeabi_fdiv+0xec>
 80a68e0:	eba2 0203 	sub.w	r2, r2, r3
 80a68e4:	ea80 0c01 	eor.w	ip, r0, r1
 80a68e8:	0249      	lsls	r1, r1, #9
 80a68ea:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80a68ee:	d037      	beq.n	80a6960 <__aeabi_fdiv+0x98>
 80a68f0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80a68f4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80a68f8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80a68fc:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a6900:	428b      	cmp	r3, r1
 80a6902:	bf38      	it	cc
 80a6904:	005b      	lslcc	r3, r3, #1
 80a6906:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80a690a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80a690e:	428b      	cmp	r3, r1
 80a6910:	bf24      	itt	cs
 80a6912:	1a5b      	subcs	r3, r3, r1
 80a6914:	ea40 000c 	orrcs.w	r0, r0, ip
 80a6918:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80a691c:	bf24      	itt	cs
 80a691e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80a6922:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a6926:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80a692a:	bf24      	itt	cs
 80a692c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80a6930:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a6934:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80a6938:	bf24      	itt	cs
 80a693a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80a693e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a6942:	011b      	lsls	r3, r3, #4
 80a6944:	bf18      	it	ne
 80a6946:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80a694a:	d1e0      	bne.n	80a690e <__aeabi_fdiv+0x46>
 80a694c:	2afd      	cmp	r2, #253	; 0xfd
 80a694e:	f63f af50 	bhi.w	80a67f2 <__aeabi_fmul+0x92>
 80a6952:	428b      	cmp	r3, r1
 80a6954:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a6958:	bf08      	it	eq
 80a695a:	f020 0001 	biceq.w	r0, r0, #1
 80a695e:	4770      	bx	lr
 80a6960:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a6964:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a6968:	327f      	adds	r2, #127	; 0x7f
 80a696a:	bfc2      	ittt	gt
 80a696c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a6970:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a6974:	4770      	bxgt	lr
 80a6976:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a697a:	f04f 0300 	mov.w	r3, #0
 80a697e:	3a01      	subs	r2, #1
 80a6980:	e737      	b.n	80a67f2 <__aeabi_fmul+0x92>
 80a6982:	f092 0f00 	teq	r2, #0
 80a6986:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a698a:	bf02      	ittt	eq
 80a698c:	0040      	lsleq	r0, r0, #1
 80a698e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a6992:	3a01      	subeq	r2, #1
 80a6994:	d0f9      	beq.n	80a698a <__aeabi_fdiv+0xc2>
 80a6996:	ea40 000c 	orr.w	r0, r0, ip
 80a699a:	f093 0f00 	teq	r3, #0
 80a699e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a69a2:	bf02      	ittt	eq
 80a69a4:	0049      	lsleq	r1, r1, #1
 80a69a6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a69aa:	3b01      	subeq	r3, #1
 80a69ac:	d0f9      	beq.n	80a69a2 <__aeabi_fdiv+0xda>
 80a69ae:	ea41 010c 	orr.w	r1, r1, ip
 80a69b2:	e795      	b.n	80a68e0 <__aeabi_fdiv+0x18>
 80a69b4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a69b8:	ea92 0f0c 	teq	r2, ip
 80a69bc:	d108      	bne.n	80a69d0 <__aeabi_fdiv+0x108>
 80a69be:	0242      	lsls	r2, r0, #9
 80a69c0:	f47f af7d 	bne.w	80a68be <__aeabi_fmul+0x15e>
 80a69c4:	ea93 0f0c 	teq	r3, ip
 80a69c8:	f47f af70 	bne.w	80a68ac <__aeabi_fmul+0x14c>
 80a69cc:	4608      	mov	r0, r1
 80a69ce:	e776      	b.n	80a68be <__aeabi_fmul+0x15e>
 80a69d0:	ea93 0f0c 	teq	r3, ip
 80a69d4:	d104      	bne.n	80a69e0 <__aeabi_fdiv+0x118>
 80a69d6:	024b      	lsls	r3, r1, #9
 80a69d8:	f43f af4c 	beq.w	80a6874 <__aeabi_fmul+0x114>
 80a69dc:	4608      	mov	r0, r1
 80a69de:	e76e      	b.n	80a68be <__aeabi_fmul+0x15e>
 80a69e0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a69e4:	bf18      	it	ne
 80a69e6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a69ea:	d1ca      	bne.n	80a6982 <__aeabi_fdiv+0xba>
 80a69ec:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80a69f0:	f47f af5c 	bne.w	80a68ac <__aeabi_fmul+0x14c>
 80a69f4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80a69f8:	f47f af3c 	bne.w	80a6874 <__aeabi_fmul+0x114>
 80a69fc:	e75f      	b.n	80a68be <__aeabi_fmul+0x15e>
 80a69fe:	bf00      	nop

080a6a00 <__gesf2>:
 80a6a00:	f04f 3cff 	mov.w	ip, #4294967295
 80a6a04:	e006      	b.n	80a6a14 <__cmpsf2+0x4>
 80a6a06:	bf00      	nop

080a6a08 <__lesf2>:
 80a6a08:	f04f 0c01 	mov.w	ip, #1
 80a6a0c:	e002      	b.n	80a6a14 <__cmpsf2+0x4>
 80a6a0e:	bf00      	nop

080a6a10 <__cmpsf2>:
 80a6a10:	f04f 0c01 	mov.w	ip, #1
 80a6a14:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a6a18:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a6a1c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a6a20:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a6a24:	bf18      	it	ne
 80a6a26:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a6a2a:	d011      	beq.n	80a6a50 <__cmpsf2+0x40>
 80a6a2c:	b001      	add	sp, #4
 80a6a2e:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 80a6a32:	bf18      	it	ne
 80a6a34:	ea90 0f01 	teqne	r0, r1
 80a6a38:	bf58      	it	pl
 80a6a3a:	ebb2 0003 	subspl.w	r0, r2, r3
 80a6a3e:	bf88      	it	hi
 80a6a40:	17c8      	asrhi	r0, r1, #31
 80a6a42:	bf38      	it	cc
 80a6a44:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 80a6a48:	bf18      	it	ne
 80a6a4a:	f040 0001 	orrne.w	r0, r0, #1
 80a6a4e:	4770      	bx	lr
 80a6a50:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a6a54:	d102      	bne.n	80a6a5c <__cmpsf2+0x4c>
 80a6a56:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80a6a5a:	d105      	bne.n	80a6a68 <__cmpsf2+0x58>
 80a6a5c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80a6a60:	d1e4      	bne.n	80a6a2c <__cmpsf2+0x1c>
 80a6a62:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80a6a66:	d0e1      	beq.n	80a6a2c <__cmpsf2+0x1c>
 80a6a68:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a6a6c:	4770      	bx	lr
 80a6a6e:	bf00      	nop

080a6a70 <__aeabi_cfrcmple>:
 80a6a70:	4684      	mov	ip, r0
 80a6a72:	4608      	mov	r0, r1
 80a6a74:	4661      	mov	r1, ip
 80a6a76:	e7ff      	b.n	80a6a78 <__aeabi_cfcmpeq>

080a6a78 <__aeabi_cfcmpeq>:
 80a6a78:	b50f      	push	{r0, r1, r2, r3, lr}
 80a6a7a:	f7ff ffc9 	bl	80a6a10 <__cmpsf2>
 80a6a7e:	2800      	cmp	r0, #0
 80a6a80:	bf48      	it	mi
 80a6a82:	f110 0f00 	cmnmi.w	r0, #0
 80a6a86:	bd0f      	pop	{r0, r1, r2, r3, pc}

080a6a88 <__aeabi_fcmpeq>:
 80a6a88:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a6a8c:	f7ff fff4 	bl	80a6a78 <__aeabi_cfcmpeq>
 80a6a90:	bf0c      	ite	eq
 80a6a92:	2001      	moveq	r0, #1
 80a6a94:	2000      	movne	r0, #0
 80a6a96:	f85d fb08 	ldr.w	pc, [sp], #8
 80a6a9a:	bf00      	nop

080a6a9c <__aeabi_fcmplt>:
 80a6a9c:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a6aa0:	f7ff ffea 	bl	80a6a78 <__aeabi_cfcmpeq>
 80a6aa4:	bf34      	ite	cc
 80a6aa6:	2001      	movcc	r0, #1
 80a6aa8:	2000      	movcs	r0, #0
 80a6aaa:	f85d fb08 	ldr.w	pc, [sp], #8
 80a6aae:	bf00      	nop

080a6ab0 <__aeabi_fcmple>:
 80a6ab0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a6ab4:	f7ff ffe0 	bl	80a6a78 <__aeabi_cfcmpeq>
 80a6ab8:	bf94      	ite	ls
 80a6aba:	2001      	movls	r0, #1
 80a6abc:	2000      	movhi	r0, #0
 80a6abe:	f85d fb08 	ldr.w	pc, [sp], #8
 80a6ac2:	bf00      	nop

080a6ac4 <__aeabi_fcmpge>:
 80a6ac4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a6ac8:	f7ff ffd2 	bl	80a6a70 <__aeabi_cfrcmple>
 80a6acc:	bf94      	ite	ls
 80a6ace:	2001      	movls	r0, #1
 80a6ad0:	2000      	movhi	r0, #0
 80a6ad2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a6ad6:	bf00      	nop

080a6ad8 <__aeabi_fcmpgt>:
 80a6ad8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a6adc:	f7ff ffc8 	bl	80a6a70 <__aeabi_cfrcmple>
 80a6ae0:	bf34      	ite	cc
 80a6ae2:	2001      	movcc	r0, #1
 80a6ae4:	2000      	movcs	r0, #0
 80a6ae6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a6aea:	bf00      	nop

080a6aec <__aeabi_f2iz>:
 80a6aec:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a6af0:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80a6af4:	d30f      	bcc.n	80a6b16 <__aeabi_f2iz+0x2a>
 80a6af6:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80a6afa:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80a6afe:	d90d      	bls.n	80a6b1c <__aeabi_f2iz+0x30>
 80a6b00:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80a6b04:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a6b08:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a6b0c:	fa23 f002 	lsr.w	r0, r3, r2
 80a6b10:	bf18      	it	ne
 80a6b12:	4240      	negne	r0, r0
 80a6b14:	4770      	bx	lr
 80a6b16:	f04f 0000 	mov.w	r0, #0
 80a6b1a:	4770      	bx	lr
 80a6b1c:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80a6b20:	d101      	bne.n	80a6b26 <__aeabi_f2iz+0x3a>
 80a6b22:	0242      	lsls	r2, r0, #9
 80a6b24:	d105      	bne.n	80a6b32 <__aeabi_f2iz+0x46>
 80a6b26:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 80a6b2a:	bf08      	it	eq
 80a6b2c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a6b30:	4770      	bx	lr
 80a6b32:	f04f 0000 	mov.w	r0, #0
 80a6b36:	4770      	bx	lr

080a6b38 <__aeabi_f2uiz>:
 80a6b38:	0042      	lsls	r2, r0, #1
 80a6b3a:	d20e      	bcs.n	80a6b5a <__aeabi_f2uiz+0x22>
 80a6b3c:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80a6b40:	d30b      	bcc.n	80a6b5a <__aeabi_f2uiz+0x22>
 80a6b42:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80a6b46:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80a6b4a:	d409      	bmi.n	80a6b60 <__aeabi_f2uiz+0x28>
 80a6b4c:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80a6b50:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a6b54:	fa23 f002 	lsr.w	r0, r3, r2
 80a6b58:	4770      	bx	lr
 80a6b5a:	f04f 0000 	mov.w	r0, #0
 80a6b5e:	4770      	bx	lr
 80a6b60:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80a6b64:	d101      	bne.n	80a6b6a <__aeabi_f2uiz+0x32>
 80a6b66:	0242      	lsls	r2, r0, #9
 80a6b68:	d102      	bne.n	80a6b70 <__aeabi_f2uiz+0x38>
 80a6b6a:	f04f 30ff 	mov.w	r0, #4294967295
 80a6b6e:	4770      	bx	lr
 80a6b70:	f04f 0000 	mov.w	r0, #0
 80a6b74:	4770      	bx	lr
 80a6b76:	bf00      	nop

080a6b78 <atoi>:
 80a6b78:	220a      	movs	r2, #10
 80a6b7a:	2100      	movs	r1, #0
 80a6b7c:	f000 b914 	b.w	80a6da8 <strtol>

080a6b80 <atol>:
 80a6b80:	220a      	movs	r2, #10
 80a6b82:	2100      	movs	r1, #0
 80a6b84:	f000 b910 	b.w	80a6da8 <strtol>

080a6b88 <__cxa_atexit>:
 80a6b88:	b510      	push	{r4, lr}
 80a6b8a:	4604      	mov	r4, r0
 80a6b8c:	4804      	ldr	r0, [pc, #16]	; (80a6ba0 <__cxa_atexit+0x18>)
 80a6b8e:	4613      	mov	r3, r2
 80a6b90:	b120      	cbz	r0, 80a6b9c <__cxa_atexit+0x14>
 80a6b92:	460a      	mov	r2, r1
 80a6b94:	2002      	movs	r0, #2
 80a6b96:	4621      	mov	r1, r4
 80a6b98:	f3af 8000 	nop.w
 80a6b9c:	bd10      	pop	{r4, pc}
 80a6b9e:	bf00      	nop
 80a6ba0:	00000000 	.word	0x00000000

080a6ba4 <memcpy>:
 80a6ba4:	440a      	add	r2, r1
 80a6ba6:	4291      	cmp	r1, r2
 80a6ba8:	f100 33ff 	add.w	r3, r0, #4294967295
 80a6bac:	d100      	bne.n	80a6bb0 <memcpy+0xc>
 80a6bae:	4770      	bx	lr
 80a6bb0:	b510      	push	{r4, lr}
 80a6bb2:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a6bb6:	4291      	cmp	r1, r2
 80a6bb8:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a6bbc:	d1f9      	bne.n	80a6bb2 <memcpy+0xe>
 80a6bbe:	bd10      	pop	{r4, pc}

080a6bc0 <memset>:
 80a6bc0:	4603      	mov	r3, r0
 80a6bc2:	4402      	add	r2, r0
 80a6bc4:	4293      	cmp	r3, r2
 80a6bc6:	d100      	bne.n	80a6bca <memset+0xa>
 80a6bc8:	4770      	bx	lr
 80a6bca:	f803 1b01 	strb.w	r1, [r3], #1
 80a6bce:	e7f9      	b.n	80a6bc4 <memset+0x4>

080a6bd0 <srand>:
 80a6bd0:	b538      	push	{r3, r4, r5, lr}
 80a6bd2:	4b10      	ldr	r3, [pc, #64]	; (80a6c14 <srand+0x44>)
 80a6bd4:	4604      	mov	r4, r0
 80a6bd6:	681d      	ldr	r5, [r3, #0]
 80a6bd8:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80a6bda:	b9b3      	cbnz	r3, 80a6c0a <srand+0x3a>
 80a6bdc:	2018      	movs	r0, #24
 80a6bde:	f7fc fa67 	bl	80a30b0 <malloc>
 80a6be2:	4602      	mov	r2, r0
 80a6be4:	63a8      	str	r0, [r5, #56]	; 0x38
 80a6be6:	b920      	cbnz	r0, 80a6bf2 <srand+0x22>
 80a6be8:	2142      	movs	r1, #66	; 0x42
 80a6bea:	4b0b      	ldr	r3, [pc, #44]	; (80a6c18 <srand+0x48>)
 80a6bec:	480b      	ldr	r0, [pc, #44]	; (80a6c1c <srand+0x4c>)
 80a6bee:	f7fc fa9f 	bl	80a3130 <__assert_func>
 80a6bf2:	490b      	ldr	r1, [pc, #44]	; (80a6c20 <srand+0x50>)
 80a6bf4:	4b0b      	ldr	r3, [pc, #44]	; (80a6c24 <srand+0x54>)
 80a6bf6:	e9c0 1300 	strd	r1, r3, [r0]
 80a6bfa:	4b0b      	ldr	r3, [pc, #44]	; (80a6c28 <srand+0x58>)
 80a6bfc:	2100      	movs	r1, #0
 80a6bfe:	6083      	str	r3, [r0, #8]
 80a6c00:	230b      	movs	r3, #11
 80a6c02:	8183      	strh	r3, [r0, #12]
 80a6c04:	2001      	movs	r0, #1
 80a6c06:	e9c2 0104 	strd	r0, r1, [r2, #16]
 80a6c0a:	2200      	movs	r2, #0
 80a6c0c:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80a6c0e:	611c      	str	r4, [r3, #16]
 80a6c10:	615a      	str	r2, [r3, #20]
 80a6c12:	bd38      	pop	{r3, r4, r5, pc}
 80a6c14:	20000024 	.word	0x20000024
 80a6c18:	080a7450 	.word	0x080a7450
 80a6c1c:	080a7467 	.word	0x080a7467
 80a6c20:	abcd330e 	.word	0xabcd330e
 80a6c24:	e66d1234 	.word	0xe66d1234
 80a6c28:	0005deec 	.word	0x0005deec

080a6c2c <strcmp>:
 80a6c2c:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a6c30:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a6c34:	2a01      	cmp	r2, #1
 80a6c36:	bf28      	it	cs
 80a6c38:	429a      	cmpcs	r2, r3
 80a6c3a:	d0f7      	beq.n	80a6c2c <strcmp>
 80a6c3c:	1ad0      	subs	r0, r2, r3
 80a6c3e:	4770      	bx	lr

080a6c40 <strdup>:
 80a6c40:	4b02      	ldr	r3, [pc, #8]	; (80a6c4c <strdup+0xc>)
 80a6c42:	4601      	mov	r1, r0
 80a6c44:	6818      	ldr	r0, [r3, #0]
 80a6c46:	f000 b803 	b.w	80a6c50 <_strdup_r>
 80a6c4a:	bf00      	nop
 80a6c4c:	20000024 	.word	0x20000024

080a6c50 <_strdup_r>:
 80a6c50:	b570      	push	{r4, r5, r6, lr}
 80a6c52:	4604      	mov	r4, r0
 80a6c54:	4608      	mov	r0, r1
 80a6c56:	460d      	mov	r5, r1
 80a6c58:	f000 f80d 	bl	80a6c76 <strlen>
 80a6c5c:	1c46      	adds	r6, r0, #1
 80a6c5e:	4631      	mov	r1, r6
 80a6c60:	4620      	mov	r0, r4
 80a6c62:	f7fc fa55 	bl	80a3110 <_malloc_r>
 80a6c66:	4604      	mov	r4, r0
 80a6c68:	b118      	cbz	r0, 80a6c72 <_strdup_r+0x22>
 80a6c6a:	4632      	mov	r2, r6
 80a6c6c:	4629      	mov	r1, r5
 80a6c6e:	f7ff ff99 	bl	80a6ba4 <memcpy>
 80a6c72:	4620      	mov	r0, r4
 80a6c74:	bd70      	pop	{r4, r5, r6, pc}

080a6c76 <strlen>:
 80a6c76:	4603      	mov	r3, r0
 80a6c78:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a6c7c:	2a00      	cmp	r2, #0
 80a6c7e:	d1fb      	bne.n	80a6c78 <strlen+0x2>
 80a6c80:	1a18      	subs	r0, r3, r0
 80a6c82:	3801      	subs	r0, #1
 80a6c84:	4770      	bx	lr

080a6c86 <strncmp>:
 80a6c86:	4603      	mov	r3, r0
 80a6c88:	b510      	push	{r4, lr}
 80a6c8a:	b172      	cbz	r2, 80a6caa <strncmp+0x24>
 80a6c8c:	3901      	subs	r1, #1
 80a6c8e:	1884      	adds	r4, r0, r2
 80a6c90:	f813 0b01 	ldrb.w	r0, [r3], #1
 80a6c94:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 80a6c98:	4290      	cmp	r0, r2
 80a6c9a:	d101      	bne.n	80a6ca0 <strncmp+0x1a>
 80a6c9c:	42a3      	cmp	r3, r4
 80a6c9e:	d101      	bne.n	80a6ca4 <strncmp+0x1e>
 80a6ca0:	1a80      	subs	r0, r0, r2
 80a6ca2:	bd10      	pop	{r4, pc}
 80a6ca4:	2800      	cmp	r0, #0
 80a6ca6:	d1f3      	bne.n	80a6c90 <strncmp+0xa>
 80a6ca8:	e7fa      	b.n	80a6ca0 <strncmp+0x1a>
 80a6caa:	4610      	mov	r0, r2
 80a6cac:	e7f9      	b.n	80a6ca2 <strncmp+0x1c>
	...

080a6cb0 <_strtol_l.constprop.0>:
 80a6cb0:	2b01      	cmp	r3, #1
 80a6cb2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a6cb6:	4680      	mov	r8, r0
 80a6cb8:	d001      	beq.n	80a6cbe <_strtol_l.constprop.0+0xe>
 80a6cba:	2b24      	cmp	r3, #36	; 0x24
 80a6cbc:	d906      	bls.n	80a6ccc <_strtol_l.constprop.0+0x1c>
 80a6cbe:	f7fc fa2f 	bl	80a3120 <__errno>
 80a6cc2:	2316      	movs	r3, #22
 80a6cc4:	6003      	str	r3, [r0, #0]
 80a6cc6:	2000      	movs	r0, #0
 80a6cc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a6ccc:	460d      	mov	r5, r1
 80a6cce:	4f35      	ldr	r7, [pc, #212]	; (80a6da4 <_strtol_l.constprop.0+0xf4>)
 80a6cd0:	4628      	mov	r0, r5
 80a6cd2:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a6cd6:	5de6      	ldrb	r6, [r4, r7]
 80a6cd8:	f016 0608 	ands.w	r6, r6, #8
 80a6cdc:	d1f8      	bne.n	80a6cd0 <_strtol_l.constprop.0+0x20>
 80a6cde:	2c2d      	cmp	r4, #45	; 0x2d
 80a6ce0:	d12f      	bne.n	80a6d42 <_strtol_l.constprop.0+0x92>
 80a6ce2:	2601      	movs	r6, #1
 80a6ce4:	782c      	ldrb	r4, [r5, #0]
 80a6ce6:	1c85      	adds	r5, r0, #2
 80a6ce8:	2b00      	cmp	r3, #0
 80a6cea:	d057      	beq.n	80a6d9c <_strtol_l.constprop.0+0xec>
 80a6cec:	2b10      	cmp	r3, #16
 80a6cee:	d109      	bne.n	80a6d04 <_strtol_l.constprop.0+0x54>
 80a6cf0:	2c30      	cmp	r4, #48	; 0x30
 80a6cf2:	d107      	bne.n	80a6d04 <_strtol_l.constprop.0+0x54>
 80a6cf4:	7828      	ldrb	r0, [r5, #0]
 80a6cf6:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a6cfa:	2858      	cmp	r0, #88	; 0x58
 80a6cfc:	d149      	bne.n	80a6d92 <_strtol_l.constprop.0+0xe2>
 80a6cfe:	2310      	movs	r3, #16
 80a6d00:	786c      	ldrb	r4, [r5, #1]
 80a6d02:	3502      	adds	r5, #2
 80a6d04:	2700      	movs	r7, #0
 80a6d06:	f106 4e00 	add.w	lr, r6, #2147483648	; 0x80000000
 80a6d0a:	f10e 3eff 	add.w	lr, lr, #4294967295
 80a6d0e:	fbbe f9f3 	udiv	r9, lr, r3
 80a6d12:	4638      	mov	r0, r7
 80a6d14:	fb03 ea19 	mls	sl, r3, r9, lr
 80a6d18:	f1a4 0c30 	sub.w	ip, r4, #48	; 0x30
 80a6d1c:	f1bc 0f09 	cmp.w	ip, #9
 80a6d20:	d814      	bhi.n	80a6d4c <_strtol_l.constprop.0+0x9c>
 80a6d22:	4664      	mov	r4, ip
 80a6d24:	42a3      	cmp	r3, r4
 80a6d26:	dd22      	ble.n	80a6d6e <_strtol_l.constprop.0+0xbe>
 80a6d28:	2f00      	cmp	r7, #0
 80a6d2a:	db1d      	blt.n	80a6d68 <_strtol_l.constprop.0+0xb8>
 80a6d2c:	4581      	cmp	r9, r0
 80a6d2e:	d31b      	bcc.n	80a6d68 <_strtol_l.constprop.0+0xb8>
 80a6d30:	d101      	bne.n	80a6d36 <_strtol_l.constprop.0+0x86>
 80a6d32:	45a2      	cmp	sl, r4
 80a6d34:	db18      	blt.n	80a6d68 <_strtol_l.constprop.0+0xb8>
 80a6d36:	2701      	movs	r7, #1
 80a6d38:	fb00 4003 	mla	r0, r0, r3, r4
 80a6d3c:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a6d40:	e7ea      	b.n	80a6d18 <_strtol_l.constprop.0+0x68>
 80a6d42:	2c2b      	cmp	r4, #43	; 0x2b
 80a6d44:	bf04      	itt	eq
 80a6d46:	782c      	ldrbeq	r4, [r5, #0]
 80a6d48:	1c85      	addeq	r5, r0, #2
 80a6d4a:	e7cd      	b.n	80a6ce8 <_strtol_l.constprop.0+0x38>
 80a6d4c:	f1a4 0c41 	sub.w	ip, r4, #65	; 0x41
 80a6d50:	f1bc 0f19 	cmp.w	ip, #25
 80a6d54:	d801      	bhi.n	80a6d5a <_strtol_l.constprop.0+0xaa>
 80a6d56:	3c37      	subs	r4, #55	; 0x37
 80a6d58:	e7e4      	b.n	80a6d24 <_strtol_l.constprop.0+0x74>
 80a6d5a:	f1a4 0c61 	sub.w	ip, r4, #97	; 0x61
 80a6d5e:	f1bc 0f19 	cmp.w	ip, #25
 80a6d62:	d804      	bhi.n	80a6d6e <_strtol_l.constprop.0+0xbe>
 80a6d64:	3c57      	subs	r4, #87	; 0x57
 80a6d66:	e7dd      	b.n	80a6d24 <_strtol_l.constprop.0+0x74>
 80a6d68:	f04f 37ff 	mov.w	r7, #4294967295
 80a6d6c:	e7e6      	b.n	80a6d3c <_strtol_l.constprop.0+0x8c>
 80a6d6e:	2f00      	cmp	r7, #0
 80a6d70:	da07      	bge.n	80a6d82 <_strtol_l.constprop.0+0xd2>
 80a6d72:	2322      	movs	r3, #34	; 0x22
 80a6d74:	4670      	mov	r0, lr
 80a6d76:	f8c8 3000 	str.w	r3, [r8]
 80a6d7a:	2a00      	cmp	r2, #0
 80a6d7c:	d0a4      	beq.n	80a6cc8 <_strtol_l.constprop.0+0x18>
 80a6d7e:	1e69      	subs	r1, r5, #1
 80a6d80:	e005      	b.n	80a6d8e <_strtol_l.constprop.0+0xde>
 80a6d82:	b106      	cbz	r6, 80a6d86 <_strtol_l.constprop.0+0xd6>
 80a6d84:	4240      	negs	r0, r0
 80a6d86:	2a00      	cmp	r2, #0
 80a6d88:	d09e      	beq.n	80a6cc8 <_strtol_l.constprop.0+0x18>
 80a6d8a:	2f00      	cmp	r7, #0
 80a6d8c:	d1f7      	bne.n	80a6d7e <_strtol_l.constprop.0+0xce>
 80a6d8e:	6011      	str	r1, [r2, #0]
 80a6d90:	e79a      	b.n	80a6cc8 <_strtol_l.constprop.0+0x18>
 80a6d92:	2430      	movs	r4, #48	; 0x30
 80a6d94:	2b00      	cmp	r3, #0
 80a6d96:	d1b5      	bne.n	80a6d04 <_strtol_l.constprop.0+0x54>
 80a6d98:	2308      	movs	r3, #8
 80a6d9a:	e7b3      	b.n	80a6d04 <_strtol_l.constprop.0+0x54>
 80a6d9c:	2c30      	cmp	r4, #48	; 0x30
 80a6d9e:	d0a9      	beq.n	80a6cf4 <_strtol_l.constprop.0+0x44>
 80a6da0:	230a      	movs	r3, #10
 80a6da2:	e7af      	b.n	80a6d04 <_strtol_l.constprop.0+0x54>
 80a6da4:	080a74e5 	.word	0x080a74e5

080a6da8 <strtol>:
 80a6da8:	4613      	mov	r3, r2
 80a6daa:	460a      	mov	r2, r1
 80a6dac:	4601      	mov	r1, r0
 80a6dae:	4802      	ldr	r0, [pc, #8]	; (80a6db8 <strtol+0x10>)
 80a6db0:	6800      	ldr	r0, [r0, #0]
 80a6db2:	f7ff bf7d 	b.w	80a6cb0 <_strtol_l.constprop.0>
 80a6db6:	bf00      	nop
 80a6db8:	20000024 	.word	0x20000024

080a6dbc <dynalib_user>:
 80a6dbc:	080a0021 080a0061 080a0089 080a008d     !...a...........
 80a6dcc:	00000000 546e7552 5b656d69 64323025     ....RunTime[%02d
 80a6ddc:	3230253a 30253a64 005d6432 6e755220     :%02d:%02d]. Run
 80a6dec:	656d6954 746f4e20 74657920 6c617620     Time Not yet val
 80a6dfc:	57006469 5f646e69 3a726944 726f4e00     id.Wind_Dir:.Nor
 80a6e0c:	4e006874 4500454e 4500454e 00747361     th.NNE.ENE.East.
 80a6e1c:	00455345 00455353 74756f53 53530068     ESE.SSE.South.SS
 80a6e2c:	53570057 65570057 57007473 4e00574e     W.WSW.West.WNW.N
 80a6e3c:	4e00574e 6957206f 2000646e 646e6957     NW.No Wind. Wind
 80a6e4c:	6570535f 003a6465 2c68706d 6e690020     _Speed:.mph, .in
 80a6e5c:	00202c2e 6c696144 61522079 003a6e69     ., .Daily Rain:.
 80a6e6c:	00202c46 696d7548 79746964 2525003a     F, .Humidity:.%%
 80a6e7c:	4200202c 5f6f7261 706d6554 7250003a     , .Baro_Temp:.Pr
 80a6e8c:	75737365 003a6572 2c615068 6f530020     essure:.hPa, .So
 80a6e9c:	545f6c69 3a706d65 696f5300 6f4d5f6c     il_Temp:.Soil_Mo
 80a6eac:	75746973 003a6572 696d754c 73756f6e     siture:.Luminous
 80a6ebc:	756c465f 43003a78 003a324f 434f5674     _Flux:.CO2:.tVOC
 80a6ecc:	5553003a 53454343 44490053 5252455f     :.SUCCESS.ID_ERR
 80a6edc:	4900524f 455f4332 524f5252 544e4900     OR.I2C_ERROR.INT
 80a6eec:	414e5245 52455f4c 00524f52 454e4547     ERNAL_ERROR.GENE
 80a6efc:	5f434952 4f525245 6e550052 63657073     RIC_ERROR.Unspec
 80a6f0c:	65696669 72652064 2e726f72 43796d00     ified error..myC
 80a6f1c:	31385343 65622e31 206e6967 74697865     CS811.begin exit
 80a6f2c:	77206465 3a687469 75700020 6c654462     ed with: .pubDel
 80a6f3c:	54577961 70005248 65446275 5779616c     ayWTHR.pubDelayW
 80a6f4c:	00444e49 65736572 76654474 00656369     IND.resetDevice.
 80a6f5c:	69676964 726c6174 00646165 69676964     digitalread.digi
 80a6f6c:	776c6174 65746972 616e6100 72676f6c     talwrite.analogr
 80a6f7c:	00646165 6c616e61 7277676f 00657469     ead.analogwrite.
 80a6f8c:	65736572 72694174 736e6553 7700726f     resetAirSensor.w
 80a6f9c:	64646e69 77007269 73646e69 64656570     inddir.windspeed
 80a6fac:	0068706d 646e6977 74737567 0068706d     mph.windgustmph.
 80a6fbc:	646e6977 74737567 00726964 646e6977     windgustdir.wind
 80a6fcc:	76615f73 006d3267 646e6977 76615f64     s_avg2m.windd_av
 80a6fdc:	006d3267 646e6977 68706d67 6d30315f     g2m.windgmph_10m
 80a6fec:	6e697700 69646764 30315f72 6164006d     .windgdir_10m.da
 80a6ffc:	72796c69 696e6961 7568006e 6964696d     ilyrainin.humidi
 80a700c:	73007974 746c696f 66706d65 73617000     ty.soiltempf.pas
 80a701c:	736c6163 72616200 6d65546f 6f730070     cals.baroTemp.so
 80a702c:	6f4d6c69 75747369 4c006572 6e656d75     ilMoisture.Lumen
 80a703c:	756c4673 69610078 4f565472 69610043     sFlux.airTVOC.ai
 80a704c:	324f4372 69614600 2064656c 67206f74     rCO2.Failed to g
 80a705c:	45207465 524f5252 2044495f 69676572     et ERROR_ID regi
 80a706c:	72657473 7245002e 3a726f72 65480020     ster..Error: .He
 80a707c:	72657461 70707553 4800796c 65746165     aterSupply.Heate
 80a708c:	75614672 4d00746c 65527861 74736973     rFault.MaxResist
 80a709c:	65636e61 61654d00 646f4d73 766e4965     ance.MeasModeInv
 80a70ac:	64696c61 61655200 67655264 61766e49     alid.ReadRegInva
 80a70bc:	0064696c 4967734d 6c61766e 7b006469     lid.MsgInvalid.{
 80a70cc:	6d756822 74696469 253a2279 74222c66     "humidity":%f,"t
 80a70dc:	46706d65 66253a22 7270222c 75737365     empF":%f,"pressu
 80a70ec:	50686572 253a2261 70222c66 73736572     rehPa":%f,"press
 80a70fc:	48657275 253a2267 62222c66 546f7261     ureHg":%f,"baroT
 80a710c:	46706d65 66253a22 6f53222c 65546c69     empF":%f,"SoilTe
 80a711c:	2246706d 2c66253a 696f5322 696f4d6c     mpF":%f,"SoilMoi
 80a712c:	72757473 253a2265 4c222c64 6e696d75     sture":%d,"Lumin
 80a713c:	4673756f 2278756c 2c66253a 72694122     ousFlux":%f,"Air
 80a714c:	434f5654 64253a22 6961222c 324f4372     TVOC":%d,"airCO2
 80a715c:	64253a22 4d4d007d 54414557 00524548     ":%d}.MMWEATHER.
 80a716c:	45574d4d 45485441 75502052 73696c62     MMWEATHER Publis
 80a717c:	61462068 64656c69 77227b00 64646e69     h Failed.{"windd
 80a718c:	3a227269 222c6425 646e6977 65657073     ir":%d,"windspee
 80a719c:	68706d64 66253a22 6977222c 7567646e     dmph":%f,"windgu
 80a71ac:	706d7473 253a2268 77222c66 67646e69     stmph":%f,"windg
 80a71bc:	64747375 3a227269 222c6425 646e6977     ustdir":%d,"wind
 80a71cc:	6d647073 615f6870 6d326776 66253a22     spdmph_avg2m":%f
 80a71dc:	6977222c 6964646e 76615f72 226d3267     ,"winddir_avg2m"
 80a71ec:	2c64253a 6e697722 73756764 68706d74     :%d,"windgustmph
 80a71fc:	6d30315f 66253a22 6977222c 7567646e     _10m":%f,"windgu
 80a720c:	69647473 30315f72 253a226d 72222c64     stdir_10m":%d,"r
 80a721c:	696e6961 253a226e 64222c66 796c6961     ainin":%f,"daily
 80a722c:	6e696172 3a226e69 007d6625 49574d4d     rainin":%f}.MMWI
 80a723c:	4d00444e 4e49574d 75502044 73696c62     ND.MMWIND Publis
 80a724c:	61462068 64656c69 48004100 00484749     h Failed.A.HIGH.
 80a725c:	00574f4c                                LOW.

080a7260 <CSWTCH.58>:
 80a7260:	00bc005e 504d0177 3131334c 20324135     ^...w.MPL3115A2 
 80a7270:	6e756f46 69530064 31323037 756f4620     Found.Si7021 Fou
 80a7280:	4800646e 31325554 6f462044 00646e75     nd.HTU21D Found.
 80a7290:	334c504d 41353131 4f4e2032 6f462054     MPL3115A2 NOT Fo
 80a72a0:	00646e75 54206f4e 2f706d65 696d7548     und.No Temp/Humi
 80a72b0:	79746964 76654420 20656369 65746544     dity Device Dete
 80a72c0:	64657463 206f4e00 69766544 20736563     cted.No Devices 
 80a72d0:	65746544 64657463 6e616e00 666e6900     Detected.nan.inf
 80a72e0:	66766f00 70706100 2d592500 252d6d25     .ovf.app.%Y-%m-%
 80a72f0:	48255464 3a4d253a 7a255325 63736100     dT%H:%M:%S%z.asc
 80a7300:	656d6974 00000000                       time....

080a7308 <_ZTVSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE>:
	...
 80a7310:	080a3849 080a384f 080a388d 080a385d     I8..O8...8..]8..
 80a7320:	080a384b                                K8..

080a7324 <_ZTV9IPAddress>:
	...
 80a732c:	080a3dcf 080a3dcd 080a3e01              .=...=...>..

080a7338 <_ZTV9USBSerial>:
	...
 80a7340:	080a3e99 080a3eff 080a3ed7 080a3405     .>...>...>...4..
 80a7350:	080a3ec9 080a3e9b 080a3eab 080a3ef9     .>...>...>...>..
 80a7360:	080a3ebb 080a3e95                       .>...>..

080a7368 <_ZTV11USARTSerial>:
	...
 80a7370:	080a4055 080a40bd 080a4099 080a3405     U@...@...@...4..
 80a7380:	080a4069 080a4085 080a4077 080a4093     i@...@..w@...@..
 80a7390:	080a4057 080a405b                       W@..[@..

080a7398 <_ZTV7TwoWire>:
	...
 80a73a0:	080a41b5 080a41ff 080a41d7 080a41b7     .A...A...A...A..
 80a73b0:	080a41df 080a41e7 080a41ef 080a41f7     .A...A...A...A..

080a73c0 <_ZTVN5spark9WiFiClassE>:
	...
 80a73c8:	080a4347 080a433d 080a4333 080a42b1     GC..=C..3C...B..
 80a73d8:	080a3653 080a4327 080a43a5 080a43ad     S6..'C...C...C..
 80a73e8:	080a431b 080a4313 080a4309 080a42ff     .C...C...C...B..
 80a73f8:	080a42bb                                .B..

080a73fc <_ZTVN5spark12NetworkClassE>:
	...
 80a7404:	080a4365 080a436f 080a4379 080a4383     eC..oC..yC...C..
 80a7414:	080a438d 080a4399 080a43a5 080a43ad     .C...C...C...C..
 80a7424:	080a43b5 080a43c1 080a43c9 080a43d3     .C...C...C...C..
 80a7434:	080a43dd                                .C..

080a7438 <_ZSt7nothrow>:
	...

080a7440 <TWO52>:
 80a7440:	00000000 43300000 00000000 c3300000     ......0C......0.
 80a7450:	4e454552 616d2054 636f6c6c 63757320     REENT malloc suc
 80a7460:	64656563 2f006465 2f746e6d 6b726f77     ceeded./mnt/work
 80a7470:	63617073 6f772f65 70736b72 2f656361     space/workspace/
 80a7480:	2d434347 702d3031 6c657069 2f656e69     GCC-10-pipeline/
 80a7490:	6b6e656a 2d736e69 2d434347 702d3031     jenkins-GCC-10-p
 80a74a0:	6c657069 2d656e69 325f3834 31303230     ipeline-48_20201
 80a74b0:	5f343231 36303631 36303831 732f3134     124_1606180641/s
 80a74c0:	6e2f6372 696c7765 656e2f62 62696c77     rc/newlib/newlib
 80a74d0:	62696c2f 74732f63 62696c64 6e61722f     /libc/stdlib/ran
 80a74e0:	00632e64                                d.c.

080a74e4 <_ctype_>:
 80a74e4:	20202000 20202020 28282020 20282828     .         ((((( 
 80a74f4:	20202020 20202020 20202020 20202020                     
 80a7504:	10108820 10101010 10101010 10101010      ...............
 80a7514:	04040410 04040404 10040404 10101010     ................
 80a7524:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80a7534:	01010101 01010101 01010101 10101010     ................
 80a7544:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80a7554:	02020202 02020202 02020202 10101010     ................
 80a7564:	00000020 00000000 00000000 00000000      ...............
	...

080a75e5 <link_const_variable_data_end>:
 80a75e5:	00          	.byte	0x00
	...

080a75e8 <link_constructors_location>:
 80a75e8:	080a14f9 	.word	0x080a14f9
 80a75ec:	080a31b5 	.word	0x080a31b5
 80a75f0:	080a3661 	.word	0x080a3661
 80a75f4:	080a3671 	.word	0x080a3671
 80a75f8:	080a36cd 	.word	0x080a36cd
 80a75fc:	080a4351 	.word	0x080a4351
 80a7600:	080a442d 	.word	0x080a442d
 80a7604:	080a45d1 	.word	0x080a45d1

080a7608 <link_constructors_end>:
	...
